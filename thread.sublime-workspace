{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "// See LICENSE.SiFive for license details.\n\npackage freechips.rocketchip.amba.custom\n\nimport Chisel._\nimport freechips.rocketchip.config.Parameters\nimport freechips.rocketchip.diplomacy._\nimport freechips.rocketchip.diplomaticobjectmodel.logicaltree.{BusMemoryLogicalTreeNode, LogicalModuleTree, LogicalTreeNode}\nimport freechips.rocketchip.diplomaticobjectmodel.model.AXI4_Lite\nimport freechips.rocketchip.util._\nimport freechips.rocketchip.amba._\n\n// Setting wcorrupt=true is not enough to enable the w.user field\n// You must also list AMBACorrupt in your master's requestFields\nclass CustomRAM(\n    address: AddressSet,\n    parentLogicalTreeNode: Option[LogicalTreeNode] = None,\n    beatBytes: Int = 8,\n    devName: Option[String] = None,\n    errors: Seq[AddressSet] = Nil,\n    wcorrupt: Boolean = true)\n  (implicit p: Parameters) extends DiplomaticSRAM(address, beatBytes, devName)\n{\n  val node = CustomSlaveNode(Seq(CustomSlavePortParameters(\n    Seq(CustomSlaveParameters(\n      address       = List(address) ++ errors,\n      resources     = resources,\n      supportsRead  = TransferSizes(1, beatBytes),\n      supportsWrite = TransferSizes(1, beatBytes))),\n    beatBytes  = beatBytes,\n    minLatency = 1)))\n\n  private val outer = this\n\n  lazy val module = new LazyModuleImp(this) with HasJustOneSeqMem {\n    val (in, edgeIn) = node.in(0)\n    val laneDataBits = 8\n    val (mem, omSRAM, omMem) = makeSinglePortedByteWriteSeqMem(\n                                  size = BigInt(CustomParameters.queue_depth),\n                                  lanes = beatBytes,\n                                  bits = laneDataBits)\n    val eccCode = None\n    val address = outer.address\n\n    val w_addr = Cat((mask zip (in.a.bits.addr >> log2Ceil(beatBytes)).asBools).filter(_._1).map(_._2).reverse)\n    val w_sel0 = address.contains(in.a.bits.addr)\n\n    val head = RegInit(0.U(log2Up(CustomParameters.queue_depth*2).W))\n    val tail = RegInit(0.U(log2Up(CustomParameters.queue_depth*2).W))\n    def isEmpty = (tail(log2Up(CustomParameters.queue_depth)-1,0) === head(log2Up(CustomParameters.queue_depth)-1,0))\n    def isnFull = (tail(log2Up(CustomParameters.queue_depth)-1,0) =/= (head + 1.U)(log2Up(CustomParameters.queue_depth)-1,0))\n\n    val s1 = RegInit(0.U.asTypeOf(chisel3.util.Valid(in.a.bits.cloneType)));chisel3.dontTouch(s1)\n    s1.bits := in.a.bits\n    \n    in.a.ready := isnFull\n    val wdata = Vec.tabulate(beatBytes) { i => in.a.bits.data(8*(i+1)-1, 8*i) }\n    when (in.a.fire() && w_sel0 && in.a.bits.opcode === CustomParameters.OPCODE_ENQ) {\n      mem.write(head, wdata, Fill(beatBytes, true.B).asBools)\n      head := head + 1.U\n    }\n\n    when (in.a.fire() && w_sel0 && in.a.bits.opcode === CustomParameters.OPCODE_DEQ) {\n      mem.read(tial, wdata, Fill(beatBytes, true.B).asBools)\n      head := head + 1.U\n    }\n\n    //by dongdeji in. b.valid := w_full\n    //by dongdeji in.a.ready := in. w.valid && (in.b.ready || !w_full)\n    //by dongdeji in. w.ready := in.aw.valid && (in.b.ready || !w_full)\n\n    //in.b.bits.id   := w_id\n    //in.b.bits.resp := 10.U//by dongdeji Mux(w_sel1, CustomParameters.RESP_OKAY, CustomParameters.RESP_DECERR)\n    //by dongdeji in.b.bits.echo :<= w_echo\n\n    //by dongdeji val r_full = RegInit(Bool(false))\n    //by dongdeji val r_id   = Reg(UInt())\n    //by dongdeji val r_echo = Reg(BundleMap(in.params.echoFields))\n\n    //by dongdeji when (in. r.fire()) { r_full := Bool(false) }\n    //by dongdeji when (in.ar.fire()) { r_full := Bool(true) }\n\n    //by dongdeji when (in.ar.fire()) {\n    //by dongdeji   r_id := in.ar.bits.id\n    //by dongdeji   r_sel1 := r_sel0\n    //by dongdeji   r_echo :<= in.ar.bits.echo\n    //by dongdeji }\n\n    //by dongdeji val ren = in.ar.fire()\n    //by dongdeji val rdata = mem.readAndHold(r_addr, ren)\n    //by dongdeji val rcorrupt = corrupt.map(_.readAndHold(r_addr, ren)(0)).getOrElse(Bool(false))\n\n    //by dongdeji in. r.valid := r_full\n    //by dongdeji in.ar.ready := in.r.ready || !r_full\n\n    //by dongdeji in.r.bits.id   := r_id\n    //by dongdeji in.r.bits.resp := Mux(r_sel1, Mux(rcorrupt, CustomParameters.RESP_SLVERR, CustomParameters.RESP_OKAY), CustomParameters.RESP_DECERR)\n    //by dongdeji in.r.bits.data := Cat(rdata.reverse)\n    //by dongdeji in.r.bits.echo :<= r_echo\n    //by dongdeji in.r.bits.last := Bool(true)\n  }\n}\n\nobject CustomRAM\n{\n  def apply(\n    address: AddressSet,\n    parentLogicalTreeNode: Option[LogicalTreeNode] = None,\n    beatBytes: Int = 4,\n    devName: Option[String] = None,\n    errors: Seq[AddressSet] = Nil,\n    wcorrupt: Boolean = true)\n  (implicit p: Parameters) =\n  {\n    val customram = LazyModule(new CustomRAM(\n      address = address,\n      beatBytes = beatBytes,\n      devName = devName,\n      errors = errors,\n      wcorrupt = wcorrupt))\n    customram.node\n  }\n}\n",
			"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala",
			"file_size": 4604,
			"file_write_time": 132797288064885755,
			"settings":
			{
				"buffer_size": 4784,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					9,
					1,
					"right_delete",
					null,
					"AQAAAH0EAAAAAAAAfQQAAAAAAACTAAAACiAgICAgIC8vYnkgZG9uZ2RlamkgcmVnaW9uVHlwZSAgICA9IGlmIChjYWNoZWFibGUpIFJlZ2lvblR5cGUuVU5DQUNIRUQgZWxzZSBSZWdpb25UeXBlLklERU1QT1RFTlQsCiAgICAgIC8vYnkgZG9uZ2RlamkgZXhlY3V0YWJsZSAgICA9IGV4ZWN1dGFibGUs",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAB9BAAAAAAAABAFAAAAAAAAAAAAAAAA8L8"
				],
				[
					16,
					1,
					"right_delete",
					null,
					"AQAAAOIEAAAAAAAA4gQAAAAAAAAjAAAALyosCiAgICAgIGludGVybGVhdmVkSWQgPSBTb21lKDApKi8",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAADiBAAAAAAAAAUFAAAAAAAAAAAAAAAA8L8"
				],
				[
					23,
					1,
					"right_delete",
					null,
					"AQAAAAEFAAAAAAAAAQUAAAAAAABLAAAACiAgICAvL2J5IGRvbmdkZWppIHJlcXVlc3RLZXlzID0gaWYgKHdjb3JydXB0KSBTZXEoQU1CQUNvcnJ1cHQpIGVsc2UgU2VxKCks",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAABBQAAAAAAAEwFAAAAAAAAAAAAAAAA8L8"
				],
				[
					26,
					1,
					"right_delete",
					null,
					"AQAAAG4CAAAAAAAAbgIAAAAAAAAtAAAACiAgICAvL2J5IGRvbmdkZWppIGNhY2hlYWJsZTogQm9vbGVhbiA9IHRydWUs",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABuAgAAAAAAAJsCAAAAAAAAAAAAAAAA8L8"
				],
				[
					29,
					1,
					"right_delete",
					null,
					"AQAAAKkCAAAAAAAAqQIAAAAAAAAuAAAACiAgICAvL2J5IGRvbmdkZWppIGV4ZWN1dGFibGU6IEJvb2xlYW4gPSB0cnVlLA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACpAgAAAAAAANcCAAAAAAAAAAAAAAAA8L8"
				],
				[
					59,
					14,
					"indent",
					null,
					"KgAAAJkFAAAAAAAAmwUAAAAAAAAAAAAAzQUAAAAAAADPBQAAAAAAAAAAAADoBQAAAAAAAOoFAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAAzwUAAAAAAADRBQAAAAAAAAAAAADsBQAAAAAAAO4FAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA0QUAAAAAAADTBQAAAAAAAAAAAADwBQAAAAAAAPIFAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA0wUAAAAAAADVBQAAAAAAAAAAAAD0BQAAAAAAAPYFAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA1QUAAAAAAADXBQAAAAAAAAAAAAD4BQAAAAAAAPoFAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA1wUAAAAAAADZBQAAAAAAAAAAAAD8BQAAAAAAAP4FAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA2QUAAAAAAADbBQAAAAAAAAAAAAAABgAAAAAAAAIGAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA2wUAAAAAAADdBQAAAAAAAAAAAAAEBgAAAAAAAAYGAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA3QUAAAAAAADfBQAAAAAAAAAAAAAIBgAAAAAAAAoGAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA3wUAAAAAAADhBQAAAAAAAAAAAAAMBgAAAAAAAA4GAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA4QUAAAAAAADjBQAAAAAAAAAAAAAQBgAAAAAAABIGAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA4wUAAAAAAADlBQAAAAAAAAAAAAAUBgAAAAAAABYGAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA5QUAAAAAAADnBQAAAAAAAAAAAAAYBgAAAAAAABoGAAAAAAAAAAAAAJkFAAAAAAAAmwUAAAAAAAAAAAAA5wUAAAAAAADpBQAAAAAAAAAAAAAcBgAAAAAAAB4GAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAD+BQAAAAAAAJ8FAAAAAAAAAAAAAAAA8L8"
				],
				[
					103,
					2,
					"right_delete",
					null,
					"AgAAAIoGAAAAAAAAigYAAAAAAAAhAgAACiAgICAvL2J5IGRvbmdkZWppIHBhcmVudExvZ2ljYWxUcmVlTm9kZS5tYXAgewogICAgLy9ieSBkb25nZGVqaSAgIGNhc2UgcGFyZW50TFROID0+CiAgICAvL2J5IGRvbmdkZWppICAgICBkZWYgc3JhbUxvZ2ljYWxUcmVlTm9kZSA9IG5ldyBCdXNNZW1vcnlMb2dpY2FsVHJlZU5vZGUoCiAgICAvL2J5IGRvbmdkZWppICAgICAgIGRldmljZSA9IGRldmljZSwKICAgIC8vYnkgZG9uZ2RlamkgICAgICAgb21TUkFNcyA9IFNlcShvbVNSQU0pLAogICAgLy9ieSBkb25nZGVqaSAgICAgICBidXNQcm90b2NvbCA9IG5ldyBBWEk0X0xpdGUoTm9uZSksCiAgICAvL2J5IGRvbmdkZWppICAgICAgIGRhdGFFQ0MgPSBOb25lLAogICAgLy9ieSBkb25nZGVqaSAgICAgICBoYXNBdG9taWNzID0gTm9uZSwKICAgIC8vYnkgZG9uZ2RlamkgICAgICAgYnVzUHJvdG9jb2xTcGVjaWZpY2F0aW9uID0gTm9uZSkKICAgIC8vYnkgZG9uZ2RlamkgICAgIExvZ2ljYWxNb2R1bGVUcmVlLmFkZChwYXJlbnRMVE4sIHNyYW1Mb2dpY2FsVHJlZU5vZGUpCiAgICAvL2J5IGRvbmdkZWppIH2KBgAAAAAAAIoGAAAAAAAAAQAAAAo",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACrCAAAAAAAAIoGAAAAAAAAAAAAAAAA8L8"
				],
				[
					137,
					1,
					"right_delete",
					null,
					"AQAAAIsGAAAAAAAAiwYAAAAAAAAaAQAAICAgIC8vYnkgZG9uZ2RlamkgdmFsIGNvcnJ1cHQgPSBpZiAoZWRnZUluLmJ1bmRsZS5yZXF1ZXN0RmllbGRzLmNvbnRhaW5zKEFNQkFDb3JydXB0KSkgU29tZShTZXFNZW0oMSA8PCBtYXNrLmZpbHRlcihiPT5iKS5zaXplLCBVSW50KHdpZHRoPTIpKSkgZWxzZSBOb25lCgogICAgLy9ieSBkb25nZGVqaSB2YWwgcl9hZGRyID0gQ2F0KChtYXNrIHppcCAoaW4uYXIuYml0cy5hZGRyID4+IGxvZzJDZWlsKGJlYXRCeXRlcykpLmFzQm9vbHMpLmZpbHRlcihfLl8xKS5tYXAoXy5fMikucmV2ZXJzZSkK",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACLBgAAAAAAAKUHAAAAAAAAAAAAAAAA8L8"
				],
				[
					140,
					1,
					"right_delete",
					null,
					"AQAAAPsGAAAAAAAA+wYAAAAAAABBAAAAICAgIC8vYnkgZG9uZ2RlamkgdmFsIHJfc2VsMCA9IGFkZHJlc3MuY29udGFpbnMoaW4uYXIuYml0cy5hZGRyKQo",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAD7BgAAAAAAADwHAAAAAAAAAAAAAAAA8L8"
				],
				[
					143,
					1,
					"right_delete",
					null,
					"AQAAAHEHAAAAAAAAcQcAAAAAAABvAAAAICAgIC8vYnkgZG9uZ2RlamkgdmFsIHdfZWNobyA9IFJlZyhCdW5kbGVNYXAoaW4ucGFyYW1zLmVjaG9GaWVsZHMpKQogICAgLy9ieSBkb25nZGVqaSB2YWwgcl9zZWwxID0gUmVnKHJfc2VsMCkK",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABxBwAAAAAAAOAHAAAAAAAAAAAAAAAA8L8"
				],
				[
					28,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AQAAAC0HAAAAAAAALgcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAALQcAAAAAAAAtBwAAAAAAAAAAAAAAAPC/"
				],
				[
					29,
					1,
					"insert",
					{
						"characters": "    "
					},
					"BAAAAC4HAAAAAAAALwcAAAAAAAAAAAAALwcAAAAAAAAwBwAAAAAAAAAAAAAwBwAAAAAAADEHAAAAAAAAAAAAADEHAAAAAAAAMgcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAALgcAAAAAAAAuBwAAAAAAAAAAAAAAAPC/"
				],
				[
					30,
					1,
					"paste",
					null,
					"AQAAADIHAAAAAAAAUwcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAMgcAAAAAAAAyBwAAAAAAAAAAAAAAAPC/"
				],
				[
					31,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAFMHAAAAAAAAVAcAAAAAAAAAAAAAVAcAAAAAAABYBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUwcAAAAAAABTBwAAAAAAAAAAAAAAAPC/"
				],
				[
					32,
					1,
					"paste",
					null,
					"AQAAAFgHAAAAAAAAeQcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWAcAAAAAAABYBwAAAAAAAAAAAAAAAPC/"
				],
				[
					36,
					1,
					"insert",
					{
						"characters": "head"
					},
					"BQAAADYHAAAAAAAANwcAAAAAAAAAAAAANwcAAAAAAAA3BwAAAAAAAAYAAAB3X2Z1bGw3BwAAAAAAADgHAAAAAAAAAAAAADgHAAAAAAAAOQcAAAAAAAAAAAAAOQcAAAAAAAA6BwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAANgcAAAAAAAA8BwAAAAAAAAAAAAAAAPC/"
				],
				[
					46,
					1,
					"insert",
					{
						"characters": "tail"
					},
					"BQAAAFoHAAAAAAAAWwcAAAAAAAAAAAAAWwcAAAAAAABbBwAAAAAAAAYAAAB3X2Z1bGxbBwAAAAAAAFwHAAAAAAAAAAAAAFwHAAAAAAAAXQcAAAAAAAAAAAAAXQcAAAAAAABeBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWgcAAAAAAABgBwAAAAAAAAAAAAAAAPC/"
				],
				[
					56,
					1,
					"paste",
					null,
					"AgAAAEUHAAAAAAAASwcAAAAAAAAAAAAASwcAAAAAAABLBwAAAAAAAAsAAABCb29sKGZhbHNlKQ",
					"AQAAAAAAAAABAAAARQcAAAAAAABQBwAAAAAAAAAAAAAAAPC/"
				],
				[
					61,
					1,
					"paste",
					null,
					"AgAAAGQHAAAAAAAAagcAAAAAAAAAAAAAagcAAAAAAABqBwAAAAAAAAsAAABCb29sKGZhbHNlKQ",
					"AQAAAAAAAAABAAAAZAcAAAAAAABvBwAAAAAAAAAAAAAAAPC/"
				],
				[
					67,
					1,
					"insert",
					{
						"characters": "32.w"
					},
					"BAAAAEoHAAAAAAAASwcAAAAAAAAAAAAASwcAAAAAAABMBwAAAAAAAAAAAABMBwAAAAAAAE0HAAAAAAAAAAAAAE0HAAAAAAAATgcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASgcAAAAAAABKBwAAAAAAAAAAAAAAAPC/"
				],
				[
					68,
					1,
					"left_delete",
					null,
					"AQAAAE0HAAAAAAAATQcAAAAAAAABAAAAdw",
					"AQAAAAAAAAABAAAATgcAAAAAAABOBwAAAAAAAAAAAAAAAPC/"
				],
				[
					69,
					1,
					"insert",
					{
						"characters": "W"
					},
					"AQAAAE0HAAAAAAAATgcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATQcAAAAAAABNBwAAAAAAAAAAAAAAAPC/"
				],
				[
					72,
					1,
					"insert",
					{
						"characters": "32.W"
					},
					"BAAAAG0HAAAAAAAAbgcAAAAAAAAAAAAAbgcAAAAAAABvBwAAAAAAAAAAAABvBwAAAAAAAHAHAAAAAAAAAAAAAHAHAAAAAAAAcQcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbQcAAAAAAABtBwAAAAAAAAAAAAAAAPC/"
				],
				[
					77,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAHMHAAAAAAAAdAcAAAAAAAAAAAAAdAcAAAAAAAB4BwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcwcAAAAAAABzBwAAAAAAAAAAAAAAAPC/"
				],
				[
					93,
					1,
					"right_delete",
					null,
					"AgAAAMsFAAAAAAAAywUAAAAAAAAaAAAAIDw8IG1hc2suZmlsdGVyKGI9PmIpLnNpemVaBwAAAAAAAFoHAAAAAAAABAAAACAgICA",
					"AQAAAAAAAAABAAAAywUAAAAAAADlBQAAAAAAAAAAAAAAAPC/"
				],
				[
					96,
					1,
					"paste",
					null,
					"AgAAAMkFAAAAAAAA2QUAAAAAAAAAAAAA2QUAAAAAAADZBQAAAAAAAAEAAAAx",
					"AQAAAAAAAAABAAAAygUAAAAAAADJBQAAAAAAAAAAAAAAAPC/"
				],
				[
					101,
					1,
					"insert",
					{
						"characters": "."
					},
					"AQAAANkFAAAAAAAA2gUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA2QUAAAAAAADZBQAAAAAAAAAAAAAAAPC/"
				],
				[
					102,
					1,
					"paste",
					null,
					"AQAAANoFAAAAAAAA5QUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA2gUAAAAAAADaBQAAAAAAAAAAAAAAAPC/"
				],
				[
					114,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAACoJAAAAAAAAKwkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAKgkAAAAAAAAqCQAAAAAAAAAAAAAAAPC/"
				],
				[
					115,
					1,
					"insert",
					{
						"characters": "&&"
					},
					"AgAAACsJAAAAAAAALAkAAAAAAAAAAAAALAkAAAAAAAAtCQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAKwkAAAAAAAArCQAAAAAAAAAAAAAAAPC/"
				],
				[
					116,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAC0JAAAAAAAALgkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAALQkAAAAAAAAtCQAAAAAAAAAAAAAAAPC/"
				],
				[
					122,
					1,
					"paste",
					null,
					"AQAAAC4JAAAAAAAAMgkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAALgkAAAAAAAAuCQAAAAAAAAAAAAAAAPC/"
				],
				[
					123,
					1,
					"insert",
					{
						"characters": "."
					},
					"AQAAADIJAAAAAAAAMwkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAMgkAAAAAAAAyCQAAAAAAAAAAAAAAAPC/"
				],
				[
					124,
					1,
					"paste",
					null,
					"AQAAADMJAAAAAAAAOQkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAMwkAAAAAAAAzCQAAAAAAAAAAAAAAAPC/"
				],
				[
					125,
					1,
					"insert",
					{
						"characters": " ==="
					},
					"BAAAADkJAAAAAAAAOgkAAAAAAAAAAAAAOgkAAAAAAAA7CQAAAAAAAAAAAAA7CQAAAAAAADwJAAAAAAAAAAAAADwJAAAAAAAAPQkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAOQkAAAAAAAA5CQAAAAAAAAAAAAAAAPC/"
				],
				[
					126,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAD0JAAAAAAAAPgkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPQkAAAAAAAA9CQAAAAAAAAAAAAAAAPC/"
				],
				[
					127,
					1,
					"paste",
					null,
					"AQAAAD4JAAAAAAAATgkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPgkAAAAAAAA+CQAAAAAAAAAAAAAAAPC/"
				],
				[
					128,
					1,
					"paste",
					null,
					"AQAAAE4JAAAAAAAAWAkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATgkAAAAAAABOCQAAAAAAAAAAAAAAAPC/"
				],
				[
					131,
					1,
					"insert",
					{
						"characters": "."
					},
					"AQAAAE4JAAAAAAAATwkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATgkAAAAAAABOCQAAAAAAAAAAAAAAAPC/"
				],
				[
					144,
					1,
					"insert",
					{
						"characters": ".bits"
					},
					"BQAAADIJAAAAAAAAMwkAAAAAAAAAAAAAMwkAAAAAAAA0CQAAAAAAAAAAAAA0CQAAAAAAADUJAAAAAAAAAAAAADUJAAAAAAAANgkAAAAAAAAAAAAANgkAAAAAAAA3CQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAMgkAAAAAAAAyCQAAAAAAAAAAAAAAAPC/"
				],
				[
					145,
					1,
					"insert",
					{
						"characters": "."
					},
					"AQAAADcJAAAAAAAAOAkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAANwkAAAAAAAA3CQAAAAAAAAAAAAAAAPC/"
				],
				[
					146,
					1,
					"left_delete",
					null,
					"AQAAADcJAAAAAAAANwkAAAAAAAABAAAALg",
					"AQAAAAAAAAABAAAAOAkAAAAAAAA4CQAAAAAAAAAAAAAAAPC/"
				],
				[
					148,
					1,
					"left_delete",
					null,
					"AQAAADcJAAAAAAAANwkAAAAAAAABAAAALg",
					"AQAAAAAAAAABAAAAOAkAAAAAAAA4CQAAAAAAAAAAAAAAAPC/"
				],
				[
					149,
					1,
					"insert",
					{
						"characters": "."
					},
					"AQAAADcJAAAAAAAAOAkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAANwkAAAAAAAA3CQAAAAAAAAAAAAAAAPC/"
				],
				[
					152,
					1,
					"right_delete",
					null,
					"AQAAAGgJAAAAAAAAaAkAAAAAAAAOAAAALy9ieSBkb25nZGVqaSA",
					"AQAAAAAAAAABAAAAdgkAAAAAAABoCQAAAAAAAAAAAAAAAPC/"
				],
				[
					163,
					1,
					"paste",
					null,
					"AgAAAHIJAAAAAAAAdgkAAAAAAAAAAAAAdgkAAAAAAAB2CQAAAAAAAAYAAAB3X2FkZHI",
					"AQAAAAAAAAABAAAAcgkAAAAAAAB4CQAAAAAAAAAAAAAAAPC/"
				],
				[
					191,
					1,
					"paste",
					null,
					"AgAAAH8JAAAAAAAArwkAAAAAAAAAAAAArwkAAAAAAACvCQAAAAAAABYAAABpbi53LmJpdHMuc3RyYi5hc0Jvb2xz",
					"AQAAAAAAAAABAAAAfwkAAAAAAACVCQAAAAAAAAAAAAAAAPC/"
				],
				[
					194,
					1,
					"right_delete",
					null,
					"AQAAACsJAAAAAAAAKwkAAAAAAAAzAAAAJiYgaW4uYS5iaXRzLm9wY29kZSA9PT0gQ3VzdG9tUGFyYW1ldGVycy5PUENPREVfRU5R",
					"AQAAAAAAAAABAAAAKwkAAAAAAABeCQAAAAAAAAAAAAAAAPC/"
				],
				[
					195,
					1,
					"left_delete",
					null,
					"AQAAACoJAAAAAAAAKgkAAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAKwkAAAAAAAArCQAAAAAAAAAAAAAAAPC/"
				],
				[
					207,
					1,
					"paste",
					null,
					"AgAAAEQJAAAAAAAATgkAAAAAAAAAAAAATgkAAAAAAABOCQAAAAAAAAUAAAB3ZGF0YQ",
					"AQAAAAAAAAABAAAASQkAAAAAAABECQAAAAAAAAAAAAAAAPC/"
				],
				[
					208,
					1,
					"insert",
					{
						"characters": "d"
					},
					"AQAAAE4JAAAAAAAATwkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATgkAAAAAAABOCQAAAAAAAAAAAAAAAPC/"
				],
				[
					209,
					2,
					"left_delete",
					null,
					"AgAAAE4JAAAAAAAATgkAAAAAAAABAAAAZE0JAAAAAAAATQkAAAAAAAABAAAALg",
					"AQAAAAAAAAABAAAATwkAAAAAAABPCQAAAAAAAAAAAAAAAPC/"
				],
				[
					210,
					1,
					"insert",
					{
						"characters": "."
					},
					"AQAAAE0JAAAAAAAATgkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATQkAAAAAAABNCQAAAAAAAAAAAAAAAPC/"
				],
				[
					216,
					1,
					"insert_completion",
					{
						"completion": "data",
						"format": "text",
						"keep_prefix": false,
						"must_insert": true,
						"trigger": "data"
					},
					"AQAAAE4JAAAAAAAAUgkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATgkAAAAAAABOCQAAAAAAAAAAAAAAAPC/"
				],
				[
					232,
					2,
					"right_delete",
					null,
					"AgAAAHYHAAAAAAAAdgcAAAAAAABBAQAAICAgIHZhbCB3X2Z1bGwgPSBSZWdJbml0KEJvb2woZmFsc2UpKQogICAgdmFsIHdfaWQgICA9IFJlZyhVSW50KCkpCiAgICB2YWwgd19zZWwxID0gUmVnKHdfc2VsMCkKCiAgICB3aGVuIChpbi5iLmZpcmUoKSkgeyB3X2Z1bGwgOj0gQm9vbChmYWxzZSkgfQogICAgd2hlbiAoaW4uYS5maXJlKCkpIHsgd19mdWxsIDo9IEJvb2wodHJ1ZSkgfQoKICAgIHdoZW4gKGluLmEuZmlyZSgpKSB7CiAgICAgIHdfaWQgOj0gaW4uYS5iaXRzLmlkCiAgICAgIHdfc2VsMSA6PSB3X3NlbDAKICAgICAgLy9ieSBkb25nZGVqaSB3X2VjaG8gOjw9IGluLmEuYml0cy5lY2hvCiAgICB9dgcAAAAAAAB2BwAAAAAAAAEAAAAK",
					"AQAAAAAAAAABAAAAtwgAAAAAAAB2BwAAAAAAAAAAAAAAAPC/"
				],
				[
					233,
					1,
					"insert",
					{
						"characters": "    "
					},
					"BAAAAHYHAAAAAAAAdwcAAAAAAAAAAAAAdwcAAAAAAAB4BwAAAAAAAAAAAAB4BwAAAAAAAHkHAAAAAAAAAAAAAHkHAAAAAAAAegcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdgcAAAAAAAB2BwAAAAAAAAAAAAAAAPC/"
				],
				[
					234,
					1,
					"insert",
					{
						"characters": "val"
					},
					"AwAAAHoHAAAAAAAAewcAAAAAAAAAAAAAewcAAAAAAAB8BwAAAAAAAAAAAAB8BwAAAAAAAH0HAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAegcAAAAAAAB6BwAAAAAAAAAAAAAAAPC/"
				],
				[
					235,
					1,
					"insert",
					{
						"characters": " s"
					},
					"AgAAAH0HAAAAAAAAfgcAAAAAAAAAAAAAfgcAAAAAAAB/BwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAfQcAAAAAAAB9BwAAAAAAAAAAAAAAAPC/"
				],
				[
					236,
					1,
					"insert",
					{
						"characters": "1"
					},
					"AQAAAH8HAAAAAAAAgAcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAfwcAAAAAAAB/BwAAAAAAAAAAAAAAAPC/"
				],
				[
					237,
					1,
					"insert",
					{
						"characters": " ="
					},
					"AgAAAIAHAAAAAAAAgQcAAAAAAAAAAAAAgQcAAAAAAACCBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAgAcAAAAAAACABwAAAAAAAAAAAAAAAPC/"
				],
				[
					238,
					1,
					"insert",
					{
						"characters": " Reg"
					},
					"BAAAAIIHAAAAAAAAgwcAAAAAAAAAAAAAgwcAAAAAAACEBwAAAAAAAAAAAACEBwAAAAAAAIUHAAAAAAAAAAAAAIUHAAAAAAAAhgcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAggcAAAAAAACCBwAAAAAAAAAAAAAAAPC/"
				],
				[
					239,
					1,
					"insert",
					{
						"characters": "Init"
					},
					"BAAAAIYHAAAAAAAAhwcAAAAAAAAAAAAAhwcAAAAAAACIBwAAAAAAAAAAAACIBwAAAAAAAIkHAAAAAAAAAAAAAIkHAAAAAAAAigcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAhgcAAAAAAACGBwAAAAAAAAAAAAAAAPC/"
				],
				[
					240,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAIoHAAAAAAAAjAcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAigcAAAAAAACKBwAAAAAAAAAAAAAAAPC/"
				],
				[
					243,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAIwHAAAAAAAAjQcAAAAAAAAAAAAAjQcAAAAAAACRBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjAcAAAAAAACMBwAAAAAAAAAAAAAAAPC/"
				],
				[
					250,
					1,
					"insert",
					{
						"characters": "0.U"
					},
					"BQAAAEYHAAAAAAAARwcAAAAAAAAAAAAARwcAAAAAAABHBwAAAAAAAAQAAABVSW50igcAAAAAAACKBwAAAAAAAAQAAAAgICAgRwcAAAAAAABIBwAAAAAAAAAAAABIBwAAAAAAAEkHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARgcAAAAAAABKBwAAAAAAAAAAAAAAAPC/"
				],
				[
					256,
					1,
					"insert",
					{
						"characters": "0.U"
					},
					"BAAAAGgHAAAAAAAAaQcAAAAAAAAAAAAAaQcAAAAAAABpBwAAAAAAAAQAAABVSW50aQcAAAAAAABqBwAAAAAAAAAAAABqBwAAAAAAAGsHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAaAcAAAAAAABsBwAAAAAAAAAAAAAAAPC/"
				],
				[
					264,
					1,
					"insert",
					{
						"characters": "0.U"
					},
					"AwAAAIkHAAAAAAAAigcAAAAAAAAAAAAAigcAAAAAAACLBwAAAAAAAAAAAACLBwAAAAAAAIwHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAiQcAAAAAAACJBwAAAAAAAAAAAAAAAPC/"
				],
				[
					265,
					1,
					"insert",
					{
						"characters": ".asType"
					},
					"BwAAAIwHAAAAAAAAjQcAAAAAAAAAAAAAjQcAAAAAAACOBwAAAAAAAAAAAACOBwAAAAAAAI8HAAAAAAAAAAAAAI8HAAAAAAAAkAcAAAAAAAAAAAAAkAcAAAAAAACRBwAAAAAAAAAAAACRBwAAAAAAAJIHAAAAAAAAAAAAAJIHAAAAAAAAkwcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjAcAAAAAAACMBwAAAAAAAAAAAAAAAPC/"
				],
				[
					266,
					1,
					"insert",
					{
						"characters": "of"
					},
					"AgAAAJMHAAAAAAAAlAcAAAAAAAAAAAAAlAcAAAAAAACVBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkwcAAAAAAACTBwAAAAAAAAAAAAAAAPC/"
				],
				[
					267,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAJUHAAAAAAAAlwcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAlQcAAAAAAACVBwAAAAAAAAAAAAAAAPC/"
				],
				[
					277,
					2,
					"right_delete",
					null,
					"AgAAAEAFAAAAAAAAQAUAAAAAAAAYAAAAICAgIHZhbCBsYW5lRGF0YUJpdHMgPSA4QAUAAAAAAABABQAAAAAAAAEAAAAK",
					"AQAAAAAAAAABAAAAWAUAAAAAAABABQAAAAAAAAAAAAAAAPC/"
				],
				[
					281,
					1,
					"insert",
					{
						"characters": "8"
					},
					"AgAAAC0GAAAAAAAALgYAAAAAAAAAAAAALgYAAAAAAAAuBgAAAAAAAAwAAABsYW5lRGF0YUJpdHM",
					"AQAAAAAAAAABAAAALQYAAAAAAAA5BgAAAAAAAAAAAAAAAPC/"
				],
				[
					313,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"BAAAAC8GAAAAAAAAMAYAAAAAAAAAAAAAMAYAAAAAAABSBgAAAAAAAAAAAAAwBgAAAAAAADAGAAAAAAAAIgAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwBgAAAAAAADQGAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAALwYAAAAAAAAvBgAAAAAAAAAAAAAAAPC/"
				],
				[
					314,
					2,
					"left_delete",
					null,
					"AgAAADIGAAAAAAAAMgYAAAAAAAACAAAAICAwBgAAAAAAADAGAAAAAAAAAgAAACAg",
					"AQAAAAAAAAABAAAANAYAAAAAAAA0BgAAAAAAAAAAAAAAAPC/"
				],
				[
					315,
					1,
					"insert",
					{
						"characters": "printlln"
					},
					"CAAAADAGAAAAAAAAMQYAAAAAAAAAAAAAMQYAAAAAAAAyBgAAAAAAAAAAAAAyBgAAAAAAADMGAAAAAAAAAAAAADMGAAAAAAAANAYAAAAAAAAAAAAANAYAAAAAAAA1BgAAAAAAAAAAAAA1BgAAAAAAADYGAAAAAAAAAAAAADYGAAAAAAAANwYAAAAAAAAAAAAANwYAAAAAAAA4BgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAMAYAAAAAAAAwBgAAAAAAAAAAAAAAAPC/"
				],
				[
					316,
					5,
					"left_delete",
					null,
					"BQAAADcGAAAAAAAANwYAAAAAAAABAAAAbjYGAAAAAAAANgYAAAAAAAABAAAAbDUGAAAAAAAANQYAAAAAAAABAAAAbDQGAAAAAAAANAYAAAAAAAABAAAAdDMGAAAAAAAAMwYAAAAAAAABAAAAbg",
					"AQAAAAAAAAABAAAAOAYAAAAAAAA4BgAAAAAAAAAAAAAAAPC/"
				],
				[
					317,
					2,
					"left_delete",
					null,
					"AgAAADIGAAAAAAAAMgYAAAAAAAABAAAAaTEGAAAAAAAAMQYAAAAAAAABAAAAcg",
					"AQAAAAAAAAABAAAAMwYAAAAAAAAzBgAAAAAAAAAAAAAAAPC/"
				],
				[
					318,
					1,
					"insert",
					{
						"characters": "rintln"
					},
					"BgAAADEGAAAAAAAAMgYAAAAAAAAAAAAAMgYAAAAAAAAzBgAAAAAAAAAAAAAzBgAAAAAAADQGAAAAAAAAAAAAADQGAAAAAAAANQYAAAAAAAAAAAAANQYAAAAAAAA2BgAAAAAAAAAAAAA2BgAAAAAAADcGAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAMQYAAAAAAAAxBgAAAAAAAAAAAAAAAPC/"
				],
				[
					319,
					7,
					"left_delete",
					null,
					"BwAAADYGAAAAAAAANgYAAAAAAAABAAAAbjUGAAAAAAAANQYAAAAAAAABAAAAbDQGAAAAAAAANAYAAAAAAAABAAAAdDMGAAAAAAAAMwYAAAAAAAABAAAAbjIGAAAAAAAAMgYAAAAAAAABAAAAaTEGAAAAAAAAMQYAAAAAAAABAAAAcjAGAAAAAAAAMAYAAAAAAAABAAAAcA",
					"AQAAAAAAAAABAAAANwYAAAAAAAA3BgAAAAAAAAAAAAAAAPC/"
				],
				[
					320,
					1,
					"insert",
					{
						"characters": "println"
					},
					"BwAAADAGAAAAAAAAMQYAAAAAAAAAAAAAMQYAAAAAAAAyBgAAAAAAAAAAAAAyBgAAAAAAADMGAAAAAAAAAAAAADMGAAAAAAAANAYAAAAAAAAAAAAANAYAAAAAAAA1BgAAAAAAAAAAAAA1BgAAAAAAADYGAAAAAAAAAAAAADYGAAAAAAAANwYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAMAYAAAAAAAAwBgAAAAAAAAAAAAAAAPC/"
				],
				[
					321,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAADcGAAAAAAAAOQYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAANwYAAAAAAAA3BgAAAAAAAAAAAAAAAPC/"
				],
				[
					324,
					1,
					"insert",
					{
						"characters": "s\"\""
					},
					"AwAAADgGAAAAAAAAOQYAAAAAAAAAAAAAOQYAAAAAAAA6BgAAAAAAAAAAAAA6BgAAAAAAADsGAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAOAYAAAAAAAA4BgAAAAAAAAAAAAAAAPC/"
				],
				[
					326,
					1,
					"insert",
					{
						"characters": "===="
					},
					"BAAAADoGAAAAAAAAOwYAAAAAAAAAAAAAOwYAAAAAAAA8BgAAAAAAAAAAAAA8BgAAAAAAAD0GAAAAAAAAAAAAAD0GAAAAAAAAPgYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAOgYAAAAAAAA6BgAAAAAAAAAAAAAAAPC/"
				],
				[
					327,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAD4GAAAAAAAAPwYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPgYAAAAAAAA+BgAAAAAAAAAAAAAAAPC/"
				],
				[
					328,
					1,
					"paste",
					null,
					"AQAAAD8GAAAAAAAARQYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPwYAAAAAAAA/BgAAAAAAAAAAAAAAAPC/"
				],
				[
					335,
					1,
					"paste",
					null,
					"AQAAAD8GAAAAAAAARQYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPwYAAAAAAAA/BgAAAAAAAAAAAAAAAPC/"
				],
				[
					336,
					1,
					"insert",
					{
						"characters": "：￥"
					},
					"AgAAAEUGAAAAAAAARgYAAAAAAAAAAAAARgYAAAAAAABHBgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARQYAAAAAAABFBgAAAAAAAAAAAAAAAPC/"
				],
				[
					337,
					2,
					"left_delete",
					null,
					"AgAAAEYGAAAAAAAARgYAAAAAAAADAAAA77+lRQYAAAAAAABFBgAAAAAAAAMAAADvvJo",
					"AQAAAAAAAAABAAAARwYAAAAAAABHBgAAAAAAAAAAAAAAAPC/"
				],
				[
					338,
					1,
					"insert",
					{
						"characters": ":$"
					},
					"AgAAAEUGAAAAAAAARgYAAAAAAAAAAAAARgYAAAAAAABHBgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARQYAAAAAAABFBgAAAAAAAAAAAAAAAPC/"
				],
				[
					339,
					1,
					"insert",
					{
						"characters": "{}"
					},
					"AgAAAEcGAAAAAAAASAYAAAAAAAAAAAAASAYAAAAAAABJBgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARwYAAAAAAABHBgAAAAAAAAAAAAAAAPC/"
				],
				[
					341,
					1,
					"paste",
					null,
					"AQAAAEgGAAAAAAAATgYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASAYAAAAAAABIBgAAAAAAAAAAAAAAAPC/"
				],
				[
					343,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAE8GAAAAAAAAUAYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATwYAAAAAAABPBgAAAAAAAAAAAAAAAPC/"
				],
				[
					348,
					1,
					"paste",
					null,
					"AQAAAFgGAAAAAAAAgQYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWAYAAAAAAABYBgAAAAAAAAAAAAAAAPC/"
				],
				[
					356,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAKYHAAAAAAAApwcAAAAAAAAAAAAApwcAAAAAAACoBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAApgcAAAAAAACmBwAAAAAAAAAAAAAAAPC/"
				],
				[
					364,
					1,
					"paste",
					null,
					"AQAAAMYHAAAAAAAAygcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxgcAAAAAAADGBwAAAAAAAAAAAAAAAPC/"
				],
				[
					365,
					1,
					"insert",
					{
						"characters": ".clone"
					},
					"BgAAAMoHAAAAAAAAywcAAAAAAAAAAAAAywcAAAAAAADMBwAAAAAAAAAAAADMBwAAAAAAAM0HAAAAAAAAAAAAAM0HAAAAAAAAzgcAAAAAAAAAAAAAzgcAAAAAAADPBwAAAAAAAAAAAADPBwAAAAAAANAHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAygcAAAAAAADKBwAAAAAAAAAAAAAAAPC/"
				],
				[
					366,
					1,
					"insert",
					{
						"characters": "Type"
					},
					"BAAAANAHAAAAAAAA0QcAAAAAAAAAAAAA0QcAAAAAAADSBwAAAAAAAAAAAADSBwAAAAAAANMHAAAAAAAAAAAAANMHAAAAAAAA1AcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA0AcAAAAAAADQBwAAAAAAAAAAAAAAAPC/"
				],
				[
					369,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAFMIAAAAAAAAVAgAAAAAAAAAAAAAVAgAAAAAAABVCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUwgAAAAAAABTCAAAAAAAAAAAAAAAAPC/"
				],
				[
					375,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAMYJAAAAAAAAxwkAAAAAAAAAAAAAxwkAAAAAAADICQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxgkAAAAAAADGCQAAAAAAAAAAAAAAAPC/"
				],
				[
					378,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAOMJAAAAAAAA5AkAAAAAAAAAAAAA5AkAAAAAAADlCQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA4wkAAAAAAADjCQAAAAAAAAAAAAAAAPC/"
				],
				[
					381,
					1,
					"paste",
					null,
					"AgAAAC0GAAAAAAAAOQYAAAAAAAAAAAAAOQYAAAAAAAA5BgAAAAAAAAEAAAA4",
					"AQAAAAAAAAABAAAALgYAAAAAAAAtBgAAAAAAAAAAAAAAAPC/"
				],
				[
					384,
					1,
					"insert",
					{
						"characters": "\nval"
					},
					"BQAAAD8FAAAAAAAAQAUAAAAAAAAAAAAAQAUAAAAAAABEBQAAAAAAAAAAAABEBQAAAAAAAEUFAAAAAAAAAAAAAEUFAAAAAAAARgUAAAAAAAAAAAAARgUAAAAAAABHBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPwUAAAAAAAA/BQAAAAAAAAAAAAAAAPC/"
				],
				[
					385,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAEcFAAAAAAAASAUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARwUAAAAAAABHBQAAAAAAAAAAAAAAAPC/"
				],
				[
					386,
					1,
					"paste",
					null,
					"AQAAAEgFAAAAAAAAVAUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASAUAAAAAAABIBQAAAAAAAAAAAAAAAPC/"
				],
				[
					387,
					1,
					"insert",
					{
						"characters": " ="
					},
					"AgAAAFQFAAAAAAAAVQUAAAAAAAAAAAAAVQUAAAAAAABWBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVAUAAAAAAABUBQAAAAAAAAAAAAAAAPC/"
				],
				[
					388,
					1,
					"insert",
					{
						"characters": " 9"
					},
					"AgAAAFYFAAAAAAAAVwUAAAAAAAAAAAAAVwUAAAAAAABYBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVgUAAAAAAABWBQAAAAAAAAAAAAAAAPC/"
				],
				[
					389,
					1,
					"left_delete",
					null,
					"AQAAAFcFAAAAAAAAVwUAAAAAAAABAAAAOQ",
					"AQAAAAAAAAABAAAAWAUAAAAAAABYBQAAAAAAAAAAAAAAAPC/"
				],
				[
					390,
					1,
					"insert",
					{
						"characters": "8"
					},
					"AQAAAFcFAAAAAAAAWAUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVwUAAAAAAABXBQAAAAAAAAAAAAAAAPC/"
				],
				[
					404,
					1,
					"insert",
					{
						"characters": "Fill"
					},
					"BAAAAJkIAAAAAAAAmggAAAAAAAAAAAAAmggAAAAAAACbCAAAAAAAAAAAAACbCAAAAAAAAJwIAAAAAAAAAAAAAJwIAAAAAAAAnQgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmQgAAAAAAACZCAAAAAAAAAAAAAAAAPC/"
				],
				[
					405,
					1,
					"insert",
					{
						"characters": "("
					},
					"AQAAAJ0IAAAAAAAAnggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAnQgAAAAAAACdCAAAAAAAAAAAAAAAAPC/"
				],
				[
					412,
					1,
					"paste",
					null,
					"AQAAAJ4IAAAAAAAApwgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAnggAAAAAAACeCAAAAAAAAAAAAAAAAPC/"
				],
				[
					413,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAKcIAAAAAAAAqAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAApwgAAAAAAACnCAAAAAAAAAAAAAAAAPC/"
				],
				[
					414,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAKgIAAAAAAAAqQgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAqAgAAAAAAACoCAAAAAAAAAAAAAAAAPC/"
				],
				[
					418,
					1,
					"insert",
					{
						"characters": ".asBO"
					},
					"BQAAANoIAAAAAAAA2wgAAAAAAAAAAAAA2wgAAAAAAADcCAAAAAAAAAAAAADcCAAAAAAAAN0IAAAAAAAAAAAAAN0IAAAAAAAA3ggAAAAAAAAAAAAA3ggAAAAAAADfCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA2ggAAAAAAADaCAAAAAAAAAAAAAAAAPC/"
				],
				[
					419,
					1,
					"left_delete",
					null,
					"AQAAAN4IAAAAAAAA3ggAAAAAAAABAAAATw",
					"AQAAAAAAAAABAAAA3wgAAAAAAADfCAAAAAAAAAAAAAAAAPC/"
				],
				[
					420,
					1,
					"insert",
					{
						"characters": "ools"
					},
					"BAAAAN4IAAAAAAAA3wgAAAAAAAAAAAAA3wgAAAAAAADgCAAAAAAAAAAAAADgCAAAAAAAAOEIAAAAAAAAAAAAAOEIAAAAAAAA4ggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA3ggAAAAAAADeCAAAAAAAAAAAAAAAAPC/"
				],
				[
					425,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAAOIIAAAAAAAA4wgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA4ggAAAAAAADiCAAAAAAAAAAAAAAAAPC/"
				],
				[
					428,
					2,
					"left_delete",
					null,
					"AgAAAHgIAAAAAAAAeAgAAAAAAAABAAAAL3cIAAAAAAAAdwgAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAAeQgAAAAAAAB5CAAAAAAAAAAAAAAAAPC/"
				],
				[
					431,
					2,
					"left_delete",
					null,
					"AgAAAAEIAAAAAAAAAQgAAAAAAAABAAAALwAIAAAAAAAAAAgAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAAAggAAAAAAAACCAAAAAAAAAAAAAAAAPC/"
				],
				[
					438,
					1,
					"paste",
					null,
					"AgAAAIUIAAAAAAAAiggAAAAAAAAAAAAAiggAAAAAAACKCAAAAAAAAA4AAABpbi5hLmJpdHMuZGF0YQ",
					"AQAAAAAAAAABAAAAhQgAAAAAAACTCAAAAAAAAAAAAAAAAPC/"
				],
				[
					443,
					1,
					"insert",
					{
						"characters": "a"
					},
					"AgAAAC4IAAAAAAAALwgAAAAAAAAAAAAALwgAAAAAAAAvCAAAAAAAAAEAAAB3",
					"AQAAAAAAAAABAAAALwgAAAAAAAAuCAAAAAAAAAAAAAAAAPC/"
				],
				[
					451,
					2,
					"right_delete",
					null,
					"AgAAAFQGAAAAAAAAVAYAAAAAAABRAAAAcHJpbnRsbihzIj09PT0gZWRnZUluOiR7ZWRnZUlufSBwYXJhbXMiKQpwcmludGxuKHMiPT09PSBlZGdlSW46JHtlZGdlSW59IHBhcmFtcyIpVAYAAAAAAABUBgAAAAAAAAEAAAAK",
					"AQAAAAAAAAABAAAApQYAAAAAAABUBgAAAAAAAAAAAAAAAPC/"
				],
				[
					456,
					2,
					"left_delete",
					null,
					"AgAAAHkHAAAAAAAAeQcAAAAAAAABAAAAL3gHAAAAAAAAeAcAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAAegcAAAAAAAB6BwAAAAAAAAAAAAAAAPC/"
				],
				[
					463,
					1,
					"left_delete",
					null,
					"AQAAAJMHAAAAAAAAkwcAAAAAAAABAAAAbw",
					"AQAAAAAAAAABAAAAlAcAAAAAAACUBwAAAAAAAAAAAAAAAPC/"
				],
				[
					464,
					1,
					"insert",
					{
						"characters": "O"
					},
					"AQAAAJMHAAAAAAAAlAcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkwcAAAAAAACTBwAAAAAAAAAAAAAAAPC/"
				],
				[
					469,
					1,
					"insert",
					{
						"characters": "    va"
					},
					"BgAAAKcHAAAAAAAAqAcAAAAAAAAAAAAAqAcAAAAAAACpBwAAAAAAAAAAAACpBwAAAAAAAKoHAAAAAAAAAAAAAKoHAAAAAAAAqwcAAAAAAAAAAAAAqwcAAAAAAACsBwAAAAAAAAAAAACsBwAAAAAAAK0HAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAApwcAAAAAAACnBwAAAAAAAAAAAAAAAPC/"
				],
				[
					470,
					1,
					"insert",
					{
						"characters": "l"
					},
					"AQAAAK0HAAAAAAAArgcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAArQcAAAAAAACtBwAAAAAAAAAAAAAAAPC/"
				],
				[
					471,
					3,
					"left_delete",
					null,
					"AwAAAK0HAAAAAAAArQcAAAAAAAABAAAAbKwHAAAAAAAArAcAAAAAAAABAAAAYasHAAAAAAAAqwcAAAAAAAABAAAAdg",
					"AQAAAAAAAAABAAAArgcAAAAAAACuBwAAAAAAAAAAAAAAAPC/"
				],
				[
					472,
					1,
					"insert",
					{
						"characters": "s1"
					},
					"AgAAAKsHAAAAAAAArAcAAAAAAAAAAAAArAcAAAAAAACtBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAqwcAAAAAAACrBwAAAAAAAAAAAAAAAPC/"
				],
				[
					473,
					1,
					"insert",
					{
						"characters": " :="
					},
					"AwAAAK0HAAAAAAAArgcAAAAAAAAAAAAArgcAAAAAAACvBwAAAAAAAAAAAACvBwAAAAAAALAHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAArQcAAAAAAACtBwAAAAAAAAAAAAAAAPC/"
				],
				[
					474,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAALAHAAAAAAAAsQcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAsAcAAAAAAACwBwAAAAAAAAAAAAAAAPC/"
				],
				[
					480,
					1,
					"paste",
					null,
					"AQAAALEHAAAAAAAAtQcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAsQcAAAAAAACxBwAAAAAAAAAAAAAAAPC/"
				],
				[
					481,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAALUHAAAAAAAAtgcAAAAAAAAAAAAAtgcAAAAAAAC6BwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAtQcAAAAAAAC1BwAAAAAAAAAAAAAAAPC/"
				],
				[
					487,
					1,
					"insert",
					{
						"characters": ";chis"
					},
					"BgAAAKYHAAAAAAAApwcAAAAAAAAAAAAAtwcAAAAAAAC3BwAAAAAAAAQAAAAgICAgpwcAAAAAAACoBwAAAAAAAAAAAACoBwAAAAAAAKkHAAAAAAAAAAAAAKkHAAAAAAAAqgcAAAAAAAAAAAAAqgcAAAAAAACrBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAApgcAAAAAAACmBwAAAAAAAAAAAAAAAPC/"
				],
				[
					488,
					1,
					"insert",
					{
						"characters": "el3"
					},
					"AwAAAKsHAAAAAAAArAcAAAAAAAAAAAAArAcAAAAAAACtBwAAAAAAAAAAAACtBwAAAAAAAK4HAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAqwcAAAAAAACrBwAAAAAAAAAAAAAAAPC/"
				],
				[
					489,
					1,
					"insert",
					{
						"characters": ".dont"
					},
					"BQAAAK4HAAAAAAAArwcAAAAAAAAAAAAArwcAAAAAAACwBwAAAAAAAAAAAACwBwAAAAAAALEHAAAAAAAAAAAAALEHAAAAAAAAsgcAAAAAAAAAAAAAsgcAAAAAAACzBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAArgcAAAAAAACuBwAAAAAAAAAAAAAAAPC/"
				],
				[
					490,
					1,
					"insert",
					{
						"characters": "Touch"
					},
					"BQAAALMHAAAAAAAAtAcAAAAAAAAAAAAAtAcAAAAAAAC1BwAAAAAAAAAAAAC1BwAAAAAAALYHAAAAAAAAAAAAALYHAAAAAAAAtwcAAAAAAAAAAAAAtwcAAAAAAAC4BwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAswcAAAAAAACzBwAAAAAAAAAAAAAAAPC/"
				],
				[
					491,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAALgHAAAAAAAAugcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAuAcAAAAAAAC4BwAAAAAAAAAAAAAAAPC/"
				],
				[
					494,
					1,
					"insert",
					{
						"characters": "s1"
					},
					"AgAAALkHAAAAAAAAugcAAAAAAAAAAAAAugcAAAAAAAC7BwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAuQcAAAAAAAC5BwAAAAAAAAAAAAAAAPC/"
				],
				[
					504,
					1,
					"insert",
					{
						"characters": "new"
					},
					"AwAAAJYHAAAAAAAAlwcAAAAAAAAAAAAAlwcAAAAAAACYBwAAAAAAAAAAAACYBwAAAAAAAJkHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAlgcAAAAAAACWBwAAAAAAAAAAAAAAAPC/"
				],
				[
					505,
					1,
					"insert",
					{
						"characters": " V"
					},
					"AgAAAJkHAAAAAAAAmgcAAAAAAAAAAAAAmgcAAAAAAACbBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmQcAAAAAAACZBwAAAAAAAAAAAAAAAPC/"
				],
				[
					506,
					1,
					"left_delete",
					null,
					"AQAAAJoHAAAAAAAAmgcAAAAAAAABAAAAVg",
					"AQAAAAAAAAABAAAAmwcAAAAAAACbBwAAAAAAAAAAAAAAAPC/"
				],
				[
					507,
					1,
					"insert",
					{
						"characters": "valid("
					},
					"BgAAAJoHAAAAAAAAmwcAAAAAAAAAAAAAmwcAAAAAAACcBwAAAAAAAAAAAACcBwAAAAAAAJ0HAAAAAAAAAAAAAJ0HAAAAAAAAngcAAAAAAAAAAAAAngcAAAAAAACfBwAAAAAAAAAAAACfBwAAAAAAAKAHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmgcAAAAAAACaBwAAAAAAAAAAAAAAAPC/"
				],
				[
					510,
					1,
					"insert",
					{
						"characters": ".bits"
					},
					"BQAAAKQHAAAAAAAApQcAAAAAAAAAAAAApQcAAAAAAACmBwAAAAAAAAAAAACmBwAAAAAAAKcHAAAAAAAAAAAAAKcHAAAAAAAAqAcAAAAAAAAAAAAAqAcAAAAAAACpBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAApAcAAAAAAACkBwAAAAAAAAAAAAAAAPC/"
				],
				[
					518,
					1,
					"insert",
					{
						"characters": ".bits"
					},
					"BQAAANIHAAAAAAAA0wcAAAAAAAAAAAAA0wcAAAAAAADUBwAAAAAAAAAAAADUBwAAAAAAANUHAAAAAAAAAAAAANUHAAAAAAAA1gcAAAAAAAAAAAAA1gcAAAAAAADXBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA0gcAAAAAAADSBwAAAAAAAAAAAAAAAPC/"
				],
				[
					521,
					1,
					"insert",
					{
						"characters": ".bits"
					},
					"BQAAAN8HAAAAAAAA4AcAAAAAAAAAAAAA4AcAAAAAAADhBwAAAAAAAAAAAADhBwAAAAAAAOIHAAAAAAAAAAAAAOIHAAAAAAAA4wcAAAAAAAAAAAAA4wcAAAAAAADkBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA3wcAAAAAAADfBwAAAAAAAAAAAAAAAPC/"
				],
				[
					532,
					1,
					"insert",
					{
						"characters": "d"
					},
					"AQAAALUHAAAAAAAAtgcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAtQcAAAAAAAC1BwAAAAAAAAAAAAAAAPC/"
				],
				[
					533,
					1,
					"left_delete",
					null,
					"AQAAALUHAAAAAAAAtQcAAAAAAAABAAAAZA",
					"AQAAAAAAAAABAAAAtgcAAAAAAAC2BwAAAAAAAAAAAAAAAPC/"
				],
				[
					534,
					1,
					"insert",
					{
						"characters": "))"
					},
					"AgAAALUHAAAAAAAAtgcAAAAAAAAAAAAAtgcAAAAAAAC3BwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAtQcAAAAAAAC1BwAAAAAAAAAAAAAAAPC/"
				],
				[
					543,
					1,
					"left_delete",
					null,
					"AQAAALYHAAAAAAAAtgcAAAAAAAABAAAAKQ",
					"AQAAAAAAAAABAAAAtwcAAAAAAAC3BwAAAAAAAAAAAAAAAPC/"
				],
				[
					546,
					1,
					"left_delete",
					null,
					"AQAAAJoHAAAAAAAAmgcAAAAAAAABAAAAdg",
					"AQAAAAAAAAABAAAAmwcAAAAAAACbBwAAAAAAAAAAAAAAAPC/"
				],
				[
					547,
					1,
					"insert",
					{
						"characters": "V"
					},
					"AQAAAJoHAAAAAAAAmwcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmgcAAAAAAACaBwAAAAAAAAAAAAAAAPC/"
				],
				[
					550,
					1,
					"insert",
					{
						"characters": "chisle"
					},
					"BgAAAJoHAAAAAAAAmwcAAAAAAAAAAAAAmwcAAAAAAACcBwAAAAAAAAAAAACcBwAAAAAAAJ0HAAAAAAAAAAAAAJ0HAAAAAAAAngcAAAAAAAAAAAAAngcAAAAAAACfBwAAAAAAAAAAAACfBwAAAAAAAKAHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmgcAAAAAAACaBwAAAAAAAAAAAAAAAPC/"
				],
				[
					551,
					2,
					"left_delete",
					null,
					"AgAAAJ8HAAAAAAAAnwcAAAAAAAABAAAAZZ4HAAAAAAAAngcAAAAAAAABAAAAbA",
					"AQAAAAAAAAABAAAAoAcAAAAAAACgBwAAAAAAAAAAAAAAAPC/"
				],
				[
					552,
					1,
					"insert",
					{
						"characters": "el3."
					},
					"BAAAAJ4HAAAAAAAAnwcAAAAAAAAAAAAAnwcAAAAAAACgBwAAAAAAAAAAAACgBwAAAAAAAKEHAAAAAAAAAAAAAKEHAAAAAAAAogcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAngcAAAAAAACeBwAAAAAAAAAAAAAAAPC/"
				],
				[
					559,
					4,
					"left_delete",
					null,
					"BAAAAJkHAAAAAAAAmQcAAAAAAAABAAAAIJgHAAAAAAAAmAcAAAAAAAABAAAAd5cHAAAAAAAAlwcAAAAAAAABAAAAZZYHAAAAAAAAlgcAAAAAAAABAAAAbg",
					"AQAAAAAAAAABAAAAmgcAAAAAAACaBwAAAAAAAAAAAAAAAPC/"
				],
				[
					568,
					1,
					"insert",
					{
						"characters": "new"
					},
					"AwAAAJYHAAAAAAAAlwcAAAAAAAAAAAAAlwcAAAAAAACYBwAAAAAAAAAAAACYBwAAAAAAAJkHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAlgcAAAAAAACWBwAAAAAAAAAAAAAAAPC/"
				],
				[
					569,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAJkHAAAAAAAAmgcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmQcAAAAAAACZBwAAAAAAAAAAAAAAAPC/"
				],
				[
					574,
					1,
					"insert",
					{
						"characters": ".clone"
					},
					"BgAAALwHAAAAAAAAvQcAAAAAAAAAAAAAvQcAAAAAAAC+BwAAAAAAAAAAAAC+BwAAAAAAAL8HAAAAAAAAAAAAAL8HAAAAAAAAwAcAAAAAAAAAAAAAwAcAAAAAAADBBwAAAAAAAAAAAADBBwAAAAAAAMIHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvAcAAAAAAAC8BwAAAAAAAAAAAAAAAPC/"
				],
				[
					575,
					1,
					"insert",
					{
						"characters": "Typep"
					},
					"BQAAAMIHAAAAAAAAwwcAAAAAAAAAAAAAwwcAAAAAAADEBwAAAAAAAAAAAADEBwAAAAAAAMUHAAAAAAAAAAAAAMUHAAAAAAAAxgcAAAAAAAAAAAAAxgcAAAAAAADHBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAwgcAAAAAAADCBwAAAAAAAAAAAAAAAPC/"
				],
				[
					576,
					1,
					"left_delete",
					null,
					"AQAAAMYHAAAAAAAAxgcAAAAAAAABAAAAcA",
					"AQAAAAAAAAABAAAAxwcAAAAAAADHBwAAAAAAAAAAAAAAAPC/"
				],
				[
					583,
					1,
					"paste",
					null,
					"AgAAAJoHAAAAAAAApgcAAAAAAAAAAAAApgcAAAAAAACmBwAAAAAAAAcAAABjaGlzZWwz",
					"AQAAAAAAAAABAAAAoQcAAAAAAACaBwAAAAAAAAAAAAAAAPC/"
				],
				[
					587,
					2,
					"left_delete",
					null,
					"AgAAAMIHAAAAAAAAwgcAAAAAAAAJAAAAY2xvbmVUeXBlwQcAAAAAAADBBwAAAAAAAAEAAAAu",
					"AQAAAAAAAAABAAAAwgcAAAAAAADLBwAAAAAAAAAAAAAAAPC/"
				],
				[
					590,
					4,
					"left_delete",
					null,
					"BAAAAJkHAAAAAAAAmQcAAAAAAAABAAAAIJgHAAAAAAAAmAcAAAAAAAABAAAAd5cHAAAAAAAAlwcAAAAAAAABAAAAZZYHAAAAAAAAlgcAAAAAAAABAAAAbg",
					"AQAAAAAAAAABAAAAmgcAAAAAAACaBwAAAAAAAAAAAAAAAPC/"
				],
				[
					593,
					1,
					"insert",
					{
						"characters": "8"
					},
					"AgAAAL8CAAAAAAAAwAIAAAAAAAAAAAAAwAIAAAAAAADAAgAAAAAAAAEAAAA0",
					"AQAAAAAAAAABAAAAwAIAAAAAAAC/AgAAAAAAAAAAAAAAAPC/"
				],
				[
					611,
					1,
					"insert",
					{
						"characters": "\ndef"
					},
					"BQAAAHIHAAAAAAAAcwcAAAAAAAAAAAAAcwcAAAAAAAB3BwAAAAAAAAAAAAB3BwAAAAAAAHgHAAAAAAAAAAAAAHgHAAAAAAAAeQcAAAAAAAAAAAAAeQcAAAAAAAB6BwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcgcAAAAAAAByBwAAAAAAAAAAAAAAAPC/"
				],
				[
					612,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAHoHAAAAAAAAewcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAegcAAAAAAAB6BwAAAAAAAAAAAAAAAPC/"
				],
				[
					613,
					1,
					"insert",
					{
						"characters": "empty"
					},
					"BQAAAHsHAAAAAAAAfAcAAAAAAAAAAAAAfAcAAAAAAAB9BwAAAAAAAAAAAAB9BwAAAAAAAH4HAAAAAAAAAAAAAH4HAAAAAAAAfwcAAAAAAAAAAAAAfwcAAAAAAACABwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAewcAAAAAAAB7BwAAAAAAAAAAAAAAAPC/"
				],
				[
					615,
					1,
					"insert",
					{
						"characters": "isE"
					},
					"AwAAAHsHAAAAAAAAfAcAAAAAAAAAAAAAfAcAAAAAAAB9BwAAAAAAAAAAAAB9BwAAAAAAAH4HAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAewcAAAAAAAB7BwAAAAAAAAAAAAAAAPC/"
				],
				[
					617,
					1,
					"left_delete",
					null,
					"AQAAAH4HAAAAAAAAfgcAAAAAAAABAAAAZQ",
					"AQAAAAAAAAABAAAAfwcAAAAAAAB/BwAAAAAAAAAAAAAAAPC/"
				],
				[
					619,
					1,
					"insert",
					{
						"characters": " ="
					},
					"AgAAAIIHAAAAAAAAgwcAAAAAAAAAAAAAgwcAAAAAAACEBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAggcAAAAAAACCBwAAAAAAAAAAAAAAAPC/"
				],
				[
					620,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAIQHAAAAAAAAhQcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAhAcAAAAAAACEBwAAAAAAAAAAAAAAAPC/"
				],
				[
					641,
					1,
					"insert",
					{
						"characters": " &&"
					},
					"AwAAAHIIAAAAAAAAcwgAAAAAAAAAAAAAcwgAAAAAAAB0CAAAAAAAAAAAAAB0CAAAAAAAAHUIAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcggAAAAAAAByCAAAAAAAAAAAAAAAAPC/"
				],
				[
					642,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAHUIAAAAAAAAdggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdQgAAAAAAAB1CAAAAAAAAAAAAAAAAPC/"
				],
				[
					643,
					1,
					"paste",
					null,
					"AQAAAHYIAAAAAAAApggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdggAAAAAAAB2CAAAAAAAAAAAAAAAAPC/"
				],
				[
					646,
					1,
					"insert",
					{
						"characters": "true"
					},
					"BQAAANcIAAAAAAAA2AgAAAAAAAAAAAAA2AgAAAAAAADYCAAAAAAAADAAAABpbi5hLmJpdHMub3Bjb2RlID09PSBDdXN0b21QYXJhbWV0ZXJzLk9QQ09ERV9FTlHYCAAAAAAAANkIAAAAAAAAAAAAANkIAAAAAAAA2ggAAAAAAAAAAAAA2ggAAAAAAADbCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1wgAAAAAAAAHCQAAAAAAAAAAAAAAAPC/"
				],
				[
					647,
					1,
					"insert",
					{
						"characters": ".B"
					},
					"AgAAANsIAAAAAAAA3AgAAAAAAAAAAAAA3AgAAAAAAADdCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA2wgAAAAAAADbCAAAAAAAAAAAAAAAAPC/"
				],
				[
					652,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAOcIAAAAAAAA6AgAAAAAAAAAAAAA6AgAAAAAAADuCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA5wgAAAAAAADnCAAAAAAAAAAAAAAAAPC/"
				],
				[
					653,
					1,
					"insert",
					{
						"characters": "head"
					},
					"BAAAAO4IAAAAAAAA7wgAAAAAAAAAAAAA7wgAAAAAAADwCAAAAAAAAAAAAADwCAAAAAAAAPEIAAAAAAAAAAAAAPEIAAAAAAAA8ggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA7ggAAAAAAADuCAAAAAAAAAAAAAAAAPC/"
				],
				[
					654,
					1,
					"insert",
					{
						"characters": " :="
					},
					"AwAAAPIIAAAAAAAA8wgAAAAAAAAAAAAA8wgAAAAAAAD0CAAAAAAAAAAAAAD0CAAAAAAAAPUIAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA8ggAAAAAAADyCAAAAAAAAAAAAAAAAPC/"
				],
				[
					655,
					1,
					"insert",
					{
						"characters": " head"
					},
					"BQAAAPUIAAAAAAAA9ggAAAAAAAAAAAAA9ggAAAAAAAD3CAAAAAAAAAAAAAD3CAAAAAAAAPgIAAAAAAAAAAAAAPgIAAAAAAAA+QgAAAAAAAAAAAAA+QgAAAAAAAD6CAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA9QgAAAAAAAD1CAAAAAAAAAAAAAAAAPC/"
				],
				[
					656,
					1,
					"insert",
					{
						"characters": " _"
					},
					"AgAAAPoIAAAAAAAA+wgAAAAAAAAAAAAA+wgAAAAAAAD8CAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA+ggAAAAAAAD6CAAAAAAAAAAAAAAAAPC/"
				],
				[
					657,
					1,
					"left_delete",
					null,
					"AQAAAPsIAAAAAAAA+wgAAAAAAAABAAAAXw",
					"AQAAAAAAAAABAAAA/AgAAAAAAAD8CAAAAAAAAAAAAAAAAPC/"
				],
				[
					658,
					1,
					"insert",
					{
						"characters": "+1"
					},
					"AgAAAPsIAAAAAAAA/AgAAAAAAAAAAAAA/AgAAAAAAAD9CAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA+wgAAAAAAAD7CAAAAAAAAAAAAAAAAPC/"
				],
				[
					659,
					1,
					"left_delete",
					null,
					"AQAAAPwIAAAAAAAA/AgAAAAAAAABAAAAMQ",
					"AQAAAAAAAAABAAAA/QgAAAAAAAD9CAAAAAAAAAAAAAAAAPC/"
				],
				[
					660,
					1,
					"insert",
					{
						"characters": " 1."
					},
					"AwAAAPwIAAAAAAAA/QgAAAAAAAAAAAAA/QgAAAAAAAD+CAAAAAAAAAAAAAD+CAAAAAAAAP8IAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA/AgAAAAAAAD8CAAAAAAAAAAAAAAAAPC/"
				],
				[
					661,
					1,
					"insert",
					{
						"characters": "U"
					},
					"AQAAAP8IAAAAAAAAAAkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA/wgAAAAAAAD/CAAAAAAAAAAAAAAAAPC/"
				],
				[
					666,
					1,
					"right_delete",
					null,
					"AQAAAAEJAAAAAAAAAQkAAAAAAABcAAAAICAgICAgLy9ieSBkb25nZGVqaSBjb3JydXB0LmZvcmVhY2ggeyBfLndyaXRlKHdfYWRkciwgaW4udy5iaXRzLnVzZXIoQU1CQUNvcnJ1cHQpLmFzVUludCkgfQo",
					"AQAAAAAAAAABAAAAXQkAAAAAAAABCQAAAAAAAAAAAAAAAPC/"
				],
				[
					685,
					1,
					"insert",
					{
						"characters": "log"
					},
					"BAAAAEoHAAAAAAAASwcAAAAAAAAAAAAASwcAAAAAAABLBwAAAAAAAAIAAAAzMksHAAAAAAAATAcAAAAAAAAAAAAATAcAAAAAAABNBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASgcAAAAAAABMBwAAAAAAAAAAAAAAAPC/"
				],
				[
					686,
					1,
					"insert_completion",
					{
						"completion": "log2Up",
						"format": "text",
						"keep_prefix": false,
						"must_insert": false,
						"trigger": "log2Up"
					},
					"AgAAAEoHAAAAAAAASgcAAAAAAAADAAAAbG9nSgcAAAAAAABQBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATQcAAAAAAABNBwAAAAAAAAAAAAAAAPC/"
				],
				[
					690,
					1,
					"insert",
					{
						"characters": "()"
					},
					"AgAAAFAHAAAAAAAAUQcAAAAAAAAAAAAAUQcAAAAAAABSBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUAcAAAAAAABQBwAAAAAAAAAAAAAAAPC/"
				],
				[
					692,
					1,
					"paste",
					null,
					"AQAAAFEHAAAAAAAAbQcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUQcAAAAAAABRBwAAAAAAAAAAAAAAAPC/"
				],
				[
					693,
					1,
					"insert",
					{
						"characters": "*2"
					},
					"AgAAAG0HAAAAAAAAbgcAAAAAAAAAAAAAbgcAAAAAAABvBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbQcAAAAAAABtBwAAAAAAAAAAAAAAAPC/"
				],
				[
					700,
					1,
					"paste",
					null,
					"AgAAAJAHAAAAAAAAtgcAAAAAAAAAAAAAtgcAAAAAAAC2BwAAAAAAAAIAAAAzMg",
					"AQAAAAAAAAABAAAAkAcAAAAAAACSBwAAAAAAAAAAAAAAAPC/"
				],
				[
					705,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAALoHAAAAAAAAuwcAAAAAAAAAAAAAuwcAAAAAAAC/BwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAugcAAAAAAAC6BwAAAAAAAAAAAAAAAPC/"
				],
				[
					706,
					2,
					"left_delete",
					null,
					"AgAAAL0HAAAAAAAAvQcAAAAAAAACAAAAICC7BwAAAAAAALsHAAAAAAAAAgAAACAg",
					"AQAAAAAAAAABAAAAvwcAAAAAAAC/BwAAAAAAAAAAAAAAAPC/"
				],
				[
					707,
					1,
					"insert",
					{
						"characters": "println)"
					},
					"CAAAALsHAAAAAAAAvAcAAAAAAAAAAAAAvAcAAAAAAAC9BwAAAAAAAAAAAAC9BwAAAAAAAL4HAAAAAAAAAAAAAL4HAAAAAAAAvwcAAAAAAAAAAAAAvwcAAAAAAADABwAAAAAAAAAAAADABwAAAAAAAMEHAAAAAAAAAAAAAMEHAAAAAAAAwgcAAAAAAAAAAAAAwgcAAAAAAADDBwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAuwcAAAAAAAC7BwAAAAAAAAAAAAAAAPC/"
				],
				[
					708,
					1,
					"left_delete",
					null,
					"AQAAAMIHAAAAAAAAwgcAAAAAAAABAAAAKQ",
					"AQAAAAAAAAABAAAAwwcAAAAAAADDBwAAAAAAAAAAAAAAAPC/"
				],
				[
					709,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAMIHAAAAAAAAxAcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAwgcAAAAAAADCBwAAAAAAAAAAAAAAAPC/"
				],
				[
					712,
					1,
					"insert",
					{
						"characters": "s\"\""
					},
					"AwAAAMMHAAAAAAAAxAcAAAAAAAAAAAAAxAcAAAAAAADFBwAAAAAAAAAAAADFBwAAAAAAAMYHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAwwcAAAAAAADDBwAAAAAAAAAAAAAAAPC/"
				],
				[
					714,
					1,
					"insert",
					{
						"characters": "===="
					},
					"BAAAAMUHAAAAAAAAxgcAAAAAAAAAAAAAxgcAAAAAAADHBwAAAAAAAAAAAADHBwAAAAAAAMgHAAAAAAAAAAAAAMgHAAAAAAAAyQcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxQcAAAAAAADFBwAAAAAAAAAAAAAAAPC/"
				],
				[
					715,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAMkHAAAAAAAAygcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAyQcAAAAAAADJBwAAAAAAAAAAAAAAAPC/"
				],
				[
					723,
					1,
					"paste",
					null,
					"AQAAAMoHAAAAAAAA8AcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAygcAAAAAAADKBwAAAAAAAAAAAAAAAPC/"
				],
				[
					724,
					1,
					"insert",
					{
						"characters": ":${}"
					},
					"BAAAAPAHAAAAAAAA8QcAAAAAAAAAAAAA8QcAAAAAAADyBwAAAAAAAAAAAADyBwAAAAAAAPMHAAAAAAAAAAAAAPMHAAAAAAAA9AcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA8AcAAAAAAADwBwAAAAAAAAAAAAAAAPC/"
				],
				[
					726,
					1,
					"paste",
					null,
					"AQAAAPMHAAAAAAAAGQgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA8wcAAAAAAADzBwAAAAAAAAAAAAAAAPC/"
				],
				[
					730,
					2,
					"paste",
					null,
					"AwAAALoHAAAAAAAAHAgAAAAAAAAAAAAAHAgAAAAAAAAcCAAAAAAAAGIAAAAKcHJpbnRsbihzIj09PT0gbG9nMlVwKEN1c3RvbVBhcmFtZXRlcnMucXVldWVfZGVwdGgqMik6JHtsb2cyVXAoQ3VzdG9tUGFyYW1ldGVycy5xdWV1ZV9kZXB0aCoyKX0iKRwIAAAAAAAAfggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAugcAAAAAAAAcCAAAAAAAAAAAAAAAAPC/"
				],
				[
					733,
					2,
					"left_delete",
					null,
					"AgAAAHkIAAAAAAAAeQgAAAAAAAABAAAAMngIAAAAAAAAeAgAAAAAAAABAAAAKg",
					"AQAAAAAAAAABAAAAeggAAAAAAAB6CAAAAAAAAAAAAAAAAPC/"
				],
				[
					736,
					2,
					"left_delete",
					null,
					"AgAAAFAIAAAAAAAAUAgAAAAAAAABAAAAMk8IAAAAAAAATwgAAAAAAAABAAAAKg",
					"AQAAAAAAAAABAAAAUQgAAAAAAABRCAAAAAAAAAAAAAAAAPC/"
				],
				[
					739,
					1,
					"insert",
					{
						"characters": "head"
					},
					"BAAAAI0IAAAAAAAAjggAAAAAAAAAAAAAjggAAAAAAACPCAAAAAAAAAAAAACPCAAAAAAAAJAIAAAAAAAAAAAAAJAIAAAAAAAAkQgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjQgAAAAAAACNCAAAAAAAAAAAAAAAAPC/"
				],
				[
					740,
					1,
					"insert",
					{
						"characters": " +"
					},
					"AgAAAJEIAAAAAAAAkggAAAAAAAAAAAAAkggAAAAAAACTCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkQgAAAAAAACRCAAAAAAAAAAAAAAAAPC/"
				],
				[
					741,
					1,
					"insert",
					{
						"characters": " 1.U"
					},
					"BAAAAJMIAAAAAAAAlAgAAAAAAAAAAAAAlAgAAAAAAACVCAAAAAAAAAAAAACVCAAAAAAAAJYIAAAAAAAAAAAAAJYIAAAAAAAAlwgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkwgAAAAAAACTCAAAAAAAAAAAAAAAAPC/"
				],
				[
					742,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAAJcIAAAAAAAAmAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAlwgAAAAAAACXCAAAAAAAAAAAAAAAAPC/"
				],
				[
					745,
					1,
					"insert",
					{
						"characters": "("
					},
					"AQAAAI0IAAAAAAAAjggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjQgAAAAAAACNCAAAAAAAAAAAAAAAAPC/"
				],
				[
					747,
					1,
					"insert",
					{
						"characters": " ==="
					},
					"BAAAAJkIAAAAAAAAmggAAAAAAAAAAAAAmggAAAAAAACbCAAAAAAAAAAAAACbCAAAAAAAAJwIAAAAAAAAAAAAAJwIAAAAAAAAnQgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmQgAAAAAAACZCAAAAAAAAAAAAAAAAPC/"
				],
				[
					748,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAJ0IAAAAAAAAnggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAnQgAAAAAAACdCAAAAAAAAAAAAAAAAPC/"
				],
				[
					749,
					5,
					"left_delete",
					null,
					"BQAAAJ0IAAAAAAAAnQgAAAAAAAABAAAAIJwIAAAAAAAAnAgAAAAAAAABAAAAPZsIAAAAAAAAmwgAAAAAAAABAAAAPZoIAAAAAAAAmggAAAAAAAABAAAAPZkIAAAAAAAAmQgAAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAnggAAAAAAACeCAAAAAAAAAAAAAAAAPC/"
				],
				[
					750,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAJkIAAAAAAAAmwgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmQgAAAAAAACZCAAAAAAAAAAAAAAAAPC/"
				],
				[
					753,
					1,
					"insert",
					{
						"characters": "0"
					},
					"AQAAAJoIAAAAAAAAmwgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmggAAAAAAACaCAAAAAAAAAAAAAAAAPC/"
				],
				[
					755,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAJoIAAAAAAAAmwgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmggAAAAAAACaCAAAAAAAAAAAAAAAAPC/"
				],
				[
					764,
					1,
					"paste",
					null,
					"AQAAAJoIAAAAAAAAwAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmggAAAAAAACaCAAAAAAAAAAAAAAAAPC/"
				],
				[
					766,
					2,
					"left_delete",
					null,
					"AgAAAL4IAAAAAAAAvggAAAAAAAABAAAAMr0IAAAAAAAAvQgAAAAAAAABAAAAKg",
					"AQAAAAAAAAABAAAAvwgAAAAAAAC/CAAAAAAAAAAAAAAAAPC/"
				],
				[
					768,
					1,
					"insert",
					{
						"characters": "-1"
					},
					"AgAAAL4IAAAAAAAAvwgAAAAAAAAAAAAAvwgAAAAAAADACAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvggAAAAAAAC+CAAAAAAAAAAAAAAAAPC/"
				],
				[
					771,
					1,
					"insert",
					{
						"characters": "=="
					},
					"AgAAAI0IAAAAAAAAjggAAAAAAAAAAAAAjggAAAAAAACPCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjQgAAAAAAACNCAAAAAAAAAAAAAAAAPC/"
				],
				[
					772,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAI8IAAAAAAAAkAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjwgAAAAAAACPCAAAAAAAAAAAAAAAAPC/"
				],
				[
					774,
					1,
					"insert",
					{
						"characters": "="
					},
					"AQAAAI8IAAAAAAAAkAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjwgAAAAAAACPCAAAAAAAAAAAAAAAAPC/"
				],
				[
					776,
					1,
					"insert",
					{
						"characters": "tail"
					},
					"BAAAAI0IAAAAAAAAjggAAAAAAAAAAAAAjggAAAAAAACPCAAAAAAAAAAAAACPCAAAAAAAAJAIAAAAAAAAAAAAAJAIAAAAAAAAkQgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjQgAAAAAAACNCAAAAAAAAAAAAAAAAPC/"
				],
				[
					784,
					1,
					"paste",
					null,
					"AQAAAJEIAAAAAAAAuwgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkQgAAAAAAACRCAAAAAAAAAAAAAAAAPC/"
				],
				[
					785,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAALsIAAAAAAAAvAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAuwgAAAAAAAC7CAAAAAAAAAAAAAAAAPC/"
				],
				[
					788,
					1,
					"insert",
					{
						"characters": "("
					},
					"AQAAAI0IAAAAAAAAjggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjQgAAAAAAACNCAAAAAAAAAAAAAAAAPC/"
				],
				[
					791,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAAPcIAAAAAAAA+AgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA9wgAAAAAAAD3CAAAAAAAAAAAAAAAAPC/"
				],
				[
					796,
					2,
					"right_delete",
					null,
					"AgAAALsHAAAAAAAAuwcAAAAAAAC/AAAAcHJpbnRsbihzIj09PT0gbG9nMlVwKEN1c3RvbVBhcmFtZXRlcnMucXVldWVfZGVwdGgqMik6JHtsb2cyVXAoQ3VzdG9tUGFyYW1ldGVycy5xdWV1ZV9kZXB0aCoyKX0iKQpwcmludGxuKHMiPT09PSBsb2cyVXAoQ3VzdG9tUGFyYW1ldGVycy5xdWV1ZV9kZXB0aCk6JHtsb2cyVXAoQ3VzdG9tUGFyYW1ldGVycy5xdWV1ZV9kZXB0aCl9Iim7BwAAAAAAALsHAAAAAAAAAQAAAAo",
					"AQAAAAAAAAABAAAAeggAAAAAAAC7BwAAAAAAAAAAAAAAAPC/"
				],
				[
					824,
					1,
					"paste",
					null,
					"AQAAALoHAAAAAAAAOAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAugcAAAAAAAC6BwAAAAAAAAAAAAAAAPC/"
				],
				[
					827,
					2,
					"left_delete",
					null,
					"AgAAAAcIAAAAAAAABwgAAAAAAAAFAAAAKyAxLlUGCAAAAAAAAAYIAAAAAAAAAQAAACA",
					"AQAAAAAAAAABAAAABwgAAAAAAAAMCAAAAAAAAAAAAAAAAPC/"
				],
				[
					828,
					1,
					"right_delete",
					null,
					"AQAAAAYIAAAAAAAABggAAAAAAAABAAAAKQ",
					"AQAAAAAAAAABAAAABggAAAAAAAAGCAAAAAAAAAAAAAAAAPC/"
				],
				[
					830,
					1,
					"left_delete",
					null,
					"AQAAAAEIAAAAAAAAAQgAAAAAAAABAAAAKA",
					"AQAAAAAAAAABAAAAAggAAAAAAAACCAAAAAAAAAAAAAAAAPC/"
				],
				[
					838,
					1,
					"insert",
					{
						"characters": "Fuul"
					},
					"BQAAADsIAAAAAAAAPAgAAAAAAAAAAAAAPAgAAAAAAAA8CAAAAAAAAAUAAABFbXB0eTwIAAAAAAAAPQgAAAAAAAAAAAAAPQgAAAAAAAA+CAAAAAAAAAAAAAA+CAAAAAAAAD8IAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAOwgAAAAAAABACAAAAAAAAAAAAAAAAPC/"
				],
				[
					839,
					2,
					"left_delete",
					null,
					"AgAAAD4IAAAAAAAAPggAAAAAAAABAAAAbD0IAAAAAAAAPQgAAAAAAAABAAAAdQ",
					"AQAAAAAAAAABAAAAPwgAAAAAAAA/CAAAAAAAAAAAAAAAAPC/"
				],
				[
					840,
					1,
					"insert",
					{
						"characters": "ll"
					},
					"AgAAAD0IAAAAAAAAPggAAAAAAAAAAAAAPggAAAAAAAA/CAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPQgAAAAAAAA9CAAAAAAAAAAAAAAAAPC/"
				],
				[
					842,
					1,
					"insert",
					{
						"characters": "n"
					},
					"AQAAADsIAAAAAAAAPAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAOwgAAAAAAAA7CAAAAAAAAAAAAAAAAPC/"
				],
				[
					845,
					1,
					"insert",
					{
						"characters": "/"
					},
					"AgAAAHQIAAAAAAAAdQgAAAAAAAAAAAAAdQgAAAAAAAB1CAAAAAAAAAEAAAA9",
					"AQAAAAAAAAABAAAAdQgAAAAAAAB0CAAAAAAAAAAAAAAAAPC/"
				],
				[
					852,
					1,
					"insert",
					{
						"characters": "    "
					},
					"BAAAACsJAAAAAAAALAkAAAAAAAAAAAAALAkAAAAAAAAtCQAAAAAAAAAAAAAtCQAAAAAAAC4JAAAAAAAAAAAAAC4JAAAAAAAALwkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAKwkAAAAAAAArCQAAAAAAAAAAAAAAAPC/"
				],
				[
					853,
					1,
					"insert",
					{
						"characters": "\nin."
					},
					"BQAAAC8JAAAAAAAAMAkAAAAAAAAAAAAAMAkAAAAAAAA0CQAAAAAAAAAAAAA0CQAAAAAAADUJAAAAAAAAAAAAADUJAAAAAAAANgkAAAAAAAAAAAAANgkAAAAAAAA3CQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAALwkAAAAAAAAvCQAAAAAAAAAAAAAAAPC/"
				],
				[
					854,
					1,
					"insert",
					{
						"characters": "a.re"
					},
					"BAAAADcJAAAAAAAAOAkAAAAAAAAAAAAAOAkAAAAAAAA5CQAAAAAAAAAAAAA5CQAAAAAAADoJAAAAAAAAAAAAADoJAAAAAAAAOwkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAANwkAAAAAAAA3CQAAAAAAAAAAAAAAAPC/"
				],
				[
					855,
					1,
					"insert",
					{
						"characters": "ady"
					},
					"AwAAADsJAAAAAAAAPAkAAAAAAAAAAAAAPAkAAAAAAAA9CQAAAAAAAAAAAAA9CQAAAAAAAD4JAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAOwkAAAAAAAA7CQAAAAAAAAAAAAAAAPC/"
				],
				[
					856,
					1,
					"insert",
					{
						"characters": " :="
					},
					"AwAAAD4JAAAAAAAAPwkAAAAAAAAAAAAAPwkAAAAAAABACQAAAAAAAAAAAABACQAAAAAAAEEJAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPgkAAAAAAAA+CQAAAAAAAAAAAAAAAPC/"
				],
				[
					857,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAEEJAAAAAAAAQgkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAQQkAAAAAAABBCQAAAAAAAAAAAAAAAPC/"
				],
				[
					858,
					1,
					"paste",
					null,
					"AQAAAEIJAAAAAAAASQkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAQgkAAAAAAABCCQAAAAAAAAAAAAAAAPC/"
				],
				[
					870,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAE0KAAAAAAAATgoAAAAAAAAAAAAATgoAAAAAAABSCgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATQoAAAAAAABNCgAAAAAAAAAAAAAAAPC/"
				],
				[
					871,
					1,
					"paste",
					null,
					"AQAAAFIKAAAAAAAABgsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUgoAAAAAAABSCgAAAAAAAAAAAAAAAPC/"
				],
				[
					874,
					1,
					"insert",
					{
						"characters": "DEQ"
					},
					"BQAAAKMKAAAAAAAApAoAAAAAAAAAAAAApAoAAAAAAACkCgAAAAAAAAMAAABFTlFOCgAAAAAAAE4KAAAAAAAABAAAACAgICCgCgAAAAAAAKEKAAAAAAAAAAAAAKEKAAAAAAAAogoAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAowoAAAAAAACmCgAAAAAAAAAAAAAAAPC/"
				],
				[
					881,
					1,
					"insert",
					{
						"characters": "read"
					},
					"BQAAALAKAAAAAAAAsQoAAAAAAAAAAAAAsQoAAAAAAACxCgAAAAAAAAUAAAB3cml0ZbEKAAAAAAAAsgoAAAAAAAAAAAAAsgoAAAAAAACzCgAAAAAAAAAAAACzCgAAAAAAALQKAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAsAoAAAAAAAC1CgAAAAAAAAAAAAAAAPC/"
				],
				[
					887,
					1,
					"insert",
					{
						"characters": "tial"
					},
					"BQAAALUKAAAAAAAAtgoAAAAAAAAAAAAAtgoAAAAAAAC2CgAAAAAAAAQAAABoZWFktgoAAAAAAAC3CgAAAAAAAAAAAAC3CgAAAAAAALgKAAAAAAAAAAAAALgKAAAAAAAAuQoAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAtQoAAAAAAAC5CgAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Protocol.scala",
			"settings":
			{
				"buffer_size": 325,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					4,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAMMAAAAAAAAAxAAAAAAAAAAAAAAAxAAAAAAAAADGAAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAwwAAAAAAAADDAAAAAAAAAAAAAAAAAPC/"
				],
				[
					5,
					1,
					"paste",
					null,
					"AQAAAMYAAAAAAAAA4QAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxgAAAAAAAADGAAAAAAAAAAAAAAAAAPC/"
				],
				[
					13,
					1,
					"paste",
					null,
					"AgAAANYAAAAAAAAA4QAAAAAAAAAAAAAA4QAAAAAAAADhAAAAAAAAAAkAAABiZWF0Qnl0ZXM",
					"AQAAAAAAAAABAAAA1gAAAAAAAADfAAAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "/share/code/rocket-chip-dongdeji/src/main/scala/util/package.scala",
			"settings":
			{
				"buffer_size": 12800,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
			]
		},
		{
			"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Xbar.scala",
			"settings":
			{
				"buffer_size": 14500,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					3,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAEA3AAAAAAAAQTcAAAAAAAAAAAAAQTcAAAAAAABCNwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAQDcAAAAAAABANwAAAAAAAAAAAAAAAPC/"
				],
				[
					6,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAJw3AAAAAAAAnTcAAAAAAAAAAAAAnTcAAAAAAACeNwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAnDcAAAAAAACcNwAAAAAAAAAAAAAAAPC/"
				],
				[
					9,
					1,
					"insert",
					{
						"characters": "*/"
					},
					"AgAAAHM4AAAAAAAAdDgAAAAAAAAAAAAAdDgAAAAAAAB1OAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAczgAAAAAAABzOAAAAAAAAAAAAAAAAPC/"
				],
				[
					12,
					1,
					"insert",
					{
						"characters": "/*"
					},
					"AgAAAGU4AAAAAAAAZjgAAAAAAAAAAAAAZjgAAAAAAABnOAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZTgAAAAAAABlOAAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"contents": "Searching 10 files for \"====\" (case sensitive, whole word)\n\n0 matches\n\nSearching 386 files for \"==== edgeIn\" (case sensitive, whole word)\n\n0 matches\n\nSearching 386 files for \"cloneType\" (case sensitive, whole word)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Deinterleaver.scala:\n   64          val qs = maxFlightPerId.zipWithIndex.map { case (mf, i) =>\n   65            if (mf > 0) {\n   66:             val q = Module(new Queue(out.r.bits.cloneType, entries = beats))\n   67              q.suggestName(s\"queue_${i}\")\n   68              q.io\n   ..\n   71              // But, to satisfy type checks we must produce a Wire of the\n   72              // correct type.\n   73:             val q = Wire(new QueueIO(out.r.bits.cloneType, beats))\n   74              q.suggestName(s\"queue_wire_${i}\")\n   75              assert(!q.enq.valid, s\"ID ${i} should not be used\")\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axis/Bundles.scala:\n   25  \n   26  class AXISBundleBits(val params: AXISBundleParameters) extends BundleMap(AXISBundle.keys(params)) {\n   27:   override def cloneType: this.type = (new AXISBundleBits(params)).asInstanceOf[this.type]\n   28    def last = if (params.hasLast) apply(AXISLast) else true.B\n   29    def id   = if (params.hasId)   apply(AXISId)   else 0.U\n   ..\n   35  \n   36  class AXISBundle(val params: AXISBundleParameters) extends IrrevocableIO(new AXISBundleBits(params)) {\n   37:   override def cloneType: this.type = (new AXISBundle(params)).asInstanceOf[this.type]\n   38  }\n   39  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala:\n   49      val tail = RegInit(0.U(32.W))\n   50  \n   51:     val s1 = RegInit(0.U.asTypeof(in.a.cloneType))\n   52  \n   53      val wdata = Vec.tabulate(beatBytes) { i => in.a.bits.data(8*(i+1)-1, 8*i) }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/DebugTransport.scala:\n   41    val op = UInt(DMIConsts.dmiOpSize.W)\n   42  \n   43:   override def cloneType = new DMIAccessUpdate(addrBits).asInstanceOf[this.type]\n   44  }\n   45  \n   ..\n   49    val resp = UInt(DMIConsts.dmiRespSize.W)\n   50  \n   51:   override def cloneType = new DMIAccessCapture(addrBits).asInstanceOf[this.type]\n   52  \n   53  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/DMI.scala:\n   43    val op   = UInt(DMIConsts.dmiOpSize.W)\n   44  \n   45:   override def cloneType = new DMIReq(addrBits).asInstanceOf[this.type]\n   46  }\n   47  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/CloneModule.scala:\n   18    val elements = ListMap(elts.map(d => d.instanceName -> d.chiselCloneType): _*)\n   19    def apply(field: String) = elements(field)\n   20:   override def cloneType = (new ClonePorts(elts: _*)).asInstanceOf[this.type]\n   21  }\n   22  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/LazyModule.scala:\n  501      // Trim trailing _0_1_2 stuff so that when we append _# we don't create collisions.\n  502      val regex = new Regex(\"(_[0-9]+)*$\")\n  503:     val element = if (flip) data.cloneType.flip() else data.cloneType\n  504      (regex.replaceAllIn(key, \"\"), element, i)\n  505    }\n  506  \n  507:   override def cloneType: this.type = new AutoBundle(elts: _*).asInstanceOf[this.type]\n  508  }\n  509  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/Nodes.scala:\n 1626    def makeIOs()(implicit valName: ValName): HeterogeneousBag[B] = {\n 1627      val bundles = this.out.map(_._1)\n 1628:     val ios = IO(Flipped(new HeterogeneousBag(bundles.map(_.cloneType))))\n 1629      ios.suggestName(valName.name)\n 1630      bundles.zip(ios).foreach { case (bundle, io) => bundle <> io }\n ....\n 1690    def makeIOs()(implicit valName: ValName): HeterogeneousBag[B] = {\n 1691      val bundles = this.in.map(_._1)\n 1692:     val ios = IO(new HeterogeneousBag(bundles.map(_.cloneType)))\n 1693      ios.suggestName(valName.name)\n 1694      bundles.zip(ios).foreach { case (bundle, io) => io <> bundle }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/jtag/JtagShifter.scala:\n   37    val bits = Input(gen)  // data to capture, should be always valid\n   38    val capture = Output(Bool())  // will be high in capture state (single cycle), captured on following rising edge\n   39:   override def cloneType = Capture(gen).asInstanceOf[this.type]\n   40  }\n   41  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/jtag/JtagTap.scala:\n   17    val TDO   = Input(new Tristate())\n   18  \n   19:   override def cloneType = new JTAGIO(hasTRSTn).asInstanceOf[this.type]\n   20  }\n   21  \n   ..\n   27    val tapIsInTestLogicReset = Output(Bool())  // synchronously asserted in Test-Logic-Reset state, should NOT hold the FSM in reset\n   28  \n   29:   override def cloneType = new JtagOutput(irLength).asInstanceOf[this.type]\n   30  }\n   31  \n   ..\n   43    val idcode = if (hasIdcode) Some(Input(new JTAGIdcodeBundle())) else None\n   44  \n   45:   override def cloneType = new JtagBlockIO(irLength, hasIdcode).asInstanceOf[this.type]\n   46  }\n   47  \n   ..\n   52    val dataChainIn = Input(new ShifterIO)\n   53  \n   54:   override def cloneType = new JtagControllerIO(irLength).asInstanceOf[this.type]\n   55  }\n   56  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/prci/ClockGroupDriver.scala:\n   38        val elements =  bundles.map(_.member.elements).flatten\n   39        val io = IO(Flipped(RecordMap(elements.map { case (name, data) =>\n   40:         name -> data.cloneType\n   41        }:_*)))\n   42  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/regmapper/RegisterCrossing.scala:\n   54    val response = Irrevocable(Bool()) // ignore .bits\n   55  \n   56:   override def cloneType = new RegisterWriteIO(gen).asInstanceOf[this.type]\n   57  }\n   58  \n   ..\n  130    val response = Irrevocable(gen)\n  131  \n  132:   override def cloneType = new RegisterReadIO(gen).asInstanceOf[this.type]\n  133  }\n  134  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/regmapper/RegisterRouter.scala:\n   47  abstract class IORegisterRouter[T <: Data](devParams: RegisterRouterParams, portBundle: => T)(implicit p: Parameters)\n   48      extends RegisterRouter(devParams) {\n   49:   val ioNode = BundleBridgeSource(() => portBundle.cloneType)\n   50    val port = InModuleBody { ioNode.bundle }\n   51  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/DCache.scala:\n  153    val (tl_out_c, release_queue_empty) =\n  154      if (cacheParams.acquireBeforeRelease) {\n  155:       val q = Module(new Queue(tl_out.c.bits.cloneType, cacheDataBeats, flow = true))\n  156        tl_out.c <> q.io.deq\n  157        (q.io.enq, q.io.count === 0)\n  ...\n  293      }\n  294    val s1_data_way = Wire(init = if (nWays == 1) 1.U else Mux(inWriteback, releaseWay, s1_hit_way))\n  295:   val tl_d_data_encoded = Wire(encodeData(tl_out.d.bits.data, false.B).cloneType)\n  296    val s1_all_data_ways = Vec(data.io.resp ++ (!cacheParams.separateUncachedResp).option(tl_d_data_encoded))\n  297    val s1_mask_xwr = new StoreGen(s1_req.size, s1_req.addr, UInt(0), wordBytes).mask\n  ...\n  311    val s2_cmd_flush_all = s2_req.cmd === M_FLUSH_ALL && !s2_req.size(0)\n  312    val s2_cmd_flush_line = s2_req.cmd === M_FLUSH_ALL && s2_req.size(0)\n  313:   val s2_tlb_xcpt = Reg(tlb.io.resp.cloneType)\n  314:   val s2_pma = Reg(tlb.io.resp.cloneType)\n  315:   val s2_uncached_resp_addr = Reg(s2_req.addr.cloneType) // should be DCE'd in synthesis\n  316    when (s1_valid_not_nacked || s1_flush_valid) {\n  317      s2_req := s1_req\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/HellaCache.scala:\n  309      val read = Decoupled(new L1MetaReadReq).flip\n  310      val write = Decoupled(new L1MetaWriteReq).flip\n  311:     val resp = Vec(nWays, rstVal.cloneType).asOutput\n  312    }\n  313    val rst_cnt = Reg(init=UInt(0, log2Up(nSets+1)))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/ICache.scala:\n  105    val ae = Bool()\n  106  \n  107:   override def cloneType = new ICacheResp(outer).asInstanceOf[this.type]\n  108  }\n  109  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/Multiplier.scala:\n   16    val in2 = Bits(dataBits.W)\n   17    val tag = UInt(tagBits.W)\n   18:   override def cloneType = new MultiplierReq(dataBits, tagBits).asInstanceOf[this.type]\n   19  }\n   20  \n   ..\n   22    val data = Bits(dataBits.W)\n   23    val tag = UInt(tagBits.W)\n   24:   override def cloneType = new MultiplierResp(dataBits, tagBits).asInstanceOf[this.type]\n   25  }\n   26  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/NBDcache.scala:\n   49    val voluntary = Bool()\n   50  \n   51:   override def cloneType = new WritebackReq(params)(p).asInstanceOf[this.type]\n   52  }\n   53  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/PTW.scala:\n   93    val r = Bool()\n   94  \n   95:   override def cloneType = new L2TLBEntry(nSets).asInstanceOf[this.type]\n   96  }\n   97  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/TLB.scala:\n   33    val cmd  = Bits(width = M_SZ)\n   34  \n   35:   override def cloneType = new TLBReq(lgMaxSize).asInstanceOf[this.type]\n   36  }\n   37  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/FPU.scala:\n  232    val in3 = Bits(width = fLen+1)\n  233  \n  234:   override def cloneType = new FPInput().asInstanceOf[this.type]\n  235  }\n  236  \n  ...\n  284        val exp = UInt(expWidth.W)\n  285        val sig = UInt((ieeeWidth-expWidth-1).W)\n  286:       override def cloneType = new IEEEBundle().asInstanceOf[this.type]\n  287      }\n  288      new IEEEBundle\n  ...\n  453      val toint = Bits(width = xLen)\n  454      val exc = Bits(width = FPConstants.FLAGS_SZ)\n  455:     override def cloneType = new Output().asInstanceOf[this.type]\n  456    }\n  457    val io = new Bundle {\n  ...\n  904      val cp = Bool()\n  905      val pipeid = UInt(width = log2Ceil(pipes.size))\n  906:     override def cloneType: this.type = new WBInfo().asInstanceOf[this.type]\n  907    }\n  908  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Bundle_ACancel.scala:\n   16    val e =         Decoupled(new TLBundleE(params))\n   17  \n   18:   override def cloneType: this.type = (new TLBundle_ACancel(params)).asInstanceOf[this.type]\n   19    val elements = ListMap(\"e\" -> e, \"d\" -> d, \"c\" -> c, \"b\" -> b, \"a\" -> a)\n   20  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Bundles.scala:\n  259    def e: DecoupledIO[TLBundleE] = optE.getOrElse(Wire(Decoupled(new TLBundleE(params))))\n  260  \n  261:   override def cloneType: this.type = (new TLBundle(params)).asInstanceOf[this.type]\n  262    val elements =\n  263      if (params.hasBCE) ListMap(\"e\" -> e, \"d\" -> d, \"c\" -> c, \"b\" -> b, \"a\" -> a)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/SRAM.scala:\n   51      minLatency = 1))) // no bypass needed for this device\n   52  \n   53:   val notifyNode = ecc.notifyErrors.option(BundleBridgeSource(() => new TLRAMErrors(ecc, log2Ceil(address.max)).cloneType))\n   54  \n   55    private val outer = this\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Arbiters.scala:\n   12  \n   13    val io = new Bundle {\n   14:     val in = Vec(arbN, Decoupled(typ.cloneType)).flip\n   15:     val out = Decoupled(typ.cloneType)\n   16    }\n   17  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/BundleMap.scala:\n  101   */\n  102  \n  103: // If you extend this class, you must either redefine cloneType or have a fields constructor\n  104  class BundleMap(val fields: Seq[BundleFieldBase]) extends Record with CustomBulkAssignable {\n  105    // All fields must have distinct key.names\n  ...\n  107  \n  108    val elements: ListMap[String, Data] = ListMap(fields.map { bf => bf.key.name -> chisel3.experimental.DataMirror.internal.chiselTypeClone(bf.data) } :_*)\n  109:   override def cloneType: this.type = {\n  110      try {\n  111        this.getClass.getConstructors.head.newInstance(fields).asInstanceOf[this.type]\n  112      } catch {\n  113        case e: java.lang.IllegalArgumentException =>\n  114:         throw new Exception(\"Unable to use BundleMap.cloneType on \" +\n  115                         this.getClass + \", probably because \" + this.getClass +\n  116                         \" does not have a constructor accepting BundleFields.  Consider overriding \" +\n  117:                        \"cloneType() on \" + this.getClass, e)\n  118      }\n  119    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/CreditedIO.scala:\n   38  final class CreditedIO[T <: Data](gen: T) extends Bundle\n   39  {\n   40:   override def cloneType: this.type = new CreditedIO(genType).asInstanceOf[this.type]\n   41    def genType: T = gen\n   42  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/HeterogeneousBag.scala:\n   12  \n   13    val elements = ListMap(elts.zipWithIndex.map { case (n,i) => (i.toString, n) }:_*)\n   14:   override def cloneType: this.type = (new HeterogeneousBag(elts.map(_.chiselCloneType))).asInstanceOf[this.type]\n   15  \n   16    // IndexedSeq has its own hashCode/equals that we must not use\n   ..\n   21  object HeterogeneousBag\n   22  {\n   23:   def fromNode[D <: Data, E](elts: Seq[(D, E)]) = new HeterogeneousBag(elts.map(_._1.cloneType))\n   24  }\n   25  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/IdentityModule.scala:\n    8  {\n    9    val io = new Bundle {\n   10:     val in = gen.cloneType.flip\n   11:     val out = gen.cloneType\n   12    }\n   13  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Misc.scala:\n   63    }\n   64    def apply[T <: Data](valids: Seq[ValidIO[T]]): ValidIO[T] = {\n   65:     val out = Wire(Valid(valids.head.bits.cloneType))\n   66      out.valid := valids.map(_.valid).reduce(_ || _)\n   67      out.bits := MuxCase(valids.head.bits,\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/RationalCrossing.scala:\n   58    val sink   = Input(UInt(2.W))\n   59  \n   60:   override def cloneType: this.type = new RationalIO(gen).asInstanceOf[this.type]\n   61  }\n   62  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ReadyValidCancel.scala:\n   20    val bits       = Output(gen)\n   21    def validQual(): Bool = earlyValid && !lateCancel\n   22:   override def cloneType: this.type = ValidCancel(gen).asInstanceOf[this.type]\n   23  \n   24    /** Down-converts a ValidCancel output to a Valid bundle, dropping early/late timing split. */\n   ..\n   49    def mightFire(): Bool = ready && earlyValid\n   50    def fire():      Bool = ready && validQual()\n   51:   override def cloneType: this.type = ReadyValidCancel(gen).asInstanceOf[this.type]\n   52  \n   53    /** Down-converts a ReadyValidCancel output to a DecoupledIO bundle, dropping early/late timing split. */\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/RecordMap.scala:\n   21    def data = elements.values\n   22  \n   23:   override def cloneType: this.type = (new RecordMap(eltMap)).asInstanceOf[this.type]\n   24  \n   25  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ReorderQueue.scala:\n    7  \n    8  class ReorderQueueWrite[T <: Data](dType: T, tagWidth: Int) extends Bundle {\n    9:   val data = dType.cloneType\n   10    val tag = UInt(width = tagWidth)\n   11  \n   12:   override def cloneType =\n   13      new ReorderQueueWrite(dType, tagWidth).asInstanceOf[this.type]\n   14  }\n   ..\n   17    extends DecoupledIO(new ReorderQueueWrite(dType, tagWidth)) {\n   18  \n   19:   override def cloneType =\n   20      new ReorderEnqueueIO(dType, tagWidth).asInstanceOf[this.type]\n   21  }\n   ..\n   24    val valid = Bool(INPUT)\n   25    val tag = UInt(INPUT, tagWidth)\n   26:   val data = dType.cloneType.asOutput\n   27    val matches = Bool(OUTPUT)\n   28  \n   29:   override def cloneType =\n   30      new ReorderDequeueIO(dType, tagWidth).asInstanceOf[this.type]\n   31  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Repeater.scala:\n   13      val repeat = Input(Bool())\n   14      val full = Output(Bool())\n   15:     val enq = Flipped(Decoupled(gen.cloneType))\n   16:     val deq = Decoupled(gen.cloneType)\n   17    } )\n   18  \n   19    val full = RegInit(false.B)\n   20:   val saved = Reg(gen.cloneType)\n   21  \n   22    // When !full, a repeater is pass-through\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ShiftQueue.scala:\n   58  {\n   59    def apply[T <: Data](enq: DecoupledIO[T], entries: Int = 2, pipe: Boolean = false, flow: Boolean = false): DecoupledIO[T] = {\n   60:     val q = Module(new ShiftQueue(enq.bits.cloneType, entries, pipe, flow))\n   61      q.io.enq <> enq\n   62      q.io.deq\n\n67 matches across 36 files\n\n\nSearching 386 files for \"cloneType\" (case sensitive, whole word)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Deinterleaver.scala:\n   64          val qs = maxFlightPerId.zipWithIndex.map { case (mf, i) =>\n   65            if (mf > 0) {\n   66:             val q = Module(new Queue(out.r.bits.cloneType, entries = beats))\n   67              q.suggestName(s\"queue_${i}\")\n   68              q.io\n   ..\n   71              // But, to satisfy type checks we must produce a Wire of the\n   72              // correct type.\n   73:             val q = Wire(new QueueIO(out.r.bits.cloneType, beats))\n   74              q.suggestName(s\"queue_wire_${i}\")\n   75              assert(!q.enq.valid, s\"ID ${i} should not be used\")\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axis/Bundles.scala:\n   25  \n   26  class AXISBundleBits(val params: AXISBundleParameters) extends BundleMap(AXISBundle.keys(params)) {\n   27:   override def cloneType: this.type = (new AXISBundleBits(params)).asInstanceOf[this.type]\n   28    def last = if (params.hasLast) apply(AXISLast) else true.B\n   29    def id   = if (params.hasId)   apply(AXISId)   else 0.U\n   ..\n   35  \n   36  class AXISBundle(val params: AXISBundleParameters) extends IrrevocableIO(new AXISBundleBits(params)) {\n   37:   override def cloneType: this.type = (new AXISBundle(params)).asInstanceOf[this.type]\n   38  }\n   39  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala:\n   49      val tail = RegInit(0.U(32.W))\n   50  \n   51:     val s1 = RegInit(0.U.asTypeof(in.a.cloneType))\n   52  \n   53      val wdata = Vec.tabulate(beatBytes) { i => in.a.bits.data(8*(i+1)-1, 8*i) }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/DebugTransport.scala:\n   41    val op = UInt(DMIConsts.dmiOpSize.W)\n   42  \n   43:   override def cloneType = new DMIAccessUpdate(addrBits).asInstanceOf[this.type]\n   44  }\n   45  \n   ..\n   49    val resp = UInt(DMIConsts.dmiRespSize.W)\n   50  \n   51:   override def cloneType = new DMIAccessCapture(addrBits).asInstanceOf[this.type]\n   52  \n   53  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/DMI.scala:\n   43    val op   = UInt(DMIConsts.dmiOpSize.W)\n   44  \n   45:   override def cloneType = new DMIReq(addrBits).asInstanceOf[this.type]\n   46  }\n   47  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/CloneModule.scala:\n   18    val elements = ListMap(elts.map(d => d.instanceName -> d.chiselCloneType): _*)\n   19    def apply(field: String) = elements(field)\n   20:   override def cloneType = (new ClonePorts(elts: _*)).asInstanceOf[this.type]\n   21  }\n   22  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/LazyModule.scala:\n  501      // Trim trailing _0_1_2 stuff so that when we append _# we don't create collisions.\n  502      val regex = new Regex(\"(_[0-9]+)*$\")\n  503:     val element = if (flip) data.cloneType.flip() else data.cloneType\n  504      (regex.replaceAllIn(key, \"\"), element, i)\n  505    }\n  506  \n  507:   override def cloneType: this.type = new AutoBundle(elts: _*).asInstanceOf[this.type]\n  508  }\n  509  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/Nodes.scala:\n 1626    def makeIOs()(implicit valName: ValName): HeterogeneousBag[B] = {\n 1627      val bundles = this.out.map(_._1)\n 1628:     val ios = IO(Flipped(new HeterogeneousBag(bundles.map(_.cloneType))))\n 1629      ios.suggestName(valName.name)\n 1630      bundles.zip(ios).foreach { case (bundle, io) => bundle <> io }\n ....\n 1690    def makeIOs()(implicit valName: ValName): HeterogeneousBag[B] = {\n 1691      val bundles = this.in.map(_._1)\n 1692:     val ios = IO(new HeterogeneousBag(bundles.map(_.cloneType)))\n 1693      ios.suggestName(valName.name)\n 1694      bundles.zip(ios).foreach { case (bundle, io) => io <> bundle }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/jtag/JtagShifter.scala:\n   37    val bits = Input(gen)  // data to capture, should be always valid\n   38    val capture = Output(Bool())  // will be high in capture state (single cycle), captured on following rising edge\n   39:   override def cloneType = Capture(gen).asInstanceOf[this.type]\n   40  }\n   41  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/jtag/JtagTap.scala:\n   17    val TDO   = Input(new Tristate())\n   18  \n   19:   override def cloneType = new JTAGIO(hasTRSTn).asInstanceOf[this.type]\n   20  }\n   21  \n   ..\n   27    val tapIsInTestLogicReset = Output(Bool())  // synchronously asserted in Test-Logic-Reset state, should NOT hold the FSM in reset\n   28  \n   29:   override def cloneType = new JtagOutput(irLength).asInstanceOf[this.type]\n   30  }\n   31  \n   ..\n   43    val idcode = if (hasIdcode) Some(Input(new JTAGIdcodeBundle())) else None\n   44  \n   45:   override def cloneType = new JtagBlockIO(irLength, hasIdcode).asInstanceOf[this.type]\n   46  }\n   47  \n   ..\n   52    val dataChainIn = Input(new ShifterIO)\n   53  \n   54:   override def cloneType = new JtagControllerIO(irLength).asInstanceOf[this.type]\n   55  }\n   56  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/prci/ClockGroupDriver.scala:\n   38        val elements =  bundles.map(_.member.elements).flatten\n   39        val io = IO(Flipped(RecordMap(elements.map { case (name, data) =>\n   40:         name -> data.cloneType\n   41        }:_*)))\n   42  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/regmapper/RegisterCrossing.scala:\n   54    val response = Irrevocable(Bool()) // ignore .bits\n   55  \n   56:   override def cloneType = new RegisterWriteIO(gen).asInstanceOf[this.type]\n   57  }\n   58  \n   ..\n  130    val response = Irrevocable(gen)\n  131  \n  132:   override def cloneType = new RegisterReadIO(gen).asInstanceOf[this.type]\n  133  }\n  134  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/regmapper/RegisterRouter.scala:\n   47  abstract class IORegisterRouter[T <: Data](devParams: RegisterRouterParams, portBundle: => T)(implicit p: Parameters)\n   48      extends RegisterRouter(devParams) {\n   49:   val ioNode = BundleBridgeSource(() => portBundle.cloneType)\n   50    val port = InModuleBody { ioNode.bundle }\n   51  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/DCache.scala:\n  153    val (tl_out_c, release_queue_empty) =\n  154      if (cacheParams.acquireBeforeRelease) {\n  155:       val q = Module(new Queue(tl_out.c.bits.cloneType, cacheDataBeats, flow = true))\n  156        tl_out.c <> q.io.deq\n  157        (q.io.enq, q.io.count === 0)\n  ...\n  293      }\n  294    val s1_data_way = Wire(init = if (nWays == 1) 1.U else Mux(inWriteback, releaseWay, s1_hit_way))\n  295:   val tl_d_data_encoded = Wire(encodeData(tl_out.d.bits.data, false.B).cloneType)\n  296    val s1_all_data_ways = Vec(data.io.resp ++ (!cacheParams.separateUncachedResp).option(tl_d_data_encoded))\n  297    val s1_mask_xwr = new StoreGen(s1_req.size, s1_req.addr, UInt(0), wordBytes).mask\n  ...\n  311    val s2_cmd_flush_all = s2_req.cmd === M_FLUSH_ALL && !s2_req.size(0)\n  312    val s2_cmd_flush_line = s2_req.cmd === M_FLUSH_ALL && s2_req.size(0)\n  313:   val s2_tlb_xcpt = Reg(tlb.io.resp.cloneType)\n  314:   val s2_pma = Reg(tlb.io.resp.cloneType)\n  315:   val s2_uncached_resp_addr = Reg(s2_req.addr.cloneType) // should be DCE'd in synthesis\n  316    when (s1_valid_not_nacked || s1_flush_valid) {\n  317      s2_req := s1_req\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/HellaCache.scala:\n  309      val read = Decoupled(new L1MetaReadReq).flip\n  310      val write = Decoupled(new L1MetaWriteReq).flip\n  311:     val resp = Vec(nWays, rstVal.cloneType).asOutput\n  312    }\n  313    val rst_cnt = Reg(init=UInt(0, log2Up(nSets+1)))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/ICache.scala:\n  105    val ae = Bool()\n  106  \n  107:   override def cloneType = new ICacheResp(outer).asInstanceOf[this.type]\n  108  }\n  109  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/Multiplier.scala:\n   16    val in2 = Bits(dataBits.W)\n   17    val tag = UInt(tagBits.W)\n   18:   override def cloneType = new MultiplierReq(dataBits, tagBits).asInstanceOf[this.type]\n   19  }\n   20  \n   ..\n   22    val data = Bits(dataBits.W)\n   23    val tag = UInt(tagBits.W)\n   24:   override def cloneType = new MultiplierResp(dataBits, tagBits).asInstanceOf[this.type]\n   25  }\n   26  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/NBDcache.scala:\n   49    val voluntary = Bool()\n   50  \n   51:   override def cloneType = new WritebackReq(params)(p).asInstanceOf[this.type]\n   52  }\n   53  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/PTW.scala:\n   93    val r = Bool()\n   94  \n   95:   override def cloneType = new L2TLBEntry(nSets).asInstanceOf[this.type]\n   96  }\n   97  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/TLB.scala:\n   33    val cmd  = Bits(width = M_SZ)\n   34  \n   35:   override def cloneType = new TLBReq(lgMaxSize).asInstanceOf[this.type]\n   36  }\n   37  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/FPU.scala:\n  232    val in3 = Bits(width = fLen+1)\n  233  \n  234:   override def cloneType = new FPInput().asInstanceOf[this.type]\n  235  }\n  236  \n  ...\n  284        val exp = UInt(expWidth.W)\n  285        val sig = UInt((ieeeWidth-expWidth-1).W)\n  286:       override def cloneType = new IEEEBundle().asInstanceOf[this.type]\n  287      }\n  288      new IEEEBundle\n  ...\n  453      val toint = Bits(width = xLen)\n  454      val exc = Bits(width = FPConstants.FLAGS_SZ)\n  455:     override def cloneType = new Output().asInstanceOf[this.type]\n  456    }\n  457    val io = new Bundle {\n  ...\n  904      val cp = Bool()\n  905      val pipeid = UInt(width = log2Ceil(pipes.size))\n  906:     override def cloneType: this.type = new WBInfo().asInstanceOf[this.type]\n  907    }\n  908  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Bundle_ACancel.scala:\n   16    val e =         Decoupled(new TLBundleE(params))\n   17  \n   18:   override def cloneType: this.type = (new TLBundle_ACancel(params)).asInstanceOf[this.type]\n   19    val elements = ListMap(\"e\" -> e, \"d\" -> d, \"c\" -> c, \"b\" -> b, \"a\" -> a)\n   20  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Bundles.scala:\n  259    def e: DecoupledIO[TLBundleE] = optE.getOrElse(Wire(Decoupled(new TLBundleE(params))))\n  260  \n  261:   override def cloneType: this.type = (new TLBundle(params)).asInstanceOf[this.type]\n  262    val elements =\n  263      if (params.hasBCE) ListMap(\"e\" -> e, \"d\" -> d, \"c\" -> c, \"b\" -> b, \"a\" -> a)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/SRAM.scala:\n   51      minLatency = 1))) // no bypass needed for this device\n   52  \n   53:   val notifyNode = ecc.notifyErrors.option(BundleBridgeSource(() => new TLRAMErrors(ecc, log2Ceil(address.max)).cloneType))\n   54  \n   55    private val outer = this\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Arbiters.scala:\n   12  \n   13    val io = new Bundle {\n   14:     val in = Vec(arbN, Decoupled(typ.cloneType)).flip\n   15:     val out = Decoupled(typ.cloneType)\n   16    }\n   17  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/BundleMap.scala:\n  101   */\n  102  \n  103: // If you extend this class, you must either redefine cloneType or have a fields constructor\n  104  class BundleMap(val fields: Seq[BundleFieldBase]) extends Record with CustomBulkAssignable {\n  105    // All fields must have distinct key.names\n  ...\n  107  \n  108    val elements: ListMap[String, Data] = ListMap(fields.map { bf => bf.key.name -> chisel3.experimental.DataMirror.internal.chiselTypeClone(bf.data) } :_*)\n  109:   override def cloneType: this.type = {\n  110      try {\n  111        this.getClass.getConstructors.head.newInstance(fields).asInstanceOf[this.type]\n  112      } catch {\n  113        case e: java.lang.IllegalArgumentException =>\n  114:         throw new Exception(\"Unable to use BundleMap.cloneType on \" +\n  115                         this.getClass + \", probably because \" + this.getClass +\n  116                         \" does not have a constructor accepting BundleFields.  Consider overriding \" +\n  117:                        \"cloneType() on \" + this.getClass, e)\n  118      }\n  119    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/CreditedIO.scala:\n   38  final class CreditedIO[T <: Data](gen: T) extends Bundle\n   39  {\n   40:   override def cloneType: this.type = new CreditedIO(genType).asInstanceOf[this.type]\n   41    def genType: T = gen\n   42  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/HeterogeneousBag.scala:\n   12  \n   13    val elements = ListMap(elts.zipWithIndex.map { case (n,i) => (i.toString, n) }:_*)\n   14:   override def cloneType: this.type = (new HeterogeneousBag(elts.map(_.chiselCloneType))).asInstanceOf[this.type]\n   15  \n   16    // IndexedSeq has its own hashCode/equals that we must not use\n   ..\n   21  object HeterogeneousBag\n   22  {\n   23:   def fromNode[D <: Data, E](elts: Seq[(D, E)]) = new HeterogeneousBag(elts.map(_._1.cloneType))\n   24  }\n   25  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/IdentityModule.scala:\n    8  {\n    9    val io = new Bundle {\n   10:     val in = gen.cloneType.flip\n   11:     val out = gen.cloneType\n   12    }\n   13  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Misc.scala:\n   63    }\n   64    def apply[T <: Data](valids: Seq[ValidIO[T]]): ValidIO[T] = {\n   65:     val out = Wire(Valid(valids.head.bits.cloneType))\n   66      out.valid := valids.map(_.valid).reduce(_ || _)\n   67      out.bits := MuxCase(valids.head.bits,\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/RationalCrossing.scala:\n   58    val sink   = Input(UInt(2.W))\n   59  \n   60:   override def cloneType: this.type = new RationalIO(gen).asInstanceOf[this.type]\n   61  }\n   62  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ReadyValidCancel.scala:\n   20    val bits       = Output(gen)\n   21    def validQual(): Bool = earlyValid && !lateCancel\n   22:   override def cloneType: this.type = ValidCancel(gen).asInstanceOf[this.type]\n   23  \n   24    /** Down-converts a ValidCancel output to a Valid bundle, dropping early/late timing split. */\n   ..\n   49    def mightFire(): Bool = ready && earlyValid\n   50    def fire():      Bool = ready && validQual()\n   51:   override def cloneType: this.type = ReadyValidCancel(gen).asInstanceOf[this.type]\n   52  \n   53    /** Down-converts a ReadyValidCancel output to a DecoupledIO bundle, dropping early/late timing split. */\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/RecordMap.scala:\n   21    def data = elements.values\n   22  \n   23:   override def cloneType: this.type = (new RecordMap(eltMap)).asInstanceOf[this.type]\n   24  \n   25  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ReorderQueue.scala:\n    7  \n    8  class ReorderQueueWrite[T <: Data](dType: T, tagWidth: Int) extends Bundle {\n    9:   val data = dType.cloneType\n   10    val tag = UInt(width = tagWidth)\n   11  \n   12:   override def cloneType =\n   13      new ReorderQueueWrite(dType, tagWidth).asInstanceOf[this.type]\n   14  }\n   ..\n   17    extends DecoupledIO(new ReorderQueueWrite(dType, tagWidth)) {\n   18  \n   19:   override def cloneType =\n   20      new ReorderEnqueueIO(dType, tagWidth).asInstanceOf[this.type]\n   21  }\n   ..\n   24    val valid = Bool(INPUT)\n   25    val tag = UInt(INPUT, tagWidth)\n   26:   val data = dType.cloneType.asOutput\n   27    val matches = Bool(OUTPUT)\n   28  \n   29:   override def cloneType =\n   30      new ReorderDequeueIO(dType, tagWidth).asInstanceOf[this.type]\n   31  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Repeater.scala:\n   13      val repeat = Input(Bool())\n   14      val full = Output(Bool())\n   15:     val enq = Flipped(Decoupled(gen.cloneType))\n   16:     val deq = Decoupled(gen.cloneType)\n   17    } )\n   18  \n   19    val full = RegInit(false.B)\n   20:   val saved = Reg(gen.cloneType)\n   21  \n   22    // When !full, a repeater is pass-through\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ShiftQueue.scala:\n   58  {\n   59    def apply[T <: Data](enq: DecoupledIO[T], entries: Int = 2, pipe: Boolean = false, flow: Boolean = false): DecoupledIO[T] = {\n   60:     val q = Module(new ShiftQueue(enq.bits.cloneType, entries, pipe, flow))\n   61      q.io.enq <> enq\n   62      q.io.deq\n\n67 matches across 36 files\n\n\nSearching 386 files for \"asTypeof\" (case sensitive, whole word)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala:\n   49      val tail = RegInit(0.U(32.W))\n   50  \n   51:     val s1 = RegInit(0.U.asTypeof(in.a.cloneType))\n   52  \n   53      val wdata = Vec.tabulate(beatBytes) { i => in.a.bits.data(8*(i+1)-1, 8*i) }\n\n1 match in 1 file\n\n\nSearching 386 files for \"asTypeof\" (whole word)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala:\n   49      val tail = RegInit(0.U(32.W))\n   50  \n   51:     val s1 = RegInit(0.U.asTypeof(in.a.cloneType))\n   52  \n   53      val wdata = Vec.tabulate(beatBytes) { i => in.a.bits.data(8*(i+1)-1, 8*i) }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/Debug.scala:\n  332      //               register accesses, which will keep returning 'busy' to the debugger interface.\n  333  \n  334:     val DMCONTROLReset = WireInit(0.U.asTypeOf(new DMCONTROLFields()))\n  335:     val DMCONTROLNxt = WireInit(0.U.asTypeOf(new DMCONTROLFields()))\n  336:     val DMCONTROLReg = RegNext(next=DMCONTROLNxt, init=0.U.asTypeOf(DMCONTROLNxt)).suggestName(\"DMCONTROLReg\")\n  337  \n  338      val hartsel_mask = if (nComponents > 1) ((1 << p(MaxHartIdBits)) - 1).U else 0.U\n  339:     val DMCONTROLWrData = WireInit(0.U.asTypeOf(new DMCONTROLFields()))\n  340      val dmactiveWrEn        = WireInit(false.B)\n  341      val ndmresetWrEn        = WireInit(false.B)\n  ...\n  372      // (implying nonexistence according to the Debug Spec).\n  373  \n  374:     val HARTINFORdData = WireInit(0.U.asTypeOf(new HARTINFOFields()))\n  375      if (cfg.atzero) when (dmAuthenticated) {\n  376        HARTINFORdData.dataaccess  := true.B\n  ...\n  390        // The following need to be declared even if supportHartArray is false due to reference\n  391        // at compile time by dmiNode.regmap\n  392:     val HAWINDOWSELWrData = WireInit(0.U.asTypeOf(new HAWINDOWSELFields()))\n  393      val HAWINDOWSELWrEn   = WireInit(false.B)\n  394  \n  395:     val HAWINDOWRdData = WireInit(0.U.asTypeOf(new HAWINDOWFields()))\n  396:     val HAWINDOWWrData = WireInit(0.U.asTypeOf(new HAWINDOWFields()))\n  397      val HAWINDOWWrEn   = WireInit(false.B)\n  398  \n  ...\n  402      }\n  403  \n  404:     val HAWINDOWSELNxt = WireInit(0.U.asTypeOf(new HAWINDOWSELFields()))\n  405:     val HAWINDOWSELReg = RegNext(next=HAWINDOWSELNxt, init=0.U.asTypeOf(HAWINDOWSELNxt))\n  406  \n  407      if (supportHartArray) {\n  408:       val HAWINDOWSELReset = WireInit(0.U.asTypeOf(new HAWINDOWSELFields()))\n  409  \n  410        HAWINDOWSELNxt := HAWINDOWSELReg\n  ...\n  427          val sliceMask = if (nComponents > ((ii*haWindowSize) + haWindowSize-1)) (BigInt(1) << haWindowSize) - 1  // All harts in this slice exist\n  428                          else (BigInt(1)<<(nComponents - (ii*haWindowSize))) - 1         // Partial last slice\n  429:         val HAMASKRst = WireInit(0.U.asTypeOf(new HAWINDOWFields()))\n  430:         val HAMASKNxt = WireInit(0.U.asTypeOf(new HAWINDOWFields()))\n  431:         val HAMASKReg = RegNext(next=HAMASKNxt, init=0.U.asTypeOf(HAMASKNxt))\n  432  \n  433          when (ii.U === HAWINDOWSELReg.hawindowsel) {\n  ...\n  469      val hrmask    = Wire(Vec(nComponents, Bool()))\n  470      val hrmaskNxt = Wire(Vec(nComponents, Bool()))\n  471:     val hrmaskReg = RegNext(next=hrmaskNxt, init=0.U.asTypeOf(hrmaskNxt)).suggestName(\"hrmaskReg\")\n  472  \n  473      hrmaskNxt := hrmaskReg\n  ...\n  550  \n  551      val debugIntNxt = WireInit(VecInit(Seq.fill(nComponents) {false.B} ))\n  552:     val debugIntRegs = RegNext(next=debugIntNxt, init=0.U.asTypeOf(debugIntNxt)).suggestName(\"debugIntRegs\")\n  553  \n  554      debugIntNxt := debugIntRegs\n  ...\n  607      if (cfg.hasHartResets) {\n  608        val hartResetNxt = Wire(Vec(nComponents, Bool()))\n  609:       val hartResetReg = RegNext(next=hartResetNxt, init=0.U.asTypeOf(hartResetNxt))\n  610  \n  611        for (component <- 0 until nComponents) {\n  ...\n  883      //----DMSTATUS\n  884  \n  885:     val DMSTATUSRdData = WireInit(0.U.asTypeOf(new DMSTATUSFields()))\n  886      DMSTATUSRdData.authenticated := dmAuthenticated\n  887      DMSTATUSRdData.version       := 2.U    // Version 0.13\n  ...\n  929      //----DMCS2 (Halt Groups)\n  930  \n  931:     val DMCS2RdData    = WireInit(0.U.asTypeOf(new DMCS2Fields()))\n  932:     val DMCS2WrData    = WireInit(0.U.asTypeOf(new DMCS2Fields()))\n  933      val hgselectWrEn   = WireInit(false.B)\n  934      val hgwriteWrEn    = WireInit(false.B)\n  ...\n 1072  \n 1073      val haltedSummary = Cat(haltedStatus.map(_.orR).reverse)\n 1074:     val HALTSUM1RdData = haltedSummary.asTypeOf(new HALTSUM1Fields())\n 1075  \n 1076      val selectedHaltedStatus = Mux((selectedHartReg >> 5) > numHaltedStatus.U, 0.U, haltedStatus(selectedHartReg >> 5))\n 1077:     val HALTSUM0RdData = selectedHaltedStatus.asTypeOf(new HALTSUM0Fields())\n 1078  \n 1079      // Since we only support 1024 harts, we don't implement HALTSUM2 or HALTSUM3\n ....\n 1081      //----ABSTRACTCS\n 1082  \n 1083:     val ABSTRACTCSReset = WireInit(0.U.asTypeOf(new ABSTRACTCSFields()))\n 1084      ABSTRACTCSReset.datacount   := cfg.nAbstractDataWords.U\n 1085      ABSTRACTCSReset.progbufsize := cfg.nProgramBufferWords.U\n 1086  \n 1087      val ABSTRACTCSReg       = Reg(new ABSTRACTCSFields())\n 1088:     val ABSTRACTCSWrData    = WireInit(0.U.asTypeOf(new ABSTRACTCSFields()))\n 1089      val ABSTRACTCSRdData    = WireInit(ABSTRACTCSReg)\n 1090  \n ....\n 1128      //---- ABSTRACTAUTO\n 1129  \n 1130:     val ABSTRACTAUTOReset     = WireInit(0.U.asTypeOf(new ABSTRACTAUTOFields()))\n 1131      val ABSTRACTAUTOReg       = Reg(new ABSTRACTAUTOFields())\n 1132:     val ABSTRACTAUTOWrData    = WireInit(0.U.asTypeOf(new ABSTRACTAUTOFields()))\n 1133      val ABSTRACTAUTORdData    = WireInit(ABSTRACTAUTOReg)\n 1134  \n ....\n 1169      //---- COMMAND\n 1170  \n 1171:     val COMMANDReset = WireInit(0.U.asTypeOf(new COMMANDFields()))\n 1172      val COMMANDReg = Reg(new COMMANDFields())\n 1173  \n 1174      val COMMANDWrDataVal    = WireInit(0.U(32.W))\n 1175:     val COMMANDWrData       = WireInit(COMMANDWrDataVal.asTypeOf(new COMMANDFields()))\n 1176      val COMMANDWrEnMaybe    = WireInit(false.B)\n 1177      val COMMANDWrEnLegal    = WireInit(false.B)\n ....\n 1380      val goAbstract   = WireInit(false.B)\n 1381      val goCustom     = WireInit(false.B)\n 1382:     val jalAbstract  = WireInit(Instructions.JAL.value.U.asTypeOf(new GeneratedUJ()))\n 1383      jalAbstract.setImm(ABSTRACT(cfg) - WHERETO)\n 1384  \n ....\n 1400      }\n 1401  \n 1402:     val flags = WireInit(VecInit(Seq.fill(1 << selectedHartReg.getWidth) {0.U.asTypeOf(new flagBundle())} ))\n 1403      assert ((hartSelFuncs.hartSelToHartId(selectedHartReg) < flags.size.U),\n 1404        s\"HartSel to HartId Mapping is illegal for this Debug Implementation, because HartID must be < ${flags.size} for it to work.\")\n ....\n 1414      //----------------------------\n 1415  \n 1416:     val accessRegisterCommandWr  = WireInit(COMMANDWrData.asUInt().asTypeOf(new ACCESS_REGISTERFields()))\n 1417:     val accessRegisterCommandReg = WireInit(COMMANDReg.asUInt().asTypeOf(new ACCESS_REGISTERFields()))\n 1418  \n 1419      // TODO: Quick Access\n ....\n 1474        val offset = if (cfg.atzero) DATA else (DATA-0x800) & 0xFFF\n 1475        val base = if (cfg.atzero) 0.U else Mux(accessRegisterCommandReg.regno(0), 8.U, 9.U)\n 1476:       inst.opcode := (Instructions.LW.value.U.asTypeOf(new GeneratedI())).opcode\n 1477        inst.rd     := (accessRegisterCommandReg.regno & 0x1F.U)\n 1478        inst.funct3 := accessRegisterCommandReg.size\n ....\n 1486        val offset = if (cfg.atzero) DATA else (DATA-0x800) & 0xFFF\n 1487        val base = if (cfg.atzero) 0.U else Mux(accessRegisterCommandReg.regno(0), 8.U, 9.U)\n 1488:       inst.opcode := (Instructions.SW.value.U.asTypeOf(new GeneratedS())).opcode\n 1489        inst.immlo  := (offset & 0x1F).U\n 1490        inst.funct3 := accessRegisterCommandReg.size\n ....\n 1498        val inst = Wire(new GeneratedCSR())\n 1499        val base = Mux(accessRegisterCommandReg.regno(0), 8.U, 9.U)     // use s0 as base for odd regs, s1 as base for even regs\n 1500:       inst := (Instructions.CSRRW.value.U.asTypeOf(new GeneratedCSR()))\n 1501        inst.imm := CSRs.dscratch1.U\n 1502        inst.rs1 := base\n ....\n 1506  \n 1507      val nop = Wire(new GeneratedI())\n 1508:     nop := Instructions.ADDI.value.U.asTypeOf(new GeneratedI())\n 1509      nop.rd   := 0.U\n 1510      nop.rs1  := 0.U\n ....\n 1512  \n 1513      val isa = Wire(new GeneratedI())\n 1514:     isa := Instructions.ADDIW.value.U.asTypeOf(new GeneratedI())\n 1515      isa.rd   := 0.U\n 1516      isa.rs1  := 0.U\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/DebugTransport.scala:\n  248    //--------------------------------------------------------\n  249    // Actual JTAG TAP\n  250:   val idcode = WireInit(0.U.asTypeOf(new JTAGIdcodeBundle()))\n  251    idcode.always1    := 1.U\n  252    idcode.version    := io.jtag_version\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/Periphery.scala:\n  254        tckHalfPeriod: Int = 2,\n  255        cmdDelay: Int = 2,\n  256:       psd: PSDTestMode = 0.U.asTypeOf(new PSDTestMode()))\n  257        (implicit p: Parameters): Unit =  {\n  258      connectDebugClockAndReset(debugOpt, c)\n  ...\n  309    def tieoffDebug(debugOpt: Option[DebugIO], resetctrlOpt: Option[ResetCtrlIO] = None, psdio: Option[PSDIO] = None)(implicit p: Parameters): Bool = {\n  310  \n  311:     psdio.foreach(_.psd.foreach { _ <> 0.U.asTypeOf(new PSDTestMode()) } )\n  312      resetctrlOpt.map { rcio => rcio.hartIsInReset.map { _ := false.B }}\n  313      debugOpt.map { debug =>\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/SBA.scala:\n   44      val SBCSFieldsReg = Reg(new SBCSFields()).suggestName(\"SBCSFieldsReg\")\n   45  \n   46:     val SBCSFieldsRegReset = WireInit(0.U.asTypeOf(new SBCSFields()))\n   47      SBCSFieldsRegReset.sbversion   := 1.U(1.W) // This code implements a version of the spec after January 1, 2018\n   48      SBCSFieldsRegReset.sbbusy      := (sb2tl.module.io.sbStateOut =/= SystemBusAccessState.Idle.id.U)\n   ..\n   55      SBCSFieldsRegReset.sbaccess8   := (cfg.maxSupportedSBAccess >=   8).B\n   56  \n   57:     val SBCSRdData         = WireInit(0.U.asTypeOf(new SBCSFields())).suggestName(\"SBCSRdData\")\n   58  \n   59      val SBCSWrDataVal      = WireInit(0.U(32.W))\n   60:     val SBCSWrData         = WireInit(SBCSWrDataVal.asTypeOf(new SBCSFields()))\n   61      \n   62      val sberrorWrEn        = WireInit(false.B)\n   ..\n  238      \n  239      when (~dmAuthenticated) {    // Read value must be 0 if not authenticated\n  240:       SBCSRdData := 0.U.asTypeOf(new SBCSFields())\n  241      }\n  242  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/BundleBridge.scala:\n  166  \n  167    def orReduction[T <: Data](registered: Boolean)(seq: Seq[T]): T = {\n  168:     val x = seq.reduce((a,b) => (a.asUInt | b.asUInt).asTypeOf(seq.head))\n  169      if (registered) safeRegNext(x) else x\n  170    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/formal/FormalUtils.scala:\n  227        TernaryIf(case_var.asUInt===select.asUInt, ret_val.asUInt, 0.U)\n  228      })\n  229:     sel_vec.reduce( _ | _).asTypeOf(sel_ret(0)._2)\n  230    }\n  231  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/groundtest/DummyPTW.scala:\n   32    val s2_valid = Reg(next = req_arb.io.out.valid && req_arb.io.out.bits.valid)\n   33  \n   34:   val s2_resp = Wire(init = 0.U.asTypeOf(new PTWResp))\n   35    s2_resp.pte.ppn := s2_ppn\n   36    s2_resp.pte.reserved_for_software := UInt(0)\n   ..\n   48      requestor.resp.valid := s2_valid && s2_chosen === UInt(i)\n   49      requestor.resp.bits := s2_resp\n   50:     requestor.status := 0.U.asTypeOf(requestor.status)\n   51      requestor.ptbr.mode := requestor.ptbr.pgLevelsToMode(pgLevels).U\n   52      requestor.ptbr.asid := UInt(0)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/jtag/JtagShifter.scala:\n  158  \n  159    val updateBits = Cat(regs.reverse)(updateWidth-1, 0)\n  160:   io.update.bits := updateBits.asTypeOf(io.update.bits)\n  161  \n  162    val captureBits = io.capture.bits.asUInt()\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/CSR.scala:\n  255  object VType {\n  256    def fromUInt(that: UInt, ignore_vill: Boolean = false)(implicit p: Parameters): VType = {\n  257:     val res = 0.U.asTypeOf(new VType)\n  258:     val in = that.asTypeOf(res)\n  259      val vill = (in.max_vsew < in.vsew) || !in.lmul_ok || in.reserved =/= 0 || in.vill\n  260      when (!vill || ignore_vill) {\n  ...\n  515      reg_dscratch1.map(r => CSRs.dscratch1 -> r)\n  516  \n  517:   val read_mnstatus = WireInit(0.U.asTypeOf(new MStatus()))\n  518    read_mnstatus.mpp := io.status.mpp\n  519    val nmi_csrs = if (!usingNMI) LinkedHashMap() else LinkedHashMap[Int,Bits](\n  ...\n  584      val read_sie = reg_mie & read_mideleg\n  585      val read_sip = read_mip & read_mideleg\n  586:     val read_sstatus = Wire(init = 0.U.asTypeOf(new MStatus))\n  587      read_sstatus.sd := io.status.sd\n  588      read_sstatus.uxl := io.status.uxl\n  ...\n  615    if (reg_pmp.nonEmpty) {\n  616      require(reg_pmp.size <= CSR.maxPMPs)\n  617:     val read_pmp = reg_pmp.padTo(CSR.maxPMPs, 0.U.asTypeOf(new PMP))\n  618      for (i <- 0 until read_pmp.size by pmpCfgPerCSR)\n  619        read_mapping += (CSRs.pmpcfg0 + pmpCfgIndex(i)) -> read_pmp.map(_.cfg).slice(i, i + pmpCfgPerCSR).asUInt\n  ...\n  938        // io.interrupts.seip.  We don't want the value on the PLIC line to\n  939        // inadvertently be OR'd into read_mip.seip.\n  940:       val new_mip = readModifyWriteCSR(io.rw.cmd, reg_mip.asUInt, io.rw.wdata).asTypeOf(new MIP)\n  941        if (usingSupervisor) {\n  942          reg_mip.ssip := new_mip.ssip\n  ...\n 1053            }\n 1054            when (decoded_addr(CSRs.tdata1)) {\n 1055:             bp.control := wdata.asTypeOf(bp.control)\n 1056  \n 1057              val prevChain = if (i == 0) false.B else reg_bp(i-1).control.chain\n ....\n 1059              val nextChain = if (i >= nBreakpoints-1) true.B else reg_bp(i+1).control.chain\n 1060              val nextDMode = if (i >= nBreakpoints-1) true.B else reg_bp(i+1).control.dmode\n 1061:             val newBPC = readModifyWriteCSR(io.rw.cmd, bp.control.asUInt, io.rw.wdata).asTypeOf(bp.control)\n 1062              val dMode = newBPC.dmode && reg_debug && (prevDMode || !prevChain)\n 1063              bp.control.dmode := dMode\n ....\n 1120      when (reset.asBool) {\n 1121        reg_vconfig.get.vl := 0.U\n 1122:       reg_vconfig.get.vtype := 0.U.asTypeOf(new VType)\n 1123        reg_vconfig.get.vtype.vill := true\n 1124      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/DCache.scala:\n  284        }\n  285        val s1_meta = tag_array.read(metaIdx, metaReq.valid && !metaReq.bits.write)\n  286:       val s1_meta_uncorrected = s1_meta.map(tECC.decode(_).uncorrected.asTypeOf(new L1Metadata))\n  287        val s1_tag = s1_paddr >> tagLSB\n  288        val s1_meta_hit_way = s1_meta_uncorrected.map(r => r.coh.isValid() && r.tag === s1_tag).asUInt\n  ...\n  330    val s2_meta_uncorrectable_errors = s1_meta_decoded.map(m => RegEnable(m.uncorrectable, s1_meta_clk_en)).asUInt\n  331    val s2_meta_error_uncorrectable = s2_meta_uncorrectable_errors.orR\n  332:   val s2_meta_corrected = s1_meta_decoded.map(m => RegEnable(m.corrected, s1_meta_clk_en).asTypeOf(new L1Metadata))\n  333    val s2_meta_error = (s2_meta_uncorrectable_errors | s2_meta_correctable_errors).orR\n  334    val s2_flush_valid = s2_flush_valid_pre_tag_ecc && !s2_meta_error\n  ...\n  899  \n  900    val s1_xcpt_valid = tlb.io.req.valid && !s1_isSlavePortAccess && !s1_nack\n  901:   io.cpu.s2_xcpt := Mux(RegNext(s1_xcpt_valid), s2_tlb_xcpt, 0.U.asTypeOf(s2_tlb_xcpt))\n  902  \n  903    if (usingDataScratchpad) {\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/IBuf.scala:\n   94        io.inst(i).valid := valid(j) && full_insn\n   95        io.inst(i).bits.xcpt0 := xcpt(j)\n   96:       io.inst(i).bits.xcpt1 := Mux(exp.io.rvc, 0.U, xcpt(j+1).asUInt).asTypeOf(new FrontendExceptions)\n   97        io.inst(i).bits.replay := replay\n   98        io.inst(i).bits.rvc := exp.io.rvc\n   ..\n  107        io.inst(i).valid := valid(i)\n  108        io.inst(i).bits.xcpt0 := xcpt(i)\n  109:       io.inst(i).bits.xcpt1 := 0.U.asTypeOf(new FrontendExceptions)\n  110        io.inst(i).bits.replay := ic_replay(i)\n  111        io.inst(i).bits.rvc := false\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/ICache.scala:\n  304  \n  305    val s1_clk_en = s1_valid || s1_slaveValid\n  306:   val s2_tag_hit = RegEnable(Mux(s1_dont_read, 0.U.asTypeOf(s1_tag_hit), s1_tag_hit), s1_clk_en)\n  307    val s2_hit_way = OHToUInt(s2_tag_hit)\n  308    val s2_scratchpad_word_addr = Cat(s2_hit_way, Mux(s2_slaveValid, s1s3_slaveAddr, io.s2_vaddr)(untagBits-1, log2Ceil(wordBits/8)), UInt(0, log2Ceil(wordBits/8)))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/NBDcache.scala:\n 1003    val s1_xcpt_valid = dtlb.io.req.valid && !s1_nack\n 1004    val s1_xcpt = dtlb.io.resp\n 1005:   io.cpu.s2_xcpt := Mux(RegNext(s1_xcpt_valid), RegEnable(s1_xcpt, s1_clk_en), 0.U.asTypeOf(s1_xcpt))\n 1006    io.cpu.s2_uncached := false.B\n 1007    io.cpu.s2_paddr := s2_req.addr\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/PMP.scala:\n  137  class PMPHomogeneityChecker(pmps: Seq[PMP])(implicit p: Parameters) {\n  138    def apply(addr: UInt, pgLevel: UInt): Bool = {\n  139:     pmps.foldLeft((true.B, 0.U.asTypeOf(new PMP))) { case ((h, prev), pmp) =>\n  140        (h && pmp.homogeneous(addr, pgLevel, prev), pmp)\n  141      }._1\n  ...\n  156  \n  157    val default = if (io.pmp.isEmpty) true.B else io.prv > PRV.S\n  158:   val pmp0 = WireInit(0.U.asTypeOf(new PMP))\n  159    pmp0.cfg.r := default\n  160    pmp0.cfg.w := default\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/PTW.scala:\n  263      when (s2_valid && s2_error) { valid.foreach { _ := 0.U }}\n  264  \n  265:     val s2_entry_vec = s2_rdata.map(_.uncorrected.asTypeOf(new L2TLBEntry(nL2TLBSets)))\n  266      val s2_hit_vec = (0 until coreParams.nL2TLBWays).map(way => s2_valid_vec(way) && (r_tag === s2_entry_vec(way).tag))\n  267      val s2_hit = s2_valid && s2_hit_vec.orR\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/TLB.scala:\n   81    val data = Vec(nSectors, UInt(width = new TLBEntryData().getWidth))\n   82    val valid = Vec(nSectors, Bool())\n   83:   def entry_data = data.map(_.asTypeOf(new TLBEntryData))\n   84  \n   85    private def sectorIdx(vpn: UInt) = vpn.extract(nSectors.log2-1, 0)\n   86:   def getData(vpn: UInt) = OptimizationBarrier(data(sectorIdx(vpn)).asTypeOf(new TLBEntryData))\n   87    def sectorHit(vpn: UInt) = valid.orR && sectorTagMatch(vpn)\n   88    def sectorTagMatch(vpn: UInt) = ((tag ^ vpn) >> nSectors.log2) === 0\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/FPU.scala:\n  289    }\n  290  \n  291:   def unpackIEEE(x: UInt) = x.asTypeOf(ieeeBundle)\n  292  \n  293    def recode(x: UInt) = hardfloat.recFNFromFN(exp, sig, x)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/LanePositionedQueue.scala:\n  455      Mux(!isPow2(rows).B && deq_row_half === (rows/2-2).U, 0.U,\n  456      deq_row_half + 2.U))))))\n  457:   val ram_o = ecc.decode(ram.read(read_row, ren)).corrected.asTypeOf(Vec(2*lanes, gen))\n  458    when (wen && !ren) { ram.write(write_row, ecc.encode(ram_i.asUInt)) }\n  459  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/MultiPortQueue.scala:\n   34      val highHoles = sparse.map(x => WireInit(UInt(popBits.W), !x.valid))\n   35      val enq_dense = Gather(\n   36:       Seq.fill(dense.lanes) { 0.U.asTypeOf(chiselTypeOf(sparse.head.bits)) } ++ sparse.map(_.bits),\n   37        Seq.fill(dense.lanes) { lowHoles } ++ DensePrefixSum(lowHoles +: highHoles)(_ + _).tail)\n   38  \n   ..\n   57  \n   58      // Scatter data from rotated lanes to deq ports\n   59:     val bits = dense.bits ++ dense.bits ++ Seq.fill(sparse.size) { 0.U.asTypeOf(chiselTypeOf(sparse.head.bits)) }\n   60      val popBits = log2Ceil(dense.lanes + sparse.size)\n   61      val lowHoles = dense.lanes.U(popBits.W) - offset\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ShiftReg.scala:\n   46      name.foreach{ chain.suggestName(_) }\n   47      chain.io.d := in.asUInt\n   48:     chain.io.q.asTypeOf(in)\n   49    }\n   50  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/SynchronizerReg.scala:\n  209      cdc_reg.io.d := in.asUInt\n  210      cdc_reg.io.en := en\n  211:     cdc_reg.io.q.asTypeOf(in)\n  212    }\n  213  }\n\n77 matches across 22 files\n\n\nSearching 386 files for \"Valid\" (whole word)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/ahb/RegisterRouter.scala:\n   41      // Only send the request to the RR once\n   42      d_taken := d_phase && in.ready\n   43:     in.valid := d_phase && !d_taken\n   44  \n   45      in.bits.read  := d_read\n   ..\n   49  \n   50      when (ahb.hready) { d_phase := Bool(false) }\n   51:     ahb.hreadyout := !d_phase || out.valid\n   52      ahb.hresp     := AHBParameters.RESP_OKAY\n   53      ahb.hrdata    := out.bits.data\n   ..\n   55      val request = ahb.htrans === AHBParameters.TRANS_NONSEQ || ahb.htrans === AHBParameters.TRANS_SEQ\n   56      when (ahb.hready && ahb.hsel && request) {\n   57:       assert (!in.valid || in.ready)\n   58        d_phase := Bool(true)\n   59        d_taken := Bool(false)\n   ..\n   64  \n   65      out.ready := Bool(true)\n   66:     assert (d_phase || !out.valid)\n   67    }\n   68  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/ahb/ToTL.scala:\n   69        val d_user  = Reg(BundleMap(edgeOut.bundle.requestFields))\n   70  \n   71:       when (out.d.valid) { d_recv  := Bool(false) }\n   72        when (out.a.ready) { d_send  := Bool(false) }\n   73        when (in.hresp(0)) { d_pause := Bool(false) }\n   ..\n  124        }\n  125  \n  126:       out.a.valid        := d_send\n  127        out.a.bits.opcode  := Mux(d_write, TLMessages.PutFullData, TLMessages.Get)\n  128        out.a.bits.param   := UInt(0)\n  ...\n  141        // the failure might be legally retracted on the second cycle.\n  142        // Although the AHB spec says:\n  143:       //   \"A slave only has to provide valid data when a transfer completes with\n  144:       //    an OKAY response. ERROR responses do not require valid read data.\"\n  145        // We choose, nevertheless, to provide the read data for the failed request.\n  146        // Unfortunately, this comes at the cost of a bus-wide register.\n  ...\n  154  \n  155        // In a perfect world, we'd use these signals\n  156:       val hresp = d_fail || (out.d.valid && (out.d.bits.denied || out.d.bits.corrupt))\n  157:       val hreadyout = Mux(d_write, (!d_send || out.a.ready) && (!d_last || !d_recv || out.d.valid), out.d.valid || !d_recv)\n  158  \n  159        // Make the failure persistent (and defer it to the last beat--otherwise AHB can cancel the burst!)\n  ...\n  168        // Unused channels\n  169        out.b.ready := Bool(true)\n  170:       out.c.valid := Bool(false)\n  171:       out.e.valid := Bool(false)\n  172      }\n  173    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/apb/RegisterRouter.scala:\n   40      in.bits.mask  := Mux(apb.pwrite, apb.pstrb, UInt((1<<beatBytes) - 1))\n   41  \n   42:     in.valid := apb.psel && !taken\n   43      out.ready := apb.penable\n   44  \n   45:     apb.pready  := out.valid\n   46      apb.pslverr := Bool(false)\n   47      apb.prdata  := out.bits.data\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/apb/ToTL.scala:\n   47        // on the same cycle that we send the transaction. Require and verify.\n   48        require (edgeOut.manager.minLatency >= 1)\n   49:       assert (!(in.psel && !in.penable && out.d.valid))\n   50  \n   51  \n   ..\n   68        val in_flight = in_flight_reg || error_in_flight_reg\n   69  \n   70:       out.a.valid := in.psel && !in_flight && a_legal\n   71:       in.pready := out.d.valid  || error_in_flight_reg\n   72        out.d.ready := true.B\n   73  \n   ..\n  113        // Unused channels\n  114        out.b.ready := Bool(true)\n  115:       out.c.valid := Bool(false)\n  116:       out.e.valid := Bool(false)\n  117      }\n  118    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Bundles.scala:\n   83          aw.ready := Bool(false)\n   84          w.ready  := Bool(false)\n   85:         r.valid  := Bool(false)\n   86          r.bits   := DontCare\n   87:         b.valid  := Bool(false)\n   88          b.bits   := DontCare\n   89        case OUTPUT =>\n   90:         ar.valid := Bool(false)\n   91          ar.bits  := DontCare\n   92:         aw.valid := Bool(false)\n   93          aw.bits  := DontCare\n   94:         w.valid  := Bool(false)\n   95          w.bits   := DontCare\n   96          r.ready  := Bool(false)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Deinterleaver.scala:\n   73              val q = Wire(new QueueIO(out.r.bits.cloneType, beats))\n   74              q.suggestName(s\"queue_wire_${i}\")\n   75:             assert(!q.enq.valid, s\"ID ${i} should not be used\")\n   76              q := DontCare\n   77              q\n   ..\n  111  \n  112          // Transmit the selected burst to inner\n  113:         in.r.valid := locked\n  114          val deq_bits = VecInit(qs.map(_.deq.bits))\n  115          in.r.bits  := deq_bits(deq_id)\n  ...\n  126          out.r.ready := enq_readys(enq_id)\n  127          (enq_OH_bools zip qs) foreach { case (s, q) =>\n  128:           q.enq.valid := s && out.r.valid\n  129            q.enq.bits := out.r.bits\n  130          }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Delayer.scala:\n   17    lazy val module = new LazyModuleImp(this) {\n   18      def feed[T <: Data](sink: IrrevocableIO[T], source: IrrevocableIO[T], noise: T): Unit = {\n   19:       // irrevocable requires that we not lower valid\n   20        val hold = RegInit(Bool(false))\n   21:       when (sink.valid)  { hold := Bool(true) }\n   22        when (sink.fire()) { hold := Bool(false) }\n   23  \n   24:       val allow = hold || UInt((q * 65535.0).toInt) <= LFSRNoiseMaker(16, source.valid)\n   25:       sink.valid := source.valid && allow\n   26        source.ready := sink.ready && allow\n   27        sink.bits := source.bits\n   28:       when (!sink.valid) { sink.bits := noise }\n   29      }\n   30  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Fragmenter.scala:\n   49         * On W we set 'last' on beats which are fragment boundaries\n   50         * On R we clear 'last' on the fragments being reassembled\n   51:        * On B we clear 'valid' on the responses for the injected fragments\n   52         *\n   53         * AR=>R and AW+W=>B are completely independent state machines.\n   ..\n  110          val last = beats1 === len\n  111          a.ready := out.ready && last\n  112:         out.valid := a.valid\n  113  \n  114          out.bits :<= a.bits\n  ...\n  139        val (in_aw, aw_last, w_beats) = fragment(Queue.irrevocable(in.aw, 1, flow=true), writeSizes1)\n  140  \n  141:       // AXI ready may not depend on valid of other channels\n  142        // We cut wready here along with awready and arready before AXI4ToTL\n  143        val in_w = Queue.irrevocable(in.w, 1, flow=true)\n  ...\n  155  \n  156        // AW flow control\n  157:       out.aw.valid := in_aw.valid && (wbeats_ready || wbeats_latched)\n  158        in_aw.ready := out.aw.ready && (wbeats_ready || wbeats_latched)\n  159:       wbeats_valid := in_aw.valid && !wbeats_latched\n  160        out.aw.bits :<>: in_aw.bits\n  161        out.aw.bits.echo(AXI4FragLast) := aw_last\n  ...\n  171        // W flow control\n  172        wbeats_ready := w_idle\n  173:       out.w.valid := in_w.valid && (!wbeats_ready || wbeats_valid)\n  174        in_w.ready := out.w.ready && (!wbeats_ready || wbeats_valid)\n  175        out.w.bits :<= in_w.bits\n  176        out.w.bits.last := w_last\n  177        // We should also recreate the last last\n  178:       assert (!out.w.valid || !in_w.bits.last || w_last)\n  179  \n  180        // R flow control\n  ...\n  186        val b_last = out.b.bits.echo(AXI4FragLast)\n  187        in.b :<> out.b\n  188:       in.b.valid := out.b.valid && b_last\n  189        out.b.ready := in.b.ready || !b_last\n  190  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/RegisterRouter.scala:\n   43  \n   44      // Prefer to execute reads first\n   45:     in.valid := ar.valid || (aw.valid && w.valid)\n   46      ar.ready := in.ready\n   47:     aw.ready := in.ready && !ar.valid && w .valid\n   48:     w .ready := in.ready && !ar.valid && aw.valid\n   49  \n   50      ar_extra :<= ar.bits.echo\n   ..\n   52      ar_extra(AXI4RRId) := ar.bits.id\n   53      aw_extra(AXI4RRId) := aw.bits.id\n   54:     val addr = Mux(ar.valid, ar.bits.addr, aw.bits.addr)\n   55      val mask = MaskGen(ar.bits.addr, ar.bits.size, beatBytes)\n   56  \n   57:     in.bits.read  := ar.valid\n   58      in.bits.index := addr >> log2Ceil(beatBytes)\n   59      in.bits.data  := w.bits.data\n   60:     in.bits.mask  := Mux(ar.valid, mask, w.bits.strb)\n   61:     in.bits.extra := Mux(ar.valid, ar_extra, aw_extra)\n   62  \n   63      // Invoke the register map builder and make it Irrevocable\n   ..\n   68      // No flow control needed\n   69      out.ready := Mux(out.bits.read, r.ready, b.ready)\n   70:     r.valid := out.valid &&  out.bits.read\n   71:     b.valid := out.valid && !out.bits.read\n   72  \n   73      r.bits.id   := out.bits.extra(AXI4RRId)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/SRAM.scala:\n   89      }\n   90  \n   91:     in. b.valid := w_full\n   92:     in.aw.ready := in. w.valid && (in.b.ready || !w_full)\n   93:     in. w.ready := in.aw.valid && (in.b.ready || !w_full)\n   94  \n   95      in.b.bits.id   := w_id\n   ..\n  114      val rcorrupt = corrupt.map(_.readAndHold(r_addr, ren)(0)).getOrElse(Bool(false))\n  115  \n  116:     in. r.valid := r_full\n  117      in.ar.ready := in.r.ready || !r_full\n  118  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/ToTL.scala:\n   96        }\n   97  \n   98:       assert (!in.ar.valid || r_size1 === UIntToOH1(r_size, beatCountBits)) // because aligned\n   99        in.ar.ready := r_out.ready\n  100:       r_out.valid := in.ar.valid\n  101        r_out.bits :<= edgeOut.Get(r_id, r_addr, r_size)._2\n  102  \n  ...\n  129        }\n  130  \n  131:       assert (!in.aw.valid || w_size1 === UIntToOH1(w_size, beatCountBits)) // because aligned\n  132:       assert (!in.aw.valid || in.aw.bits.len === UInt(0) || in.aw.bits.size === UInt(log2Ceil(beatBytes))) // because aligned\n  133:       in.aw.ready := w_out.ready && in.w.valid && in.w.bits.last\n  134:       in.w.ready  := w_out.ready && in.aw.valid\n  135:       w_out.valid := in.aw.valid && in.w.valid\n  136        w_out.bits :<= edgeOut.Put(w_id, w_addr, w_size, in.w.bits.data, in.w.bits.strb)._2\n  137        in.w.bits.user.lift(AMBACorrupt).foreach { w_out.bits.corrupt := _ }\n  ...\n  163  \n  164        out.d.ready := Mux(d_hasData, ok_r.ready, ok_b.ready)\n  165:       ok_r.valid := out.d.valid && d_hasData\n  166:       ok_b.valid := out.d.valid && !d_hasData\n  167  \n  168        ok_r.bits.id   := out.d.bits.source >> addedBits\n  ...\n  182        val q_b = Queue.irrevocable(ok_b, 1, flow=true)\n  183  \n  184:       // We need to prevent sending B valid before the last W beat is accepted\n  185        // TileLink allows early acknowledgement of a write burst, but AXI does not.\n  186        val b_count = RegInit(Vec.fill(numIds) { UInt(0, width = txnCountBits) })\n  ...\n  193  \n  194        in.b.bits :<= q_b.bits\n  195:       in.b.valid := q_b.valid && b_allow\n  196        q_b.ready := in.b.ready && b_allow\n  197  \n  198        // Unused channels\n  199        out.b.ready := Bool(true)\n  200:       out.c.valid := Bool(false)\n  201:       out.e.valid := Bool(false)\n  202      }\n  203    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/UserYanker.scala:\n   55        val ar_ready = Vec(rqueues.map(_.enq.ready))(arid)\n   56        in .ar.ready := out.ar.ready && ar_ready\n   57:       out.ar.valid := in .ar.valid && ar_ready\n   58        out.ar.bits :<= in .ar.bits\n   59  \n   60        val rid = out.r.bits.id\n   61:       val r_valid = Vec(rqueues.map(_.deq.valid))(rid)\n   62        val r_bits = Vec(rqueues.map(_.deq.bits))(rid)\n   63:       assert (!out.r.valid || r_valid) // Q must be ready faster than the response\n   64        in.r :<> out.r\n   65        in.r.bits.echo :<= r_bits\n   ..\n   68        val rsel  = UIntToOH(rid,  edgeIn.master.endId).asBools\n   69        (rqueues zip (arsel zip rsel)) foreach { case (q, (ar, r)) =>\n   70:         q.deq.ready := out.r .valid && in .r .ready && r && out.r.bits.last\n   71:         q.enq.valid := in .ar.valid && out.ar.ready && ar\n   72          q.enq.bits :<= in.ar.bits.echo\n   73        }\n   ..\n   76        val aw_ready = Vec(wqueues.map(_.enq.ready))(awid)\n   77        in .aw.ready := out.aw.ready && aw_ready\n   78:       out.aw.valid := in .aw.valid && aw_ready\n   79        out.aw.bits :<= in .aw.bits\n   80  \n   81        val bid = out.b.bits.id\n   82:       val b_valid = Vec(wqueues.map(_.deq.valid))(bid)\n   83        val b_bits = Vec(wqueues.map(_.deq.bits))(bid)\n   84:       assert (!out.b.valid || b_valid) // Q must be ready faster than the response\n   85        in.b :<> out.b\n   86        in.b.bits.echo :<= b_bits\n   ..\n   89        val bsel  = UIntToOH(bid,  edgeIn.master.endId).asBools\n   90        (wqueues zip (awsel zip bsel)) foreach { case (q, (aw, b)) =>\n   91:         q.deq.ready := out.b .valid && in .b .ready && b\n   92:         q.enq.valid := in .aw.valid && out.aw.ready && aw\n   93          q.enq.bits :<= in.aw.bits.echo\n   94        }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Xbar.scala:\n  134  \n  135          val allowAR = arFIFOMap(io_in(i).ar.bits.id)\n  136:         in(i).ar.valid := io_in(i).ar.valid && allowAR\n  137          io_in(i).ar.ready := in(i).ar.ready && allowAR\n  138  \n  ...\n  142          // Block AW if we cannot record the W destination\n  143          val allowAW = awFIFOMap(io_in(i).aw.bits.id)\n  144:         val latched = RegInit(Bool(false)) // cut awIn(i).enq.valid from awready\n  145:         in(i).aw.valid := io_in(i).aw.valid && (latched || awIn(i).io.enq.ready) && allowAW\n  146          io_in(i).aw.ready := in(i).aw.ready && (latched || awIn(i).io.enq.ready) && allowAW\n  147:         awIn(i).io.enq.valid := io_in(i).aw.valid && !latched\n  148          when (awIn(i).io.enq.fire()) { latched := Bool(true) }\n  149          when (in(i).aw.fire()) { latched := Bool(false) }\n  150  \n  151          // Block W if we do not have an AW destination\n  152:         in(i).w.valid := io_in(i).w.valid && awIn(i).io.deq.valid // depends on awvalid (but not awready)\n  153:         io_in(i).w.ready := in(i).w.ready && awIn(i).io.deq.valid\n  154:         awIn(i).io.deq.ready := io_in(i).w.valid && io_in(i).w.bits.last && in(i).w.ready\n  155        }\n  156      }\n  ...\n  163        if (io_in.size > 1) {\n  164          // Block AW if we cannot record the W source\n  165:         val latched = RegInit(Bool(false)) // cut awOut(i).enq.valid from awready\n  166:         io_out(i).aw.valid := out(i).aw.valid && (latched || awOut(i).io.enq.ready)\n  167          out(i).aw.ready := io_out(i).aw.ready && (latched || awOut(i).io.enq.ready)\n  168:         awOut(i).io.enq.valid := out(i).aw.valid && !latched\n  169          when (awOut(i).io.enq.fire()) { latched := Bool(true) }\n  170          when (out(i).aw.fire()) { latched := Bool(false) }\n  171  \n  172          // Block W if we do not have an AW source\n  173:         io_out(i).w.valid := out(i).w.valid && awOut(i).io.deq.valid // depends on awvalid (but not awready)\n  174:         out(i).w.ready := io_out(i).w.ready && awOut(i).io.deq.valid\n  175:         awOut(i).io.deq.ready := out(i).w.valid && out(i).w.bits.last && io_out(i).w.ready\n  176        }\n  177      }\n  ...\n  191        AXI4Arbiter(arbitrationPolicy)(out(o).ar, portsAROI(o):_*)\n  192        // W arbitration is informed by the Q, not policy\n  193:       out(o).w.valid := Mux1H(awOut(o).io.deq.bits, portsWOI(o).map(_.valid))\n  194        out(o).w.bits :<= Mux1H(awOut(o).io.deq.bits, portsWOI(o).map(_.bits))\n  195        portsWOI(o).zipWithIndex.map { case (p, i) =>\n  ...\n  227      for (i <- 0 until select.size) {\n  228        filtered(i).bits :<= input.bits\n  229:       filtered(i).valid := input.valid && select(i)\n  230      }\n  231      input.ready := Mux1H(select, filtered.map(_.ready))\n  ...\n  238    def apply[T <: Data](policy: TLArbiter.Policy)(sink: IrrevocableIO[T], sources: IrrevocableIO[T]*): Unit = {\n  239      if (sources.isEmpty) {\n  240:       sink.valid := Bool(false)\n  241      } else {\n  242        returnWinner(policy)(sink, sources:_*)\n  ...\n  250  \n  251      // Who wants access to the sink?\n  252:     val valids = sources.map(_.valid)\n  253      val anyValid = valids.reduce(_ || _)\n  254      // Arbitrate amongst the requests\n  ...\n  283      }\n  284  \n  285:     sink.valid := Mux(idle, anyValid, Mux1H(state, valids))\n  286      sink.bits :<= Mux1H(muxState, sources.map(_.bits))\n  287      muxState\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axis/Xbar.scala:\n   75    def arbitrate(policy: TLArbiter.Policy)(sink: AXISBundle, sources: Seq[AXISBundle]): Unit = {\n   76      if (sources.isEmpty) {\n   77:       sink.valid := false.B\n   78      } else if (sources.size == 1) {\n   79        sink :<> sources.head\n   ..\n   81        // The number of beats which remain to be sent\n   82        val idle = RegInit(true.B)\n   83:       when (sink.valid) { idle := sink.bits.last && sink.ready }\n   84  \n   85        // Who wants access to the sink?\n   86:       val valids = sources.map(_.valid)\n   87        // Arbitrate amongst the requests\n   88        val readys = VecInit(policy(valids.size, Cat(valids.reverse), idle).asBools)\n   ..\n  105        val allowed = Mux(idle, readys, state)\n  106        (sources zip allowed) foreach { case (s, r) => s.ready := sink.ready && r }\n  107:       sink.valid := Mux(idle, valids.reduce(_||_), Mux1H(state, valids))\n  108        sink.bits :<= Mux1H(muxState, sources.map(_.bits))\n  109      }\n  ...\n  114      for (i <- 0 until select.size) {\n  115        filtered(i).bits :<= input.bits\n  116:       filtered(i).valid := input.valid && (select(i) || (select.size == 1).B)\n  117      }\n  118      input.ready := Mux1H(select, filtered.map(_.ready))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala:\n   49      val tail = RegInit(0.U(32.W))\n   50  \n   51:     val s1 = RegInit(0.U.asTypeOf(new chisel3.Valid(in.a.bits.cloneType)));chisel3.dontTouch(s1)\n   52      s1.bits := in.a.bits\n   53  \n   ..\n   58      }\n   59  \n   60:     //by dongdeji in. b.valid := w_full\n   61:     //by dongdeji in.a.ready := in. w.valid && (in.b.ready || !w_full)\n   62:     //by dongdeji in. w.ready := in.aw.valid && (in.b.ready || !w_full)\n   63  \n   64      //in.b.bits.id   := w_id\n   ..\n   83      //by dongdeji val rcorrupt = corrupt.map(_.readAndHold(r_addr, ren)(0)).getOrElse(Bool(false))\n   84  \n   85:     //by dongdeji in. r.valid := r_full\n   86      //by dongdeji in.ar.ready := in.r.ready || !r_full\n   87  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/ToCustom.scala:\n  145        //by dongdeji out.ar.bits := queue_arw.bits\n  146        out.a.bits := queue_arw.bits\n  147:       //by dongdeji out.ar.valid := queue_arw.valid && !queue_arw.bits.wen\n  148:       out.a.valid := queue_arw.valid //by dongdeji &&  queue_arw.bits.wen\n  149        //by dongdeji queue_arw.ready := Mux(queue_arw.bits.wen, out.aw.ready, out.ar.ready)\n  150        queue_arw.ready := out.a.ready\n  ...\n  188        val stall = sourceStall(in.a.bits.source) && a_first\n  189        in.a.ready := !stall && Mux(a_isPut, (doneAW || out_arw.ready)/* && out_w.ready*/, out_arw.ready)\n  190:       out_arw.valid := !stall && in.a.valid && Mux(a_isPut, !doneAW/* && out_w.ready*/, Bool(true))\n  191  \n  192:       //by dongdeji out_w.valid := !stall && in.a.valid && a_isPut && (doneAW || out_arw.ready)\n  193        //by dongdeji out_w.bits.data := in.a.bits.data\n  194        //by dongdeji out_w.bits.strb := in.a.bits.mask\n  ...\n  201        // Give R higher priority than B, unless B has been delayed for 8 cycles\n  202        val b_delay = Reg(UInt(width=3))\n  203:       when (out.b.valid && !out.b.ready) {\n  204          b_delay := b_delay + UInt(1)\n  205        } .otherwise {\n  206          b_delay := UInt(0)\n  207        }\n  208:       //by dongdeji val r_wins = (out.r.valid && b_delay =/= UInt(7)) || r_holds_d\n  209  \n  210        //by dongdeji out.r.ready := in.d.ready && r_wins\n  211        out.b.ready := in.d.ready //by dongdeji && !r_wins\n  212:       //by dongdeji in.d.valid := Mux(r_wins, out.r.valid, out.b.valid)\n  213  \n  214        // If the first beat of the AXI RRESP is RESP_DECERR, treat this as a denied\n  ...\n  264  \n  265        // Tie off unused channels\n  266:       in.b.valid := Bool(false)\n  267        in.c.ready := Bool(true)\n  268        in.e.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Xbar.scala:\n  129  \n  130          //by dongdeji val allowAR = arFIFOMap(io_in(i).ar.bits.id)\n  131:         //by dongdeji in(i).ar.valid := io_in(i).ar.valid && allowAR\n  132          //by dongdeji io_in(i).ar.ready := in(i).ar.ready && allowAR\n  133  \n  ...\n  137          // Block AW if we cannot record the W destination\n  138          val allowAW = awFIFOMap(io_in(i).a.bits.id)\n  139:         val latched = RegInit(Bool(false)) // cut awIn(i).enq.valid from awready\n  140:         in(i).a.valid := io_in(i).a.valid && (latched || awIn(i).io.enq.ready) && allowAW\n  141          io_in(i).a.ready := in(i).a.ready && (latched || awIn(i).io.enq.ready) && allowAW\n  142:         awIn(i).io.enq.valid := io_in(i).a.valid && !latched\n  143          when (awIn(i).io.enq.fire()) { latched := Bool(true) }\n  144          when (in(i).a.fire()) { latched := Bool(false) }\n  145  \n  146          // Block W if we do not have an AW destination\n  147:         //by dongdeji in(i).w.valid := io_in(i).w.valid && awIn(i).io.deq.valid // depends on awvalid (but not awready)\n  148:         //by dongdeji io_in(i).w.ready := in(i).w.ready && awIn(i).io.deq.valid\n  149:         //by dongdeji awIn(i).io.deq.ready := io_in(i).w.valid && io_in(i).w.bits.last && in(i).w.ready\n  150        }\n  151      }\n  ...\n  158        if (io_in.size > 1) {\n  159          // Block AW if we cannot record the W source\n  160:         val latched = RegInit(Bool(false)) // cut awOut(i).enq.valid from awready\n  161:         io_out(i).a.valid := out(i).a.valid && (latched || awOut(i).io.enq.ready)\n  162          out(i).a.ready := io_out(i).a.ready && (latched || awOut(i).io.enq.ready)\n  163:         awOut(i).io.enq.valid := out(i).a.valid && !latched\n  164          when (awOut(i).io.enq.fire()) { latched := Bool(true) }\n  165          when (out(i).a.fire()) { latched := Bool(false) }\n  166  \n  167          // Block W if we do not have an AW source\n  168:         //by dongdeji io_out(i).w.valid := out(i).w.valid && awOut(i).io.deq.valid // depends on awvalid (but not awready)\n  169:         //by dongdeji out(i).w.ready := io_out(i).w.ready && awOut(i).io.deq.valid\n  170:         //by dongdeji awOut(i).io.deq.ready := out(i).w.valid && out(i).w.bits.last && io_out(i).w.ready\n  171        }\n  172      }\n  ...\n  186        //by dongdeji CustomArbiter(arbitrationPolicy)(out(o).ar, portsAROI(o):_*)\n  187        // W arbitration is informed by the Q, not policy\n  188:       //by dongdeji out(o).w.valid := Mux1H(awOut(o).io.deq.bits, portsWOI(o).map(_.valid))\n  189        //by dongdeji out(o).w.bits :<= Mux1H(awOut(o).io.deq.bits, portsWOI(o).map(_.bits))\n  190        //by dongdeji portsWOI(o).zipWithIndex.map { case (p, i) =>\n  ...\n  222      for (i <- 0 until select.size) {\n  223        filtered(i).bits :<= input.bits\n  224:       filtered(i).valid := input.valid && select(i)\n  225      }\n  226      input.ready := Mux1H(select, filtered.map(_.ready))\n  ...\n  233    def apply[T <: Data](policy: TLArbiter.Policy)(sink: IrrevocableIO[T], sources: IrrevocableIO[T]*): Unit = {\n  234      if (sources.isEmpty) {\n  235:       sink.valid := Bool(false)\n  236      } else {\n  237        returnWinner(policy)(sink, sources:_*)\n  ...\n  245  \n  246      // Who wants access to the sink?\n  247:     val valids = sources.map(_.valid)\n  248      val anyValid = valids.reduce(_ || _)\n  249      // Arbitrate amongst the requests\n  ...\n  278      }\n  279  \n  280:     sink.valid := Mux(idle, anyValid, Mux1H(state, valids))\n  281      sink.bits :<= Mux1H(muxState, sources.map(_.bits))\n  282      muxState\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/abstract_commands.scala:\n   44  \n   45              This bit can be used to just execute the Program Buffer without\n   46:             having to worry about placing valid values into \\Fsize or \\Fregno.\n   47    */\n   48    val transfer = Bool()\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/Custom.scala:\n   23    val data = Output(UInt(p.width.W))\n   24    val ready = Output(Bool())\n   25:   val valid = Input(Bool())\n   26  }\n   27  \n   ..\n   77      sources.zipWithIndex.foreach { case (source, i) =>\n   78        source.addr := sink.addr\n   79:       // decode the 'valid' signal based on address\n   80:       source.valid := sink.valid & decoded(i)\n   81      }\n   82      // mux correct 'ready' and 'data' based on address\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/Debug.scala:\n  247  object WNotifyWire {\n  248    def apply(n: Int, value: UInt, set: Bool, name: String, desc: String) : RegField = {\n  249:     RegField(n, 0.U, RegWriteFn((valid, data) => {\n  250:       set := valid\n  251        value := data\n  252        true.B\n  ...\n  261        RegField(n,\n  262          RegReadFn ((ready)       => {rNotify := ready ; (true.B, rVal)}),\n  263:         RegWriteFn((valid, data) => {\n  264:           wNotify := valid\n  265:           when (valid) {wVal := data}\n  266            true.B\n  267          }\n  ...\n  274  object WNotifyVal {\n  275    def apply(n: Int, rVal: UInt, wVal: UInt, wNotify: Bool, desc: RegFieldDesc): RegField = {\n  276:     RegField(n, rVal, RegWriteFn((valid, data) => {\n  277:       wNotify := valid\n  278        wVal := data\n  279        true.B\n  ...\n  588         (HAWINDOWWrEn & supportHartArray.B)\n  589  \n  590:     innerCtrlValidReg        := io.innerCtrl.valid & ~io.innerCtrl.ready             // Hold innerctrl request until the async queue accepts it\n  591      innerCtrlResumeReqReg    := io.innerCtrl.bits.resumereq & ~io.innerCtrl.ready    // Hold resumereq until accepted\n  592      innerCtrlAckHaveResetReg := io.innerCtrl.bits.ackhavereset & ~io.innerCtrl.ready // Hold ackhavereset until accepted\n  593  \n  594:     io.innerCtrl.valid             := innerCtrlValid | innerCtrlValidReg\n  595      io.innerCtrl.bits.hartsel      := Mux(hartselloWrEn, DMCONTROLWrData.hartsello, DMCONTROLReg.hartsello)\n  596      io.innerCtrl.bits.resumereq    := (resumereqWrEn & DMCONTROLWrData.resumereq) | innerCtrlResumeReqReg\n  ...\n 1360        val custom_data = custom.data.asBools\n 1361        val custom_bytes =  Seq.tabulate(customP.width/8){i => custom_data.slice(i*8, (i+1)*8).asUInt}\n 1362:       when (custom.ready && custom.valid) {\n 1363          (abstractDataMem zip custom_bytes).zipWithIndex.foreach {case ((a, b), i) =>\n 1364            a := b\n ....\n 1555        val (custom, customP) = customNode.in.head\n 1556        custom.addr  := accessRegisterCommandReg.regno\n 1557:       custom.valid := goCustom\n 1558      }\n 1559      //--------------------------------------------------------------\n ....\n 1717        goCustom := true.B\n 1718        val (custom, customP) = customNode.in.head\n 1719:       when (custom.ready && custom.valid) {\n 1720          ctrlStateNxt := CtrlState(Waiting)\n 1721        }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/DebugTransport.scala:\n  143    // We stop being busy when we accept a response.\n  144  \n  145:   when (io.dmi.req.valid) {\n  146      busyReg := true.B\n  147    }\n  ...\n  151  \n  152    // We are busy during a given CAPTURE\n  153:   // if we haven't received a valid response yet or if we\n  154    // were busy last time without a reset.\n  155    // busyReg will still be set when we check it,\n  156    // so the logic for checking busy looks ahead.\n  157:   busy := (busyReg & !io.dmi.resp.valid) | stickyBusyReg;\n  158  \n  159    // Downgrade/Skip. We make the decision to downgrade or skip\n  160    // during every CAPTURE_DR, and use the result in UPDATE_DR.\n  161    // The sticky versions are reset by write to dmiReset in DTM_INFO.\n  162:   when (dmiAccessChain.io.update.valid) {\n  163      downgradeOpReg := false.B\n  164    }\n  ...\n  168      stickyNonzeroRespReg := nonzeroResp\n  169    }\n  170:   when (dtmInfoChain.io.update.valid) {\n  171      when (dtmInfoChain.io.update.bits.dmireset) {\n  172        stickyNonzeroRespReg := false.B\n  ...\n  175    }\n  176  \n  177:   // Especially for the first request, we must consider dtmResp.valid,\n  178    // so that we don't consider junk in the FIFO to be an error response.\n  179    // The current specification says that any non-zero response is an error.\n  180:   nonzeroResp := stickyNonzeroRespReg | (io.dmi.resp.valid & (io.dmi.resp.bits.resp =/= 0.U))\n  181    cover(!nonzeroResp, \"Should see a non-zero response (e.g. when accessing most DM registers when dmactive=0)\")\n  182    cover(!stickyNonzeroRespReg, \"Should see a sticky non-zero response (e.g. when accessing most DM registers when dmactive=0)\")\n  ...\n  197    // Debug Access Chain Implementation\n  198  \n  199:   dmiAccessChain.io.capture.bits := Mux(busy, busyResp, Mux(io.dmi.resp.valid, dmiResp, nopResp))\n  200  \n  201    //--------------------------------------------------------\n  202:   // Drive Ready Valid Interface\n  203  \n  204    val dmiReqValidCheck = WireInit(false.B)\n  205    assert(!(dmiReqValidCheck && io.dmi.req.fire()), \"Conflicting updates for dmiReqValidReg, should not happen.\");\n  206  \n  207:   when (dmiAccessChain.io.update.valid) {\n  208      when (stickyBusyReg) {\n  209        // Do Nothing\n  ...\n  227      dmiReqReg.op === DMIConsts.dmi_OP_WRITE,\n  228        // for write operations confirm resp immediately because we don't care about data\n  229:       io.dmi.resp.valid,\n  230        // for read operations confirm resp when we capture the data\n  231        dmiAccessChain.io.capture.capture & !busy)\n  ...\n  241    cover(dmiReqReg.op === DMIConsts.dmi_OP_READ & dmiAccessChain.io.capture.capture & !busy, \"Enough Idle after DMI Read\");\n  242  \n  243:   io.dmi.req.valid := dmiReqValidReg\n  244  \n  245    // This is a name-based, not type-based assignment. Do these still work?\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/dm_registers.scala:\n  650    val reserved0 = UInt(3.W)\n  651  \n  652:   /* Size of the Program Buffer, in 32-bit words. Valid sizes are 0 - 16.\n  653    */\n  654    val progbufsize = UInt(5.W)\n  ...\n  669              started until the value is reset to 0.\n  670  \n  671:             This field only contains a valid value if \\Fbusy is 0.\n  672  \n  673              0 (none): No error.\n  ...\n  697  \n  698    /* Number of {\\tt data} registers that are implemented as part of the\n  699:             abstract command interface. Valid sizes are 1 -- 12.\n  700    */\n  701    val datacount = UInt(4.W)\n  ...\n  772  \n  773              If a non-existent trigger value is written here, the hardware will\n  774:             change it to a valid one or 0 if no external triggers exist.\n  775    */\n  776    val exttrigger = UInt(4.W)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/DMI.scala:\n  112      }\n  113  \n  114:     tl.a.valid       := io.dmi.req.valid\n  115      io.dmi.req.ready := tl.a.ready\n  116  \n  117:     io.dmi.resp.valid      := tl.d.valid\n  118      tl.d.ready             := io.dmi.resp.ready\n  119      io.dmi.resp.bits.resp  := Mux(tl.d.bits.corrupt || tl.d.bits.denied, DMIConsts.dmi_RESP_FAILURE, DMIConsts.dmi_RESP_SUCCESS)\n  ...\n  122      // Tie off unused channels\n  123      tl.b.ready := false.B\n  124:     tl.c.valid := false.B\n  125:     tl.e.valid := false.B\n  126  \n  127    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/Periphery.scala:\n  327  \n  328        debug.clockeddmi.foreach { d =>\n  329:         d.dmi.req.valid := false.B\n  330          d.dmi.resp.ready := true.B\n  331          d.dmiClock := false.B.asClock\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/SBA.scala:\n  296  \n  297      val muxedData = WireInit(0.U(8.W))\n  298:     val requestValid = tl.a.valid\n  299      val requestReady = tl.a.ready\n  300:     val responseValid = d.valid\n  301      val responseReady = d.ready\n  302  \n  ...\n  360      io.dataOut := d.bits.data\n  361   \n  362:     tl.a.valid := (sbState === SBReadRequest.id.U) || (sbState === SBWriteRequest.id.U)\n  363  \n  364      // Tie off unused channels\n  365      tl.b.ready := false.B\n  366:     tl.c.valid := false.B\n  367:     tl.e.valid := false.B\n  368  \n  369      assert (sbState === Idle.id.U ||\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/BootROM.scala:\n   44      val rom = Vec(bigs.map(x => UInt(x, width = 8*beatBytes)))\n   45  \n   46:     in.d.valid := in.a.valid\n   47      in.a.ready := in.d.ready\n   48  \n   ..\n   52  \n   53      // Tie off unused channels\n   54:     in.b.valid := Bool(false)\n   55      in.c.ready := Bool(true)\n   56      in.e.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/BusBypass.scala:\n   84      val stall = (bypass =/= io.bypass) && edgeIn.first(in.a)\n   85  \n   86:     out0.a.valid := !stall && in.a.valid &&  bypass\n   87:     out1.a.valid := !stall && in.a.valid && !bypass\n   88      in.a.ready   := !stall && Mux(bypass, out0.a.ready, out1.a.ready)\n   89      out0.a.bits  := in.a.bits\n   ..\n   92      out0.d.ready := in.d.ready &&  bypass\n   93      out1.d.ready := in.d.ready && !bypass\n   94:     in.d.valid   := Mux(bypass, out0.d.valid, out1.d.valid)\n   95      def cast(x: TLBundleD) = { val out = Wire(in.d.bits); out <> x; out }\n   96      in.d.bits := Mux(bypass, cast(out0.d.bits), cast(out1.d.bits))\n   ..\n   99        out0.b.ready := in.b.ready &&  bypass\n  100        out1.b.ready := in.b.ready && !bypass\n  101:       in.b.valid   := Mux(bypass, out0.b.valid, out1.b.valid)\n  102        def cast(x: TLBundleB) = { val out = Wire(in.b.bits); out <> x; out }\n  103        in.b.bits := Mux(bypass, cast(out0.b.bits), cast(out1.b.bits))\n  104  \n  105:       out0.c.valid := in.c.valid &&  bypass\n  106:       out1.c.valid := in.c.valid && !bypass\n  107        in.c.ready   := Mux(bypass, out0.c.ready, out1.c.ready)\n  108        out0.c.bits  := in.c.bits\n  109        out1.c.bits  := in.c.bits\n  110  \n  111:       out0.e.valid := in.e.valid &&  bypass\n  112:       out1.e.valid := in.e.valid && !bypass\n  113        in.e.ready   := Mux(bypass, out0.e.ready, out1.e.ready)\n  114        out0.e.bits  := in.e.bits\n  115        out1.e.bits  := in.e.bits\n  116      } else {\n  117:       in.b.valid := Bool(false)\n  118        in.c.ready := Bool(true)\n  119        in.e.ready := Bool(true)\n  120  \n  121        out0.b.ready := Bool(true)\n  122:       out0.c.valid := Bool(false)\n  123:       out0.e.valid := Bool(false)\n  124  \n  125        out1.b.ready := Bool(true)\n  126:       out1.c.valid := Bool(false)\n  127:       out1.e.valid := Bool(false)\n  128      }\n  129    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/Deadlock.scala:\n   18      val (in, _) = node.in(0)\n   19      in.a.ready := Bool(false)\n   20:     in.b.valid := Bool(false)\n   21      in.c.ready := Bool(false)\n   22:     in.d.valid := Bool(false)\n   23      in.e.ready := Bool(false)\n   24    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/Error.scala:\n   49      assert (idle || da_first) // we only send Grant, never GrantData => simplified flow control below\n   50      a.ready := (da.ready && da_last && idle) || !a_last\n   51:     da.valid := a.valid && a_last && idle\n   52  \n   53      da.bits.opcode  := TLMessages.adResponse(a.bits.opcode)\n   ..\n   72  \n   73        c.ready := (dc.ready && dc_last) || !c_last\n   74:       dc.valid := c.valid && c_last\n   75  \n   76        // ReleaseAck is not allowed to report failure\n   ..\n   91  \n   92      // We never probe or issue B requests\n   93:     in.b.valid := Bool(false)\n   94  \n   95      // Sink GrantAcks\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/MaskROM.scala:\n   41      when (in.d.fire()) { d_full := Bool(false) }\n   42      when (in.a.fire()) { d_full := Bool(true)  }\n   43:     in.d.valid := d_full\n   44      in.a.ready := in.d.ready || !d_full\n   45  \n   ..\n   52  \n   53      // Tie off unused channels\n   54:     in.b.valid := Bool(false)\n   55      in.c.ready := Bool(true)\n   56      in.e.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/MasterMux.scala:\n   28    lazy val module = new LazyModuleImp(this) {\n   29      val Seq((out, edgeOut)) = node.out\n   30:     out.a.valid := Bool(false)\n   31      out.b.ready := out.c.ready\n   32:     out.c.valid := out.b.valid\n   33      out.d.ready := Bool(true)\n   34:     out.e.valid := Bool(false)\n   35  \n   36      out.c.bits := edgeOut.ProbeAck(out.b.bits, TLPermissions.NtoN)\n   ..\n   61      in0.a.ready := !stall && out.a.ready &&  bypass\n   62      in1.a.ready := !stall && out.a.ready && !bypass\n   63:     out.a.valid := !stall && Mux(bypass, in0.a.valid, in1.a.valid)\n   64      def castA(x: TLBundleA) = { val ret = Wire(out.a.bits); ret <> x; ret }\n   65      out.a.bits := Mux(bypass, castA(in0.a.bits), castA(in1.a.bits))\n   66  \n   67      out.d.ready := Mux(bypass, in0.d.ready, in1.d.ready)\n   68:     in0.d.valid := out.d.valid &&  bypass\n   69:     in1.d.valid := out.d.valid && !bypass\n   70      in0.d.bits := out.d.bits\n   71      in1.d.bits := out.d.bits\n   ..\n   73      if (edgeOut.manager.anySupportAcquireB && edgeOut.client.anySupportProbe) {\n   74        out.b.ready := Mux(bypass, in0.b.ready, in1.b.ready)\n   75:       in0.b.valid := out.b.valid &&  bypass\n   76:       in1.b.valid := out.b.valid && !bypass\n   77        in0.b.bits := out.b.bits\n   78        in1.b.bits := out.b.bits\n   ..\n   80        in0.c.ready := out.c.ready &&  bypass\n   81        in1.c.ready := out.c.ready && !bypass\n   82:       out.c.valid := Mux(bypass, in0.c.valid, in1.c.valid)\n   83        def castC(x: TLBundleC) = { val ret = Wire(out.c.bits); ret <> x; ret }\n   84        out.c.bits := Mux(bypass, castC(in0.c.bits), castC(in1.c.bits))\n   ..\n   86        in0.e.ready := out.e.ready &&  bypass\n   87        in1.e.ready := out.e.ready && !bypass\n   88:       out.e.valid := Mux(bypass, in0.e.valid, in1.e.valid)\n   89        def castE(x: TLBundleE) = { val ret = Wire(out.e.bits); ret <> x; ret }\n   90        out.e.bits := Mux(bypass, castE(in0.e.bits), castE(in1.e.bits))\n   91      } else {\n   92:       in0.b.valid := Bool(false)\n   93        in0.c.ready := Bool(true)\n   94        in0.e.ready := Bool(true)\n   95  \n   96:       in1.b.valid := Bool(false)\n   97        in1.c.ready := Bool(true)\n   98        in1.e.ready := Bool(true)\n   99  \n  100        out.b.ready := Bool(true)\n  101:       out.c.valid := Bool(false)\n  102:       out.e.valid := Bool(false)\n  103      }\n  104    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/PhysicalFilter.scala:\n  230        val deny_ready = !denyWait && flight === UInt(0)\n  231        in.a.ready := Mux(allow, out.a.ready, !a_first || deny_ready)\n  232:       out.a.valid := in.a.valid && allow\n  233  \n  234        // Frame an appropriate deny message\n  ...\n  237        val d_opcode = TLMessages.adResponse(in.a.bits.opcode)\n  238        val d_grant = Bool(edgeIn.manager.anySupportAcquireB) && deny.opcode === TLMessages.Grant\n  239:       when (in.a.valid && !allow && deny_ready && a_first) {\n  240          denyValid    := Bool(true)\n  241          denyWait     := Bool(true)\n  ...\n  262        // ReleaseAck, because we waited for all A=>D traffic to complete. ReleaseAck is\n  263        // single-beat, so it's safe to just arbitrate without counting the responses.\n  264:       in.d.valid := out.d.valid || denyValid\n  265        out.d.ready := !denyValid && in.d.ready\n  266        in.d.bits := Mux(denyValid, deny, out_d)\n  ...\n  271          val aWOk = PriorityMux(sel, pmps.map(_.w(0)))\n  272          val dWOk = wSourceVec(in.d.bits.source)\n  273:         val bypass = Bool(edgeIn.manager.minLatency == 0) && in.a.valid && in.a.bits.source === in.d.bits.source\n  274          val d_grant = in.d.bits.opcode === TLMessages.Grant || in.d.bits.opcode === TLMessages.GrantData\n  275          val dWHeld = Mux(bypass, aWOk, dWOk) holdUnless d_first\n  ...\n  289          // Swallow GrantAcks\n  290          val isMyId = mySinkId === in.e.bits.sink\n  291:         out.e.valid := in.e.valid && !isMyId\n  292          in.e.ready := out.e.ready || isMyId\n  293  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/Plic.scala:\n   21  \n   22  class GatewayPLICIO extends Bundle {\n   23:   val valid = Bool(OUTPUT)\n   24    val ready = Bool(INPUT)\n   25    val complete = Bool(INPUT)\n   ..\n   35    when (io.interrupt && io.plic.ready) { inFlight := true }\n   36    when (io.plic.complete) { inFlight := false }\n   37:   io.plic.valid := io.interrupt && !inFlight\n   38  }\n   39  \n   ..\n  249      ((pending zip gateways) zip claimedDevs.tail) foreach { case ((p, g), c) =>\n  250        g.ready := !p\n  251:       when (c || g.valid) { p := !c }\n  252      }\n  253  \n  ...\n  285          RegField(32-prioBits),\n  286          RegField(32,\n  287:           RegReadFn { valid =>\n  288:             claimer(i) := valid\n  289              (Bool(true), maxDevs(i))\n  290            },\n  291:           RegWriteFn { (valid, data) =>\n  292              assert(completerDev === data.extract(log2Ceil(nDevices+1)-1, 0), \n  293                     \"completerDev should be consistent for all harts\")\n  294              completerDev := data.extract(log2Ceil(nDevices+1)-1, 0)\n  295:             completer(i) := valid && enableVec0(i)(completerDev)\n  296              Bool(true)\n  297            },\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/TestRAM.scala:\n   42      // \"Flow control\"\n   43      in.a.ready := in.d.ready\n   44:     in.d.valid := in.a.valid\n   45  \n   46      val hasData = edge.hasData(in.a.bits)\n   ..\n   57  \n   58      // Tie off unused channels\n   59:     in.b.valid := Bool(false)\n   60      in.c.ready := Bool(true)\n   61      in.e.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/Zero.scala:\n   52  \n   53      a.ready := in.d.ready\n   54:     in.d.valid := a.valid\n   55      in.d.bits := edge.AccessAck(a.bits)\n   56      in.d.bits.opcode := TLMessages.adResponse(edge.opcode(a.bits))\n   57  \n   58      // Tie off unused channels\n   59:     in.b.valid := Bool(false)\n   60      in.c.ready := Bool(true)\n   61      in.e.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/package.scala:\n  146    *    of binding c to b and b to a. This requires that the return type of `:=` be the\n  147    *    same as its arguments, because the result of one `:=` operation must be\n  148:   *    valid as an argument to other `:=` operations.\n  149    *\n  150    * 2. It should be associative, so that `(a := b) := c` is equivalent to `a := (b := c).`\n\n/share/code/rocket-chip-dongdeji/src/main/scala/groundtest/DummyPTW.scala:\n   16    }\n   17  \n   18:   val req_arb = Module(new RRArbiter(Valid(new PTWReq), n))\n   19    req_arb.io.in <> io.requestors.map(_.req)\n   20    req_arb.io.out.ready := Bool(true)\n   ..\n   28  \n   29    val s1_ppn = vpn_to_ppn(req_arb.io.out.bits.bits.addr)\n   30:   val s2_ppn = RegEnable(s1_ppn, req_arb.io.out.valid)\n   31:   val s2_chosen = RegEnable(req_arb.io.chosen, req_arb.io.out.valid)\n   32:   val s2_valid = Reg(next = req_arb.io.out.valid && req_arb.io.out.bits.valid)\n   33  \n   34    val s2_resp = Wire(init = 0.U.asTypeOf(new PTWResp))\n   ..\n   46  \n   47    io.requestors.zipWithIndex.foreach { case (requestor, i) =>\n   48:     requestor.resp.valid := s2_valid && s2_chosen === UInt(i)\n   49      requestor.resp.bits := s2_resp\n   50      requestor.status := 0.U.asTypeOf(requestor.status)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/groundtest/Status.scala:\n    7  \n    8  class GroundTestStatus extends Bundle {\n    9:   val timeout = Valid(UInt(width = 4))\n   10:   val error = Valid(UInt(width = 4))\n   11  }\n   12  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/groundtest/TraceGen.scala:\n  223  \n  224    val reqTimer = Module(new Timer(8192, maxTags))\n  225:   reqTimer.io.start.valid := io.mem.req.fire()\n  226    reqTimer.io.start.bits := io.mem.req.bits.tag\n  227:   reqTimer.io.stop.valid := io.mem.resp.valid\n  228    reqTimer.io.stop.bits := io.mem.resp.bits.tag\n  229  \n  ...\n  524  \n  525    // Wire up interface to memory\n  526:   io.mem.req.valid     := reqValid\n  527    io.mem.req.bits.addr := reqAddr\n  528    io.mem.req.bits.data := reqData\n  ...\n  564  \n  565    // When a response is received\n  566:   when (io.mem.resp.valid) {\n  567      // Put tag back in tag set\n  568      tagMan.io.tagIn := io.mem.resp.bits.tag\n  ...\n  589  \n  590    io.finished := done\n  591:   io.timeout := reqTimer.io.timeout.valid\n  592  }\n  593  \n  ...\n  627    outer.reportHalt(Some(tracegen.io.timeout))\n  628    outer.reportWFI(None)\n  629:   status.timeout.valid := tracegen.io.timeout\n  630    status.timeout.bits := UInt(0)\n  631:   status.error.valid := Bool(false)\n  632  \n  633    assert(!tracegen.io.timeout, s\"TraceGen tile ${outer.tileParams.hartId}: request timed out\")\n\n/share/code/rocket-chip-dongdeji/src/main/scala/jtag/JtagShifter.scala:\n    6  import chisel3.experimental.DataMirror\n    7  import chisel3.internal.firrtl.KnownWidth\n    8: import chisel3.util.{Cat, Valid}\n    9  \n   10  import freechips.rocketchip.config.Parameters\n   ..\n   35  \n   36  class Capture[+T <: Data](gen: T) extends Bundle {\n   37:   val bits = Input(gen)  // data to capture, should be always valid\n   38    val capture = Output(Bool())  // will be high in capture state (single cycle), captured on following rising edge\n   39    override def cloneType = Capture(gen).asInstanceOf[this.type]\n   ..\n  138    class ModIO extends ChainIO {\n  139      val capture = Capture(genCapture)\n  140:     val update = Valid(genUpdate)  // valid high when in update state (single cycle), contents may change any time after\n  141    }\n  142    val io = IO(new ModIO)\n  ...\n  169      (captureWidth until n) map (x => regs(x) := 0.U)\n  170      io.capture.capture := true.B\n  171:     io.update.valid := false.B\n  172    } .elsewhen (io.chainIn.update) {\n  173      io.capture.capture := false.B\n  174:     io.update.valid := true.B\n  175    } .elsewhen (io.chainIn.shift) {\n  176      regs(n-1) := io.chainIn.data\n  177      (0 until n-1) map (x => regs(x) := regs(x+1))\n  178      io.capture.capture := false.B\n  179:     io.update.valid := false.B\n  180    } .otherwise {\n  181      io.capture.capture := false.B\n  182:     io.update.valid := false.B\n  183    }\n  184    assert(!(io.chainIn.capture && io.chainIn.update)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/regmapper/RegField.scala:\n   23    implicit def apply(x: RegisterReadIO[UInt]): RegReadFn =\n   24      RegReadFn((ivalid, oready) => {\n   25:       x.request.valid := ivalid\n   26        x.response.ready := oready\n   27:       (x.request.ready, x.response.valid, x.response.bits)\n   28      })\n   29:   // (ready: Bool) => (valid: Bool, data: UInt)\n   30:   // valid must not combinationally depend on ready\n   31:   // effects must become visible on the cycle after valid && ready\n   32    implicit def apply(x: Bool => (Bool, UInt)) =\n   33      new RegReadFn(true, { case (_, oready) =>\n   ..\n   36      })\n   37    // read from a ReadyValidIO (only safe if there is a consistent source of data)\n   38:   implicit def apply(x: ReadyValidIO[UInt]):RegReadFn = RegReadFn(ready => { x.ready := ready; (x.valid, x.bits) })\n   39    // read from a register\n   40    implicit def apply(x: UInt):RegReadFn = RegReadFn(ready => (Bool(true), x))\n   ..\n   55    implicit def apply(x: RegisterWriteIO[UInt]): RegWriteFn =\n   56      RegWriteFn((ivalid, oready, data) => {\n   57:       x.request.valid := ivalid\n   58        x.request.bits := data\n   59        x.response.ready := oready\n   60:       (x.request.ready, x.response.valid)\n   61      })\n   62:   // (valid: Bool, data: UInt) => (ready: Bool)\n   63:   // ready may combinationally depend on data (but not valid)\n   64:   // effects must become visible on the cycle after valid && ready\n   65    implicit def apply(x: (Bool, UInt) => Bool) =\n   66:     // combinational => data valid on oready\n   67      new RegWriteFn(true, { case (_, oready, data) =>\n   68        (Bool(true), x(oready, data))\n   69      })\n   70    // write to a DecoupledIO (only safe if there is a consistent sink draining data)\n   71:   // NOTE: this is not an IrrevocableIO (even on TL2) because other fields could cause a lowered valid\n   72:   implicit def apply(x: DecoupledIO[UInt]): RegWriteFn = RegWriteFn((valid, data) => { x.valid := valid; x.bits := data; x.ready })\n   73    // updates a register (or adds a mux to a wire)\n   74:   implicit def apply(x: UInt): RegWriteFn = RegWriteFn((valid, data) => { when (valid) { x := data }; Bool(true) })\n   75    // noop\n   76:   implicit def apply(x: Unit): RegWriteFn = RegWriteFn((valid, data) => { Bool(true) })\n   77  }\n   78  \n   ..\n  126    // Setting takes priority over clearing.\n  127    def w1ToClear(n: Int, reg: UInt, set: UInt, desc: Option[RegFieldDesc] = None): RegField =\n  128:     RegField(n, reg, RegWriteFn((valid, data) => { reg := ~(~reg | Mux(valid, data, UInt(0))) | set; Bool(true) }),\n  129        desc.map{_.copy(access = RegFieldAccessType.RW, wrType=Some(RegFieldWrType.ONE_TO_CLEAR), volatile = true)})\n  130  \n  ...\n  132    // (e.g. Black-Boxed Register) to create a R/W register.\n  133    def rwReg(n: Int, bb: SimpleRegIO, desc: Option[RegFieldDesc] = None) : RegField =\n  134:     RegField(n, bb.q, RegWriteFn((valid, data) => {\n  135:       bb.en := valid\n  136        bb.d := data\n  137        Bool(true)\n  ...\n  154      when (valids.reduce(_ || _)) { reg := newBytes.asUInt }\n  155  \n  156:     def wrFn(i: Int): RegWriteFn = RegWriteFn((valid, data) => {\n  157:       valids(i) := valid\n  158:       when (valid) {newBytes(i) := data}\n  159        Bool(true)\n  160      })\n\n/share/code/rocket-chip-dongdeji/src/main/scala/regmapper/RegisterCrossing.scala:\n  105  \n  106    control.io.bypass := io.master_bypass\n  107:   control.io.master_request_valid  := io.master_port.request.valid\n  108    control.io.master_response_ready := io.master_port.response.ready\n  109    io.master_port.request.ready  := control.io.master_request_ready\n  110:   io.master_port.response.valid := control.io.master_response_valid\n  111  \n  112    control.io.crossing_request_ready := crossing.io.enq.ready\n  113:   crossing.io.enq.valid := control.io.crossing_request_valid\n  114    crossing.io.enq.bits := io.master_port.request.bits\n  115  \n  116    crossing.io.deq.ready := Bool(true)\n  117:   io.slave_valid := crossing.io.deq.valid\n  118    io.slave_register := crossing.io.deq.bits\n  119  \n  ...\n  160  \n  161    control.io.bypass := io.master_bypass\n  162:   control.io.master_request_valid  := io.master_port.request.valid\n  163    control.io.master_response_ready := io.master_port.response.ready\n  164    io.master_port.request.ready  := control.io.master_request_ready\n  165:   io.master_port.response.valid := control.io.master_response_valid\n  166  \n  167:   control.io.crossing_request_ready := crossing.io.deq.valid\n  168    crossing.io.deq.ready := control.io.crossing_request_valid\n  169    io.master_port.response.bits := crossing.io.deq.bits\n  170  \n  171:   crossing.io.enq.valid := Bool(true)\n  172    crossing.io.enq.bits := io.slave_register\n  173  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/regmapper/RegMapper.scala:\n  164  \n  165        def litOR(x: Bool, y: Bool) = if (x.isLit && x.litValue == 1) Bool(true) else x || y\n  166:       // Add this field to the ready-valid signals for the register\n  167        rifire(reg) = (rivalid(i), litOR(f_riready, !rimask)) +: rifire(reg)\n  168        wifire(reg) = (wivalid(i), litOR(f_wiready, !wimask)) +: wifire(reg)\n  ...\n  182  \n  183      // Compute: is the selected register ready? ... and cross-connect all ready-valids\n  184:     def mux(index: UInt, valid: Bool, select: Seq[Bool], guard: Seq[Bool], flow: Seq[Seq[(Bool, Bool)]]): Bool =\n  185        MuxSeq(index, Bool(true), ((select zip guard) zip flow).map { case ((s, g), f) =>\n  186          val out = Wire(Bool())\n  187:         ReduceOthers((out, valid && s && g) +: f)\n  188          out || !g\n  189        })\n  190  \n  191      // Include the per-register one-hot selected criteria\n  192:     val rifireMux = mux(iindex, in.valid && front.ready &&  front.bits.read, frontSel, iRightReg, rifire)\n  193:     val wifireMux = mux(iindex, in.valid && front.ready && !front.bits.read, frontSel, iRightReg, wifire)\n  194:     val rofireMux = mux(oindex, back.valid && out.ready &&  back .bits.read, backSel,  oRightReg, rofire)\n  195:     val wofireMux = mux(oindex, back.valid && out.ready && !back .bits.read, backSel,  oRightReg, wofire)\n  196  \n  197      val iready = Mux(front.bits.read, rifireMux, wifireMux)\n  ...\n  200      // Connect the pipeline\n  201      in.ready    := front.ready && iready\n  202:     front.valid := in.valid    && iready\n  203      back.ready  := out.ready   && oready\n  204:     out.valid   := back.valid  && oready\n  205  \n  206      out.bits.read  := back.bits.read\n\n/share/code/rocket-chip-dongdeji/src/main/scala/regmapper/Test.scala:\n   54    def delay(x: Int): Bool => Bool = { ready =>\n   55      val reg = RegInit(UInt(0, width = log2Ceil(x+1)))\n   56:     val valid = reg === UInt(0)\n   57:     reg := Mux(ready && valid, UInt(x), Mux(valid, UInt(0), reg - UInt(1)))\n   58:     valid\n   59    }\n   60  \n   ..\n   63      RegField(bits,\n   64        RegReadFn { ready => combo.io.rready := ready; (combo.io.rvalid, combo.io.rdata) },\n   65:       RegWriteFn { (valid, data) => combo.io.wvalid := valid; combo.io.wdata := data; combo.io.wready })\n   66    }\n   67  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/Breakpoint.scala:\n   71  \n   72  class BPWatch (val n: Int) extends Bundle() {\n   73:   val valid = Vec(n, Bool())\n   74    val rvalid = Vec(n, Bool())\n   75    val wvalid = Vec(n, Bool())\n   ..\n  112  \n  113      bpw.action := action\n  114:     bpw.valid(0) := false.B\n  115      bpw.rvalid(0) := false.B\n  116      bpw.wvalid(0) := false.B\n  117      bpw.ivalid(0) := false.B\n  118  \n  119:     when (end && r && ri) { io.xcpt_ld := (action === 0.U); io.debug_ld := (action === 1.U); bpw.valid(0) := true.B; bpw.rvalid(0) := true.B }\n  120:     when (end && w && wi) { io.xcpt_st := (action === 0.U); io.debug_st := (action === 1.U); bpw.valid(0) := true.B; bpw.wvalid(0) := true.B }\n  121:     when (end && x && xi) { io.xcpt_if := (action === 0.U); io.debug_if := (action === 1.U); bpw.valid(0) := true.B; bpw.ivalid(0) := true.B }\n  122  \n  123      (end || r, end || w, end || x)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/BTB.scala:\n  167  //  - \"bridx\" is the low-order PC bits of the predicted branch (after\n  168  //     shifting off the lowest log(inst_bytes) bits off).\n  169: //  - \"mask\" provides a mask of valid instructions (instructions are\n  170  //     masked off by the predicted taken branch from the BTB).\n  171  class BTBResp(implicit p: Parameters) extends BtbBundle()(p) {\n  ...\n  189  class BTB(implicit p: Parameters) extends BtbModule {\n  190    val io = new Bundle {\n  191:     val req = Valid(new BTBReq).flip\n  192:     val resp = Valid(new BTBResp)\n  193:     val btb_update = Valid(new BTBUpdate).flip\n  194:     val bht_update = Valid(new BHTUpdate).flip\n  195:     val bht_advance = Valid(new BTBResp).flip\n  196:     val ras_update = Valid(new RASUpdate).flip\n  197:     val ras_head = Valid(UInt(width = vaddrBits))\n  198      val flush = Bool().asInput\n  199    }\n  ...\n  249    val tgtPageReplEn = Mux(doTgtPageRepl, tgtPageRepl, UInt(0))\n  250  \n  251:   when (r_btb_update.valid && (doIdxPageRepl || doTgtPageRepl)) {\n  252      val both = doIdxPageRepl && doTgtPageRepl\n  253      val next = nextPageRepl + Mux[UInt](both, 2, 1)\n  ...\n  258    val waddr = Mux(updateHit, updateHitAddr, repl.way)\n  259    val r_resp = Pipe(io.resp)\n  260:   when (r_resp.valid && r_resp.bits.taken || r_btb_update.valid) {\n  261:     repl.access(Mux(r_btb_update.valid, waddr, r_resp.bits.entry))\n  262    }\n  263  \n  264:   when (r_btb_update.valid) {\n  265      val mask = UIntToOH(waddr)\n  266      idxs(waddr) := r_btb_update.bits.pc(matchBits-1, log2Up(coreInstBytes))\n  267      tgts(waddr) := update_target(matchBits-1, log2Up(coreInstBytes))\n  268:     idxPages(waddr) := idxPageUpdate +& 1 // the +1 corresponds to the <<1 on io.resp.valid\n  269      tgtPages(waddr) := tgtPageUpdate\n  270      cfiType(waddr) := r_btb_update.bits.cfiType\n  ...\n  287    }\n  288  \n  289:   io.resp.valid := (pageHit << 1)(Mux1H(idxHit, idxPages))\n  290    io.resp.bits.taken := true\n  291    io.resp.bits.target := Cat(pagesMasked(Mux1H(idxHit, tgtPages)), Mux1H(idxHit, tgts) << log2Up(coreInstBytes))\n  ...\n  307      val isBranch = (idxHit & cfiType.map(_ === CFIType.branch).asUInt).orR\n  308      val res = bht.get(io.req.bits.addr)\n  309:     when (io.bht_advance.valid) {\n  310        bht.advanceHistory(io.bht_advance.bits.bht.taken)\n  311      }\n  312:     when (io.bht_update.valid) {\n  313        when (io.bht_update.bits.branch) {\n  314          bht.updateTable(io.bht_update.bits.pc, io.bht_update.bits.prediction, io.bht_update.bits.taken)\n  ...\n  327      val ras = new RAS(btbParams.nRAS)\n  328      val doPeek = (idxHit & cfiType.map(_ === CFIType.ret).asUInt).orR\n  329:     io.ras_head.valid := !ras.isEmpty\n  330      io.ras_head.bits := ras.peek\n  331      when (!ras.isEmpty && doPeek) {\n  332        io.resp.bits.target := ras.peek\n  333      }\n  334:     when (io.ras_update.valid) {\n  335        when (io.ras_update.bits.cfiType === CFIType.call) {\n  336          ras.push(io.ras_update.bits.returnAddr)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/CSR.scala:\n  127    def C = UInt(7,SZ)\n  128  \n  129:   // mask a CSR cmd with a valid bit\n  130:   def maskCmd(valid: Bool, cmd: UInt): UInt = {\n  131      // all commands less than CSR.I are treated by CSRFile as NOPs\n  132:     cmd & ~Mux(valid, 0.U, CSR.I)\n  133    }\n  134  \n  ...\n  167  \n  168  class TracedInstruction(implicit p: Parameters) extends CoreBundle {\n  169:   val valid = Bool()\n  170    val iaddr = UInt(width = coreMaxAddrBits)\n  171    val insn = UInt(width = iLen)\n  ...\n  222    val time = UInt(OUTPUT, xLen)\n  223    val fcsr_rm = Bits(OUTPUT, FPConstants.RM_SZ)\n  224:   val fcsr_flags = Valid(Bits(width = FPConstants.FLAGS_SZ)).flip\n  225    val set_fs_dirty = coreParams.haveFSDirty.option(Bool(INPUT))\n  226    val rocc_interrupt = Bool(INPUT)\n  ...\n  242      val vxrm = UInt(2.W).asOutput\n  243      val set_vs_dirty = Input(Bool())\n  244:     val set_vconfig = Valid(new VConfig).flip\n  245:     val set_vstart = Valid(vstart).flip\n  246      val set_vxsat = Bool().asInput\n  247    })\n  ...\n  884  \n  885    io.fcsr_rm := reg_frm\n  886:   when (io.fcsr_flags.valid) {\n  887      reg_fflags := reg_fflags | io.fcsr_flags.bits\n  888      set_fs_dirty := true\n  ...\n 1105  \n 1106    io.vector.map { vio =>\n 1107:     when (vio.set_vconfig.valid) {\n 1108        // user of CSRFile is responsible for set_vs_dirty in this case\n 1109        assert(vio.set_vconfig.bits.vl <= vio.set_vconfig.bits.vtype.vlMax)\n 1110        reg_vconfig.get := vio.set_vconfig.bits\n 1111      }\n 1112:     when (vio.set_vstart.valid) {\n 1113        set_vs_dirty := true\n 1114        reg_vstart.get := vio.set_vstart.bits\n ....\n 1163    for (((t, insn), i) <- (io.trace zip io.inst).zipWithIndex) {\n 1164      t.exception := io.retire >= i && exception\n 1165:     t.valid := io.retire > i || t.exception\n 1166      t.insn := insn\n 1167      t.iaddr := io.pc\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/DCache.scala:\n   27  class DCacheErrors(implicit p: Parameters) extends L1HellaCacheBundle()(p)\n   28      with CanHaveErrors {\n   29:   val correctable = (cacheParams.tagCode.canCorrect || cacheParams.dataCode.canCorrect).option(Valid(UInt(width = paddrBits)))\n   30:   val uncorrectable = (cacheParams.tagCode.canDetect || cacheParams.dataCode.canDetect).option(Valid(UInt(width = paddrBits)))\n   31:   val bus = Valid(UInt(width = paddrBits))\n   32  }\n   33  \n   ..\n   43  class DCacheDataArray(implicit p: Parameters) extends L1HellaCacheModule()(p) {\n   44    val io = new Bundle {\n   45:     val req = Valid(new DCacheDataReq).flip\n   46      val resp = Vec(nWays, UInt(width = req.bits.wdata.getWidth)).asOutput\n   47    }\n   ..\n   63  \n   64    val rdata = for (((array, omSRAM), i) <- data_arrays zipWithIndex) yield {\n   65:     val valid = io.req.valid && (Bool(data_arrays.size == 1) || io.req.bits.wordMask(i))\n   66:     when (valid && io.req.bits.write) {\n   67        val wMaskSlice = (0 until wMask.size).filter(j => i % (wordBits/subWordBits) == (j % (wordBytes/eccBytes)) / (subWordBytes/eccBytes)).map(wMask(_))\n   68        val wData = wWords(i).grouped(encBits)\n   69        array.write(addr, Vec((0 until nWays).flatMap(i => wData)), wMaskSlice)\n   70      }\n   71:     val data = array.read(addr, valid && !io.req.bits.write)\n   72      data.grouped(subWordBits / eccBits).map(_.asUInt).toSeq\n   73    }\n   ..\n  168    val s1_tlb_req_valid = RegNext(tlb_port.req.fire(), false.B)\n  169    val s2_tlb_req_valid = RegNext(s1_tlb_req_valid, false.B)\n  170:   val s0_clk_en = metaArb.io.out.valid && !metaArb.io.out.bits.write\n  171  \n  172    val s0_req = WireInit(io.cpu.req.bits)\n  ...\n  184      s0_tlb_req.cmd := s0_req.cmd\n  185    }\n  186:   val s1_tlb_req = RegEnable(s0_tlb_req, s0_clk_en || tlb_port.req.valid)\n  187  \n  188    val s1_read = isRead(s1_req.cmd)\n  ...\n  218    // hit initiation path\n  219    val s0_read = isRead(io.cpu.req.bits.cmd)\n  220:   dataArb.io.in(3).valid := io.cpu.req.valid && likelyNeedsRead(io.cpu.req.bits)\n  221    dataArb.io.in(3).bits := dataArb.io.in(1).bits\n  222    dataArb.io.in(3).bits.write := false\n  ...\n  235    dataArb.io.in(3).bits.way_en := ~UInt(0, nWays)\n  236    when (!dataArb.io.in(3).ready && s0_read) { io.cpu.req.ready := false }\n  237:   val s1_did_read = RegEnable(dataArb.io.in(3).ready && (io.cpu.req.valid && needsRead(io.cpu.req.bits)), s0_clk_en)\n  238    val s1_read_mask = RegEnable(dataArb.io.in(3).bits.wordMask, s0_clk_en)\n  239:   metaArb.io.in(7).valid := io.cpu.req.valid\n  240    metaArb.io.in(7).bits.write := false\n  241    metaArb.io.in(7).bits.idx := dataArb.io.in(3).bits.addr(idxMSB, idxLSB)\n  ...\n  249    io.ptw <> tlb.io.ptw\n  250    tlb.io.kill := io.cpu.s2_kill || s2_tlb_req_valid && tlb_port.s2_kill\n  251:   tlb.io.req.valid := s1_tlb_req_valid || s1_valid && !io.cpu.s1_kill && s1_cmd_uses_tlb\n  252    tlb.io.req.bits := s1_tlb_req\n  253:   when (!tlb.io.req.ready && !tlb.io.ptw.resp.valid && !io.cpu.req.bits.phys) { io.cpu.req.ready := false }\n  254    when (!s1_tlb_req_valid && s1_valid && s1_cmd_uses_tlb && tlb.io.resp.miss) { s1_nack := true }\n  255  \n  256:   tlb.io.sfence.valid := s1_valid && !io.cpu.s1_kill && s1_sfence\n  257    tlb.io.sfence.bits.rs1 := s1_req.size(0)\n  258    tlb.io.sfence.bits.rs2 := s1_req.size(1)\n  ...\n  279        val metaReq = metaArb.io.out\n  280        val metaIdx = metaReq.bits.idx\n  281:       when (metaReq.valid && metaReq.bits.write) {\n  282          val wmask = if (nWays == 1) Seq(true.B) else metaReq.bits.way_en.asBools\n  283          tag_array.write(metaIdx, Vec.fill(nWays)(metaReq.bits.data), wmask)\n  284        }\n  285:       val s1_meta = tag_array.read(metaIdx, metaReq.valid && !metaReq.bits.write)\n  286        val s1_meta_uncorrected = s1_meta.map(tECC.decode(_).uncorrected.asTypeOf(new L1Metadata))\n  287        val s1_tag = s1_paddr >> tagLSB\n  ...\n  419    // tag updates on ECC errors\n  420    val s2_first_meta_corrected = PriorityMux(s2_meta_correctable_errors, s2_meta_corrected)\n  421:   metaArb.io.in(1).valid := s2_meta_error && (s2_valid_masked || s2_flush_valid_pre_tag_ecc || s2_probe)\n  422    metaArb.io.in(1).bits.write := true\n  423    metaArb.io.in(1).bits.way_en := s2_meta_uncorrectable_errors | Mux(s2_meta_error_uncorrectable, 0.U, PriorityEncoderOH(s2_meta_correctable_errors))\n  ...\n  431  \n  432    // tag updates on hit\n  433:   metaArb.io.in(2).valid := s2_valid_hit_pre_data_ecc_and_waw && s2_update_meta\n  434    metaArb.io.in(2).bits.write := !io.cpu.s2_kill\n  435    metaArb.io.in(2).bits.way_en := s2_victim_or_hit_way\n  ...\n  471    val pstore1_merge = s2_store_valid && s2_store_merge\n  472    val pstore2_valid = RegInit(false.B)\n  473:   val pstore_drain_opportunistic = !(io.cpu.req.valid && likelyNeedsRead(io.cpu.req.bits)) && !(s1_valid && s1_waw_hazard)\n  474    val pstore_drain_on_miss = releaseInFlight || RegNext(io.cpu.s2_nack)\n  475    val pstore1_held = RegInit(false.B)\n  ...\n  516      pstore2_valid && wordMatch && idxMatch && tagMatch\n  517    })\n  518:   dataArb.io.in(0).valid := should_pstore_drain(false)\n  519    dataArb.io.in(0).bits.write := pstore_drain\n  520    dataArb.io.in(0).bits.addr := Mux(pstore2_valid, pstore2_addr, pstore1_addr)\n  ...\n  568    } else {\n  569      // If no managers support atomics, assert fail if processor asks for them\n  570:     assert (!(tl_out_a.valid && s2_read && s2_write && s2_uncached))\n  571      Wire(new TLBundleA(edge.bundle))\n  572    }\n  573  \n  574:   tl_out_a.valid := !io.cpu.s2_kill &&\n  575      (s2_valid_uncached_pending ||\n  576        (s2_valid_cached_miss &&\n  ...\n  623      val whole_opc = tl_out.d.bits.opcode\n  624      if (usingDataScratchpad) {\n  625:       assert(!tl_out.d.valid || whole_opc.isOneOf(uncachedGrantOpcodes))\n  626:       // the only valid TL-D messages are uncached, so we can do some pruning\n  627        val opc = whole_opc(uncachedGrantOpcodes.map(_.getWidth).max - 1, 0)\n  628        val data = DecodeLogic(opc, uncachedGrantOpcodesWithData, uncachedGrantOpcodesSansData)\n  ...\n  683  \n  684    // Finish TileLink transaction by issuing a GrantAck\n  685:   tl_out.e.valid := tl_out.d.valid && d_first && grantIsCached && canAcceptCachedGrant\n  686    tl_out.e.bits := edge.GrantAck(tl_out.d.bits)\n  687    assert(tl_out.e.fire() === (tl_out.d.fire() && d_first && grantIsCached))\n  688  \n  689    // data refill\n  690:   // note this ready-valid signaling ignores E-channel backpressure, which\n  691    // benignly means the data RAM might occasionally be redundantly written\n  692:   dataArb.io.in(1).valid := tl_out.d.valid && grantIsRefill && canAcceptCachedGrant\n  693    when (grantIsRefill && !dataArb.io.in(1).ready) {\n  694:     tl_out.e.valid := false\n  695      tl_out.d.ready := false\n  696    }\n  ...\n  710    // errors on hit-under-miss.  failing to write the new tag will leave the\n  711    // line invalid, so we'll simply request the line again later.\n  712:   metaArb.io.in(3).valid := grantIsCached && d_done && !tl_out.d.bits.denied\n  713    metaArb.io.in(3).bits.write := true\n  714    metaArb.io.in(3).bits.way_en := refill_way\n  ...\n  720      // don't accept uncached grants if there's a structural hazard on s2_data...\n  721      val blockUncachedGrant = Reg(Bool())\n  722:     blockUncachedGrant := dataArb.io.out.valid\n  723      when (grantIsUncachedData && (blockUncachedGrant || s1_valid)) {\n  724        tl_out.d.ready := false\n  725        // ...but insert bubble to guarantee grant's eventual forward progress\n  726:       when (tl_out.d.valid) {\n  727          io.cpu.req.ready := false\n  728:         dataArb.io.in(1).valid := true\n  729          dataArb.io.in(1).bits.write := false\n  730          blockUncachedGrant := !dataArb.io.in(1).ready\n  ...\n  732      }\n  733    }\n  734:   ccover(tl_out.d.valid && !tl_out.d.ready, \"BLOCK_D\", \"D$ D-channel blocked\")\n  735  \n  736    // Handle an incoming TileLink Probe message\n  ...\n  738    val block_probe_for_pending_release_ack = release_ack_wait && (tl_out.b.bits.address ^ release_ack_addr)(((pgIdxBits + pgLevelBits) min paddrBits) - 1, idxLSB) === 0\n  739    val block_probe_for_ordering = releaseInFlight || block_probe_for_pending_release_ack || grantInProgress\n  740:   metaArb.io.in(6).valid := tl_out.b.valid && (!block_probe_for_core_progress || lrscBackingOff)\n  741    tl_out.b.ready := metaArb.io.in(6).ready && !(block_probe_for_core_progress || block_probe_for_ordering || s1_valid || s2_valid)\n  742    metaArb.io.in(6).bits.write := false\n  ...\n  779    val dirtyReleaseMessage = edge.ProbeAck(b = probe_bits, reportPermissions = s2_report_param, data = 0.U)\n  780  \n  781:   tl_out_c.valid := (s2_release_data_valid || (!cacheParams.silentDrop && release_state === s_voluntary_release)) && !(c_first && release_ack_wait)\n  782    tl_out_c.bits := nackResponseMessage\n  783    val newCoh = Wire(init = probeNewCoh)\n  ...\n  800          release_state := s_probe_rep_dirty\n  801        }.elsewhen (s2_probe_state.isValid()) {\n  802:         tl_out_c.valid := true\n  803          tl_out_c.bits := cleanReleaseMessage\n  804          release_state := Mux(releaseDone, s_probe_write_meta, s_probe_rep_clean)\n  805        }.otherwise {\n  806:         tl_out_c.valid := true\n  807          probeNack := !releaseDone\n  808          release_state := Mux(releaseDone, s_ready, s_probe_rep_miss)\n  ...\n  811      }\n  812      when (release_state === s_probe_retry) {\n  813:       metaArb.io.in(6).valid := true\n  814        metaArb.io.in(6).bits.idx := probeIdx(probe_bits)\n  815        metaArb.io.in(6).bits.addr := Cat(io.cpu.req.bits.addr >> paddrBits, probe_bits.address)\n  ...\n  820      }\n  821      when (release_state === s_probe_rep_miss) {\n  822:       tl_out_c.valid := true\n  823        when (releaseDone) { release_state := s_ready }\n  824      }\n  825      when (release_state === s_probe_rep_clean) {\n  826:       tl_out_c.valid := true\n  827        tl_out_c.bits := cleanReleaseMessage\n  828        when (releaseDone) { release_state := s_probe_write_meta }\n  ...\n  869    }\n  870  \n  871:   dataArb.io.in(2).valid := inWriteback && releaseDataBeat < refillCycles\n  872    dataArb.io.in(2).bits := dataArb.io.in(1).bits\n  873    dataArb.io.in(2).bits.write := false\n  ...\n  877    dataArb.io.in(2).bits.way_en := ~UInt(0, nWays)\n  878  \n  879:   metaArb.io.in(4).valid := release_state.isOneOf(s_voluntary_write_meta, s_probe_write_meta)\n  880    metaArb.io.in(4).bits.write := true\n  881    metaArb.io.in(4).bits.way_en := releaseWay\n  ...\n  898    io.cpu.ordered := !(s1_valid && !s1_isSlavePortAccess || s2_valid && !s2_isSlavePortAccess || cached_grant_wait || uncachedInFlight.asUInt.orR)\n  899  \n  900:   val s1_xcpt_valid = tlb.io.req.valid && !s1_isSlavePortAccess && !s1_nack\n  901    io.cpu.s2_xcpt := Mux(RegNext(s1_xcpt_valid), s2_tlb_xcpt, 0.U.asTypeOf(s2_tlb_xcpt))\n  902  \n  ...\n  904      assert(!(s2_valid_masked && s2_req.cmd.isOneOf(M_XLR, M_XSC)))\n  905    } else {\n  906:     ccover(tl_out.b.valid && !tl_out.b.ready, \"BLOCK_B\", \"D$ B-channel blocked\")\n  907    }\n  908  \n  ...\n  915    val s2_uncached_data_word = RegEnable(s1_uncached_data_word, io.cpu.replay_next)\n  916    val doUncachedResp = Reg(next = io.cpu.replay_next)\n  917:   io.cpu.resp.valid := (s2_valid_hit_pre_data_ecc || doUncachedResp) && !s2_data_error\n  918    io.cpu.replay_next := tl_out.d.fire() && grantIsUncachedData && !cacheParams.separateUncachedResp\n  919    when (doUncachedResp) {\n  ...\n  924  \n  925    io.cpu.uncached_resp.map { resp =>\n  926:     resp.valid := tl_out.d.valid && grantIsUncachedData\n  927      resp.bits.tag := uncachedResp.tag\n  928      resp.bits.size := uncachedResp.size\n  ...\n  981    ccover(s2_valid_masked && s2_cmd_flush_all && s2_data_error, \"DATA_ECC_ERROR_DURING_FENCE_I\", \"D$ ECC error in data array during cache flush\")\n  982    s1_flush_valid := metaArb.io.in(5).fire() && !s1_flush_valid && !s2_flush_valid_pre_tag_ecc && release_state === s_ready && !release_ack_wait\n  983:   metaArb.io.in(5).valid := flushing && !flushed\n  984    metaArb.io.in(5).bits.write := false\n  985    metaArb.io.in(5).bits.idx := flushCounter(idxBits-1, 0)\n  ...\n 1012      }\n 1013    }\n 1014:   metaArb.io.in(0).valid := resetting\n 1015    metaArb.io.in(0).bits := metaArb.io.in(5).bits\n 1016    metaArb.io.in(0).bits.write := true\n ....\n 1029      io.ptw.customCSRs.disableDCacheClockGate ||\n 1030      io.cpu.keep_clock_enabled ||\n 1031:     metaArb.io.out.valid || // subsumes resetting || flushing\n 1032      s1_probe || s2_probe ||\n 1033      s1_valid || s2_valid ||\n 1034:     tlb_port.req.valid ||\n 1035      s1_tlb_req_valid || s2_tlb_req_valid ||\n 1036      pstore1_held || pstore2_valid ||\n ....\n 1044    io.cpu.perf.acquire := edge.done(tl_out_a)\n 1045    io.cpu.perf.release := edge.done(tl_out_c)\n 1046:   io.cpu.perf.grant := tl_out.d.valid && d_last\n 1047    io.cpu.perf.tlbMiss := io.ptw.req.fire()\n 1048    io.cpu.perf.storeBufferEmptyAfterLoad := !(\n ....\n 1067        case _: CreditedCrossing     => 1 // likewise\n 1068      }\n 1069:     val near_end_of_refill = if (cacheBlockBytes / beatBytes <= beatsBeforeEnd) tl_out.d.valid else {\n 1070        val refill_count = RegInit(0.U((cacheBlockBytes / beatBytes).log2.W))\n 1071        when (tl_out.d.fire() && grantIsRefill) { refill_count := refill_count + 1 }\n ....\n 1084    {\n 1085      val error_addr =\n 1086:       Mux(metaArb.io.in(1).valid, Cat(s2_first_meta_corrected.tag, metaArb.io.in(1).bits.addr(tagLSB-1, idxLSB)),\n 1087            data_error_addr >> idxLSB) << idxLSB\n 1088      io.errors.uncorrectable.foreach { u =>\n 1089:       u.valid := metaArb.io.in(1).valid && s2_meta_error_uncorrectable || data_error && data_error_uncorrectable\n 1090        u.bits := error_addr\n 1091      }\n 1092      io.errors.correctable.foreach { c =>\n 1093:       c.valid := metaArb.io.in(1).valid || data_error\n 1094        c.bits := error_addr\n 1095:       io.errors.uncorrectable.foreach { u => when (u.valid) { c.valid := false } }\n 1096      }\n 1097:     io.errors.bus.valid := tl_out.d.fire() && (tl_out.d.bits.denied || tl_out.d.bits.corrupt)\n 1098      io.errors.bus.bits := Mux(grantIsCached, s2_req.addr >> idxLSB << idxLSB, 0.U)\n 1099  \n 1100:     ccoverNotScratchpad(io.errors.bus.valid && grantIsCached, \"D_ERROR_CACHED\", \"D$ D-channel error, cached\")\n 1101:     ccover(io.errors.bus.valid && !grantIsCached, \"D_ERROR_UNCACHED\", \"D$ D-channel error, uncached\")\n 1102    }\n 1103  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/Frontend.scala:\n   47    val might_request = Bool(OUTPUT)\n   48    val clock_enabled = Bool(INPUT)\n   49:   val req = Valid(new FrontendReq)\n   50:   val sfence = Valid(new SFenceReq)\n   51    val resp = Decoupled(new FrontendResp).flip\n   52:   val btb_update = Valid(new BTBUpdate)\n   53:   val bht_update = Valid(new BHTUpdate)\n   54:   val ras_update = Valid(new RASUpdate)\n   55    val flush_icache = Bool(OUTPUT)\n   56    val npc = UInt(INPUT, width = vaddrBitsExtended)\n   ..\n   82    require(fetchWidth*coreInstBytes == outer.icacheParams.fetchBytes)\n   83  \n   84:   val fq = withReset(reset || io.cpu.req.valid) { Module(new ShiftQueue(new FrontendResp, 5, flow = true)) }\n   85  \n   86    val clock_en_reg = Reg(Bool())\n   87    val clock_en = clock_en_reg || io.cpu.might_request\n   88    io.cpu.clock_enabled := clock_en\n   89:   assert(!(io.cpu.req.valid || io.cpu.sfence.valid || io.cpu.flush_icache || io.cpu.bht_update.valid || io.cpu.btb_update.valid) || io.cpu.might_request)\n   90    val gated_clock =\n   91      if (!rocketParams.clockGate) clock\n   ..\n  104      (!fq.io.mask(fq.io.mask.getWidth-2) && (!s1_valid || !s2_valid)) ||\n  105      (!fq.io.mask(fq.io.mask.getWidth-1) && (!s1_valid && !s2_valid))\n  106:   val s0_valid = io.cpu.req.valid || s0_fq_has_space\n  107    s1_valid := s0_valid\n  108    val s1_pc = Reg(UInt(width=vaddrBitsExtended))\n  ...\n  134      if (usingCompressed) s1_speculative || s2_valid && !s2_speculative || predicted_taken\n  135      else Bool(true)\n  136:   s1_speculative := Mux(io.cpu.req.valid, io.cpu.req.bits.speculative, Mux(s2_replay, s2_speculative, s0_speculative))\n  137  \n  138:   val s2_redirect = Wire(init = io.cpu.req.valid)\n  139    s2_valid := false\n  140    when (!s2_replay) {\n  ...\n  146  \n  147    io.ptw <> tlb.io.ptw\n  148:   tlb.io.req.valid := s1_valid && !s2_replay\n  149    tlb.io.req.bits.vaddr := s1_pc\n  150    tlb.io.req.bits.passthrough := Bool(false)\n  ...\n  153    tlb.io.kill := !s2_valid\n  154  \n  155:   icache.io.req.valid := s0_valid\n  156    icache.io.req.bits.addr := io.cpu.npc\n  157    icache.io.invalidate := io.cpu.flush_icache\n  ...\n  163    icache.io.s2_prefetch := s2_tlb_resp.prefetchable && !io.ptw.customCSRs.asInstanceOf[RocketCustomCSRs].disableICachePrefetch\n  164  \n  165:   fq.io.enq.valid := RegNext(s1_valid) && s2_valid && (icache.io.resp.valid || !s2_tlb_resp.miss && icache.io.s2_kill)\n  166    fq.io.enq.bits.pc := s2_pc\n  167:   io.cpu.npc := alignPC(Mux(io.cpu.req.valid, io.cpu.req.bits.pc, npc))\n  168  \n  169    fq.io.enq.bits.data := icache.io.resp.bits.data\n  170    fq.io.enq.bits.mask := UInt((1 << fetchWidth)-1) << s2_pc.extract(log2Ceil(fetchWidth)+log2Ceil(coreInstBytes)-1, log2Ceil(coreInstBytes))\n  171:   fq.io.enq.bits.replay := icache.io.resp.bits.replay || icache.io.s2_kill && !icache.io.resp.valid && !s2_xcpt\n  172    fq.io.enq.bits.btb := s2_btb_resp_bits\n  173    fq.io.enq.bits.btb.taken := s2_btb_taken\n  174    fq.io.enq.bits.xcpt := s2_tlb_resp\n  175    assert(!(s2_speculative && io.ptw.customCSRs.asInstanceOf[RocketCustomCSRs].disableSpeculativeICacheRefill && !icache.io.s2_kill))\n  176:   when (icache.io.resp.valid && icache.io.resp.bits.ae) { fq.io.enq.bits.xcpt.ae.inst := true }\n  177  \n  178    if (usingBTB) {\n  179      val btb = Module(new BTB)\n  180      btb.io.flush := false\n  181:     btb.io.req.valid := false\n  182      btb.io.req.bits.addr := s1_pc\n  183      btb.io.btb_update := io.cpu.btb_update\n  184      btb.io.bht_update := io.cpu.bht_update\n  185:     btb.io.ras_update.valid := false\n  186:     btb.io.bht_advance.valid := false\n  187      when (!s2_replay) {\n  188:       btb.io.req.valid := !s2_redirect\n  189:       s2_btb_resp_valid := btb.io.resp.valid\n  190        s2_btb_resp_bits := btb.io.resp.bits\n  191      }\n  192:     when (btb.io.resp.valid && btb.io.resp.bits.taken) {\n  193        predicted_npc := btb.io.resp.bits.target.sextTo(vaddrBitsExtended)\n  194        predicted_taken := Bool(true)\n  ...\n  197      val force_taken = io.ptw.customCSRs.bpmStatic\n  198      when (io.ptw.customCSRs.flushBTB) { btb.io.flush := true }\n  199:     when (force_taken) { btb.io.bht_update.valid := false }\n  200  \n  201      val s2_base_pc = ~(~s2_pc | (fetchBytes-1))\n  ...\n  208        def insnIsRVC(bits: UInt) = bits(1,0) =/= 3\n  209        val prevRVI = prevValid && !insnIsRVC(prevBits)\n  210:       val valid = fq.io.enq.bits.mask(idx) && !prevRVI\n  211        val bits = fq.io.enq.bits.data(coreInstBits*(idx+1)-1, coreInstBits*idx)\n  212        val rvc = insnIsRVC(bits)\n  ...\n  229        val taken =\n  230          prevRVI && (rviJump || rviJALR || rviBranch && predict_taken) ||\n  231:         valid && (rvcJump || rvcJALR || rvcJR || rvcBranch && predict_taken)\n  232:       val predictReturn = btb.io.ras_head.valid && (prevRVI && rviReturn || valid && rvcReturn)\n  233:       val predictJump = prevRVI && rviJump || valid && rvcJump\n  234:       val predictBranch = predict_taken && (prevRVI && rviBranch || valid && rvcBranch)\n  235  \n  236:       when (s2_valid && s2_btb_resp_valid && s2_btb_resp_bits.bridx === idx && valid && !rvc) {\n  237          // The BTB has predicted that the middle of an RVI instruction is\n  238          // a branch! Flush the BTB and the pipeline.\n  ...\n  246          taken_idx := idx\n  247          after_idx := idx + 1\n  248:         btb.io.ras_update.valid := fq.io.enq.fire() && !wrong_path && (prevRVI && (rviCall || rviReturn) || valid && (rvcCall || rvcReturn))\n  249          btb.io.ras_update.bits.cfiType := Mux(Mux(prevRVI, rviReturn, rvcReturn), CFIType.ret,\n  250                                            Mux(Mux(prevRVI, rviCall, rvcCall), CFIType.call,\n  ...\n  267            }\n  268          }\n  269:         when (prevRVI && rviBranch || valid && rvcBranch) {\n  270:           btb.io.bht_advance.valid := fq.io.enq.fire() && !wrong_path\n  271            btb.io.bht_advance.bits := s2_btb_resp_bits\n  272          }\n  ...\n  279          when (fq.io.enq.fire()) {\n  280            s2_partial_insn_valid := false\n  281:           when (valid && !prevTaken && !rvc) {\n  282              s2_partial_insn_valid := true\n  283              s2_partial_insn := bits | 0x3\n  ...\n  286          prevTaken || taken\n  287        } else {\n  288:         scanInsns(idx + 1, valid, bits, prevTaken || taken)\n  289        }\n  290      }\n  291  \n  292:     when (!io.cpu.btb_update.valid) {\n  293        val fetch_bubble_likely = !fq.io.mask(1)\n  294:       btb.io.btb_update.valid := fq.io.enq.fire() && !wrong_path && fetch_bubble_likely && updateBTB\n  295        btb.io.btb_update.bits.prediction.entry := UInt(tileParams.btb.get.nEntries)\n  296        btb.io.btb_update.bits.isValid := true\n  ...\n  320      assert(!s2_partial_insn_valid || fq.io.enq.bits.mask(0))\n  321      when (s2_redirect) { s2_partial_insn_valid := false }\n  322:     when (io.cpu.req.valid) { wrong_path := false }\n  323    }\n  324  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/HellaCache.scala:\n  172    val s2_paddr = UInt(INPUT, paddrBits) // translated address\n  173  \n  174:   val resp = Valid(new HellaCacheResp).flip\n  175    val replay_next = Bool(INPUT)\n  176    val s2_xcpt = (new HellaCacheExceptions).asInput\n  ...\n  321    val metabits = rstVal.getWidth\n  322    val tag_array = SeqMem(nSets, Vec(nWays, UInt(width = metabits)))\n  323:   val wen = rst || io.write.valid\n  324    when (wen) {\n  325      tag_array.write(waddr, Vec.fill(nWays)(wdata), wmask)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/HellaCacheArbiter.scala:\n   22      io.mem.keep_clock_enabled := io.requestor.map(_.keep_clock_enabled).reduce(_||_)\n   23  \n   24:     io.mem.req.valid := io.requestor.map(_.req.valid).reduce(_||_)\n   25      io.requestor(0).req.ready := io.mem.req.ready\n   26      for (i <- 1 until n)\n   27:       io.requestor(i).req.ready := io.requestor(i-1).req.ready && !io.requestor(i-1).req.valid\n   28  \n   29      for (i <- n-1 to 0 by -1) {\n   ..\n   47          connect_s2()\n   48        } else {\n   49:         when (req.valid) { connect_s0() }\n   50          when (s1_id === UInt(i)) { connect_s1() }\n   51          when (s2_id === UInt(i)) { connect_s2() }\n   ..\n   58        val resp = io.requestor(i).resp\n   59        val tag_hit = io.mem.resp.bits.tag(log2Up(n)-1,0) === UInt(i)\n   60:       resp.valid := io.mem.resp.valid && tag_hit\n   61        io.requestor(i).s2_xcpt := io.mem.s2_xcpt\n   62        io.requestor(i).ordered := io.mem.ordered\n   ..\n   74        io.requestor(i).uncached_resp.map { uncached_resp =>\n   75          val uncached_tag_hit = io.mem.uncached_resp.get.bits.tag(log2Up(n)-1,0) === UInt(i)\n   76:         uncached_resp.valid := io.mem.uncached_resp.get.valid && uncached_tag_hit\n   77          when (uncached_resp.ready && uncached_tag_hit) {\n   78            io.mem.uncached_resp.get.ready := true.B\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/IBuf.scala:\n   41    val nIC = Mux(io.imem.bits.btb.taken, io.imem.bits.btb.bridx +& 1, UInt(fetchWidth)) - pcWordBits\n   42    val nICReady = nReady - nBufValid\n   43:   val nValid = Mux(io.imem.valid, nIC, UInt(0)) + nBufValid\n   44    io.imem.ready := io.inst(0).ready && nReady >= nBufValid && (nICReady >= nIC || n >= nIC - nICReady)\n   45  \n   ..\n   52          buf.pc := buf.pc & ~pcWordMask | (buf.pc + (nReady << log2Ceil(coreInstBytes))) & pcWordMask\n   53        }\n   54:       when (io.imem.valid && nReady >= nBufValid && nICReady < nIC && n >= nIC - nICReady) {\n   55          val shamt = pcWordBits + nICReady\n   56          nBufValid := nIC - nICReady\n   ..\n   72    val inst = icData & icMask | buf.data & ~icMask\n   73  \n   74:   val valid = (UIntToOH(nValid) - 1)(fetchWidth-1, 0)\n   75    val bufMask = UIntToOH(nBufValid) - 1\n   76    val xcpt = (0 until bufMask.getWidth).map(i => Mux(bufMask(i), buf.xcpt, io.imem.bits.xcpt))\n   77    val buf_replay = Mux(buf.replay, bufMask, UInt(0))\n   78:   val ic_replay = buf_replay | Mux(io.imem.bits.replay, valid & ~bufMask, UInt(0))\n   79:   assert(!io.imem.valid || !io.imem.bits.btb.taken || io.imem.bits.btb.bridx >= pcWordBits)\n   80  \n   81    io.btb_resp := io.imem.bits.btb\n   ..\n   91      if (usingCompressed) {\n   92        val replay = ic_replay(j) || (!exp.io.rvc && ic_replay(j+1))\n   93:       val full_insn = exp.io.rvc || valid(j+1) || buf_replay(j)\n   94:       io.inst(i).valid := valid(j) && full_insn\n   95        io.inst(i).bits.xcpt0 := xcpt(j)\n   96        io.inst(i).bits.xcpt1 := Mux(exp.io.rvc, 0.U, xcpt(j+1).asUInt).asTypeOf(new FrontendExceptions)\n   ..\n  105      } else {\n  106        when (i == 0 || io.inst(i).ready) { nReady := i+1 }\n  107:       io.inst(i).valid := valid(i)\n  108        io.inst(i).bits.xcpt0 := xcpt(i)\n  109        io.inst(i).bits.xcpt1 := 0.U.asTypeOf(new FrontendExceptions)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/ICache.scala:\n   49      with HasL1ICacheParameters\n   50      with CanHaveErrors {\n   51:   val correctable = (cacheParams.tagCode.canDetect || cacheParams.dataCode.canDetect).option(Valid(UInt(width = paddrBits)))\n   52:   val uncorrectable = (cacheParams.itimAddr.nonEmpty && cacheParams.dataCode.canDetect).option(Valid(UInt(width = paddrBits)))\n   53:   val bus = Valid(UInt(width = paddrBits))\n   54  }\n   55  \n   ..\n  120    val s2_prefetch = Bool(INPUT) // should I$ prefetch next line on a miss?\n  121  \n  122:   val resp = Valid(new ICacheResp(outer))\n  123    val invalidate = Bool(INPUT)\n  124  \n  ...\n  226      ccover(refillError, \"D_CORRUPT\", \"I$ D-channel corrupt\")\n  227    }\n  228:   io.errors.bus.valid := tl_out.d.fire() && (tl_out.d.bits.denied || tl_out.d.bits.corrupt)\n  229    io.errors.bus.bits  := (refill_paddr >> blockOffBits) << blockOffBits\n  230  \n  ...\n  328        io.resp.bits.data := Mux1H(s1_tag_hit, s1_dout)\n  329        io.resp.bits.ae := s1_tl_error.asUInt.orR\n  330:       io.resp.valid := s1_valid && s1_hit\n  331  \n  332      case 2 =>\n  ...\n  337        io.resp.bits.ae := s2_tl_error\n  338        io.resp.bits.replay := s2_disparity\n  339:       io.resp.valid := s2_valid && s2_hit\n  340  \n  341        io.errors.correctable.foreach { c =>\n  342:         c.valid := (s2_valid || s2_slaveValid) && s2_disparity && !s2_report_uncorrectable_error\n  343          c.bits := s2_error_addr\n  344        }\n  345        io.errors.uncorrectable.foreach { u =>\n  346:         u.valid := s2_report_uncorrectable_error\n  347          u.bits := s2_error_addr\n  348        }\n  ...\n  350        tl_in.map { tl =>\n  351          val respValid = RegInit(false.B)\n  352:         tl.a.ready := !(tl_out.d.valid || s1_slaveValid || s2_slaveValid || s3_slaveValid || respValid || !io.clock_enabled)\n  353          val s1_a = RegEnable(tl.a.bits, s0_slaveValid)\n  354          s1s2_full_word_write := edge_in.get.hasData(s1_a) && s1_a.mask.andR\n  ...\n  379  \n  380          assert(!s2_valid || RegNext(RegNext(s0_vaddr)) === io.s2_vaddr)\n  381:         when (!(tl.a.valid || s1_slaveValid || s2_slaveValid || respValid)\n  382                && s2_valid && s2_data_decoded.error && !s2_tag_disparity) {\n  383            // handle correctable errors on CPU accesses to the scratchpad.\n  ...\n  398          }\n  399  \n  400:         tl.d.valid := respValid\n  401          tl.d.bits := Mux(edge_in.get.hasData(s1_a),\n  402            edge_in.get.AccessAck(s1_a),\n  ...\n  405  \n  406          // Tie off unused channels\n  407:         tl.b.valid := false\n  408          tl.c.ready := true\n  409          tl.e.ready := true\n  ...\n  411          ccover(s0_valid && s1_slaveValid, \"CONCURRENT_ITIM_ACCESS_1\", \"ITIM accessed, then I$ accessed next cycle\")\n  412          ccover(s0_valid && s2_slaveValid, \"CONCURRENT_ITIM_ACCESS_2\", \"ITIM accessed, then I$ accessed two cycles later\")\n  413:         ccover(tl.d.valid && !tl.d.ready, \"ITIM_D_STALL\", \"ITIM response blocked by D-channel\")\n  414:         ccover(tl_out.d.valid && !tl_out.d.ready, \"ITIM_BLOCK_D\", \"D-channel blocked by ITIM access\")\n  415        }\n  416    }\n  417  \n  418:   tl_out.a.valid := s2_request_refill\n  419    tl_out.a.bits := edge_out.Get(\n  420                      fromSource = UInt(0),\n  ...\n  439  \n  440      when (send_hint) {\n  441:       tl_out.a.valid := true\n  442        tl_out.a.bits := edge_out.Hint(\n  443                          fromSource = UInt(1),\n  ...\n  470    }\n  471    tl_out.b.ready := Bool(true)\n  472:   tl_out.c.valid := Bool(false)\n  473:   tl_out.e.valid := Bool(false)\n  474:   assert(!(tl_out.a.valid && addrMaybeInScratchpad(tl_out.a.bits.address)))\n  475  \n  476    when (!refill_valid) { invalidated := false.B }\n  ...\n  480    io.perf.acquire := refill_fire\n  481    io.keep_clock_enabled :=\n  482:     tl_in.map(tl => tl.a.valid || tl.d.valid || s1_slaveValid || s2_slaveValid || s3_slaveValid).getOrElse(false.B) || // ITIM\n  483      s1_valid || s2_valid || refill_valid || send_hint || hint_outstanding // I$\n  484  \n  ...\n  489    }\n  490  \n  491:   ccover(!send_hint && (tl_out.a.valid && !tl_out.a.ready), \"MISS_A_STALL\", \"I$ miss blocked by A-channel\")\n  492    ccover(invalidate && refill_valid, \"FLUSH_DURING_MISS\", \"I$ flushed during miss\")\n  493  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/Multiplier.scala:\n    5  \n    6  import chisel3._\n    7: import chisel3.util.{Cat, log2Up, log2Ceil, log2Floor, Log2, Decoupled, Enum, Fill, Valid, Pipe}\n    8  import Chisel.ImplicitConversions._\n    9  import freechips.rocketchip.util._\n   ..\n  180  \n  181    io.resp.bits.data := Cat(hiOut, loOut)\n  182:   io.resp.valid := (state === s_done_mul || state === s_done_div)\n  183    io.req.ready := state === s_ready\n  184  }\n  ...\n  186  class PipelinedMultiplier(width: Int, latency: Int, nXpr: Int = 32) extends Module with ShouldBeRetimed {\n  187    val io = IO(new Bundle {\n  188:     val req = Flipped(Valid(new MultiplierReq(width, log2Ceil(nXpr))))\n  189:     val resp = Valid(new MultiplierResp(width, log2Ceil(nXpr)))\n  190    })\n  191  \n  ...\n  207  \n  208    val resp = Pipe(in, latency-1)\n  209:   io.resp.valid := resp.valid\n  210    io.resp.bits.tag := resp.bits.tag\n  211:   io.resp.bits.data := Pipe(in.valid, muxed, latency-1).bits\n  212  }\n  213  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/NBDcache.scala:\n   57      val resp = Decoupled(new HellaCacheResp)\n   58      val mem_access = Decoupled(new TLBundleA(edge.bundle))\n   59:     val mem_ack = Valid(new TLBundleD(edge.bundle)).flip\n   60      val replay_next = Bool(OUTPUT)\n   61    }\n   ..\n  102    assert(state === s_idle || req.cmd =/= M_XSC)\n  103  \n  104:   io.mem_access.valid := (state === s_mem_access)\n  105    io.mem_access.bits := Mux(isAMO(req.cmd), atomics, Mux(isRead(req.cmd), get, put))\n  106  \n  107:   io.replay_next := (state === s_mem_ack) || io.resp.valid && !io.resp.ready\n  108:   io.resp.valid := (state === s_resp)\n  109    io.resp.bits := req\n  110    io.resp.bits.has_data := isRead(req.cmd)\n  ...\n  122    }\n  123  \n  124:   when (state === s_mem_ack && io.mem_ack.valid) {\n  125      state := s_resp\n  126      when (isRead(req.cmd)) {\n  ...\n  146  \n  147      val mem_acquire  = Decoupled(new TLBundleA(edge.bundle))\n  148:     val mem_grant = Valid(new TLBundleD(edge.bundle)).flip\n  149      val mem_finish = Decoupled(new TLBundleE(edge.bundle))\n  150  \n  ...\n  185  \n  186    val rpq = Module(new Queue(new ReplayInternal, cfg.nRPQ))\n  187:   rpq.io.enq.valid := (io.req_pri_val && io.req_pri_rdy || io.req_sec_val && sec_rdy) && !isPrefetch(io.req_bits.cmd)\n  188    rpq.io.enq.bits := io.req_bits\n  189    rpq.io.deq.ready := (io.replay.ready && state === s_drain_rpq) || state === s_invalid\n  190  \n  191    val acked = Reg(Bool())\n  192:   when (io.mem_grant.valid) { acked := true }\n  193  \n  194:   when (state === s_drain_rpq && !rpq.io.deq.valid) {\n  195      state := s_invalid\n  196    }\n  ...\n  249    val grantackq = Module(new Queue(io.mem_finish.bits, 1))\n  250    val can_finish = state.isOneOf(s_invalid, s_refill_req)\n  251:   grantackq.io.enq.valid := refill_done && edge.isRequest(io.mem_grant.bits)\n  252    grantackq.io.enq.bits := edge.GrantAck(io.mem_grant.bits)\n  253:   io.mem_finish.valid := grantackq.io.deq.valid && can_finish\n  254    io.mem_finish.bits := grantackq.io.deq.bits\n  255    grantackq.io.deq.ready := io.mem_finish.ready && can_finish\n  ...\n  267    io.probe_rdy := !idx_match || (!state.isOneOf(states_before_refill) && meta_hazard === 0) \n  268  \n  269:   io.meta_write.valid := state.isOneOf(s_meta_write_req, s_meta_clear)\n  270    io.meta_write.bits.idx := req_idx\n  271    io.meta_write.bits.data.coh := Mux(state === s_meta_clear, coh_on_clear, new_coh)\n  ...\n  273    io.meta_write.bits.way_en := req.way_en\n  274  \n  275:   io.wb_req.valid := state === s_wb_req\n  276    io.wb_req.bits.source := UInt(id)\n  277    io.wb_req.bits.tag := req.old_meta.tag\n  ...\n  281    io.wb_req.bits.voluntary := Bool(true)\n  282  \n  283:   io.mem_acquire.valid := state === s_refill_req && grantackq.io.enq.ready\n  284    io.mem_acquire.bits := edge.AcquireBlock(\n  285                                  fromSource = UInt(id),\n  ...\n  288                                  growPermissions = grow_param)._2\n  289  \n  290:   io.meta_read.valid := state === s_drain_rpq\n  291    io.meta_read.bits.idx := req_idx\n  292    io.meta_read.bits.tag := io.tag\n  293  \n  294:   io.replay.valid := state === s_drain_rpq && rpq.io.deq.valid\n  295    io.replay.bits := rpq.io.deq.bits\n  296    io.replay.bits.phys := Bool(true)\n  ...\n  310  \n  311      val mem_acquire  = Decoupled(new TLBundleA(edge.bundle))\n  312:     val mem_grant = Valid(new TLBundleD(edge.bundle)).flip\n  313      val mem_finish = Decoupled(new TLBundleE(edge.bundle))\n  314  \n  ...\n  330    val sdq_alloc_id = PriorityEncoder(~sdq_val(cfg.nSDQ-1,0))\n  331    val sdq_rdy = !sdq_val.andR\n  332:   val sdq_enq = io.req.valid && io.req.ready && cacheable && isWrite(io.req.bits.cmd)\n  333    val sdq = Mem(cfg.nSDQ, io.req.bits.data)\n  334    when (sdq_enq) { sdq(sdq_alloc_id) := io.req.bits.data }\n  ...\n  360      wbTagList(i) := mshr.io.wb_req.bits.tag\n  361  \n  362:     alloc_arb.io.in(i).valid := mshr.io.req_pri_rdy\n  363      mshr.io.req_pri_val := alloc_arb.io.in(i).ready\n  364  \n  365:     mshr.io.req_sec_val := io.req.valid && sdq_rdy && tag_match\n  366      mshr.io.req_bits := io.req.bits\n  367      mshr.io.req_bits.sdq_id := sdq_alloc_id\n  ...\n  372      replay_arb.io.in(i) <> mshr.io.replay\n  373  \n  374:     mshr.io.mem_grant.valid := io.mem_grant.valid && io.mem_grant.bits.source === UInt(i)\n  375      mshr.io.mem_grant.bits := io.mem_grant.bits\n  376      refillMux(i) := mshr.io.refill\n  ...\n  387  \n  388  \n  389:   alloc_arb.io.out.ready := io.req.valid && sdq_rdy && cacheable && !idx_match\n  390  \n  391    io.meta_read <> meta_read_arb.io.out\n  ...\n  403      val mshr = Module(new IOMSHR(id))\n  404  \n  405:     mmio_alloc_arb.io.in(i).valid := mshr.io.req.ready\n  406:     mshr.io.req.valid := mmio_alloc_arb.io.in(i).ready\n  407      mshr.io.req.bits := io.req.bits\n  408  \n  ...\n  410  \n  411      mshr.io.mem_ack.bits := io.mem_grant.bits\n  412:     mshr.io.mem_ack.valid := io.mem_grant.valid && io.mem_grant.bits.source === UInt(id)\n  413  \n  414      resp_arb.io.in(i) <> mshr.io.resp\n  ...\n  420    }\n  421  \n  422:   mmio_alloc_arb.io.out.ready := io.req.valid && !cacheable\n  423  \n  424    TLArbiter.lowestFromSeq(edge, io.mem_acquire, mshrs.map(_.io.mem_acquire) ++ mmios.map(_.io.mem_access))\n  ...\n  436    io.replay <> replay_arb.io.out\n  437  \n  438:   when (io.replay.valid || sdq_enq) {\n  439      sdq_val := sdq_val & ~(UIntToOH(replay_arb.io.out.bits.sdq_id) & Fill(cfg.nSDQ, free_sdq)) |\n  440                 PriorityEncoderOH(~sdq_val(cfg.nSDQ-1,0)) & Fill(cfg.nSDQ, sdq_enq)\n  ...\n  458    val (_, last_beat, all_beats_done, beat_count) = edge.count(io.release)\n  459  \n  460:   io.release.valid := false\n  461    when (active) {\n  462      r1_data_req_fired := false\n  ...\n  467      }\n  468      when (r2_data_req_fired) {\n  469:       io.release.valid := true\n  470        when(!io.release.ready) {\n  471          r1_data_req_fired := false\n  ...\n  490  \n  491    // We reissue the meta read as it sets up the mux ctrl for s2_data_muxed\n  492:   io.meta_read.valid := fire\n  493    io.meta_read.bits.idx := req.idx\n  494    io.meta_read.bits.tag := req.tag\n  495  \n  496:   io.data_req.valid := fire\n  497    io.data_req.bits.way_en := req.way_en\n  498    io.data_req.bits.addr := (if(refillCycles > 1) \n  ...\n  547  \n  548    io.req.ready := state === s_invalid\n  549:   io.rep.valid := state === s_release\n  550    io.rep.bits := edge.ProbeAck(req, report_param)\n  551  \n  552:   assert(!io.rep.valid || !edge.hasData(io.rep.bits),\n  553      \"ProbeUnit should not send ProbeAcks with data, WritebackUnit should handle it\")\n  554  \n  555:   io.meta_read.valid := state === s_meta_read\n  556    io.meta_read.bits.idx := req_idx\n  557    io.meta_read.bits.tag := req_tag\n  558  \n  559:   io.meta_write.valid := state === s_meta_write\n  560    io.meta_write.bits.way_en := way_en\n  561    io.meta_write.bits.idx := req_idx\n  ...\n  563    io.meta_write.bits.data.coh := new_coh\n  564  \n  565:   io.wb_req.valid := state === s_writeback_req\n  566    io.wb_req.bits.source := req.source\n  567    io.wb_req.bits.idx := req_idx\n  ...\n  632        val rway_en = io.read.bits.way_en(w+rowWords-1,w)\n  633        val resp = Wire(Vec(rowWords, Bits(width = encRowBits)))\n  634:       val r_raddr = RegEnable(io.read.bits.addr, io.read.valid)\n  635        for (i <- 0 until resp.size) {\n  636          val (array, omSRAM) = DescribedSRAM(\n  ...\n  640            data = Vec(rowWords, Bits(width=encDataBits))\n  641          )\n  642:         when (wway_en.orR && io.write.valid && io.write.bits.wmask(i)) {\n  643            val data = Vec.fill(rowWords)(io.write.bits.data(encDataBits*(i+1)-1,encDataBits*i))\n  644            array.write(waddr, data, wway_en.asBools)\n  645          }\n  646:         resp(i) := array.read(raddr, rway_en.orR && io.read.valid).asUInt\n  647        }\n  648        for (dw <- 0 until rowWords) {\n  ...\n  662          data = Vec(rowWords, Bits(width=encDataBits))\n  663        )\n  664:       when (io.write.bits.way_en(w) && io.write.valid) {\n  665          val data = Vec.tabulate(rowWords)(i => io.write.bits.data(encDataBits*(i+1)-1,encDataBits*i))\n  666          array.write(waddr, data, io.write.bits.wmask.asBools)\n  667        }\n  668:       io.resp(w) := array.read(raddr, io.read.bits.way_en(w) && io.read.valid).asUInt\n  669      }\n  670    }\n  ...\n  722    io.ptw <> dtlb.io.ptw\n  723    dtlb.io.kill := io.cpu.s2_kill\n  724:   dtlb.io.req.valid := s1_valid && !io.cpu.s1_kill && s1_readwrite\n  725    dtlb.io.req.bits.passthrough := s1_req.phys\n  726    dtlb.io.req.bits.vaddr := s1_req.addr\n  ...\n  729    when (!dtlb.io.req.ready && !io.cpu.req.bits.phys) { io.cpu.req.ready := Bool(false) }\n  730  \n  731:   dtlb.io.sfence.valid := s1_valid && !io.cpu.s1_kill && s1_sfence\n  732    dtlb.io.sfence.bits.rs1 := s1_req.size(0)\n  733    dtlb.io.sfence.bits.rs2 := s1_req.size(1)\n  ...\n  735    dtlb.io.sfence.bits.asid := io.cpu.s1_data.data\n  736    \n  737:   when (io.cpu.req.valid) {\n  738      s1_req := io.cpu.req.bits\n  739    }\n  740:   when (wb.io.meta_read.valid) {\n  741      s1_req.addr := Cat(wb.io.meta_read.bits.tag, wb.io.meta_read.bits.idx) << blockOffBits\n  742      s1_req.phys := Bool(true)\n  743    }\n  744:   when (prober.io.meta_read.valid) {\n  745      s1_req.addr := Cat(prober.io.meta_read.bits.tag, prober.io.meta_read.bits.idx) << blockOffBits\n  746      s1_req.phys := Bool(true)\n  747    }\n  748:   when (mshrs.io.replay.valid) {\n  749      s1_req := mshrs.io.replay.bits\n  750    }\n  ...\n  779    val readArb = Module(new Arbiter(new L1DataReadReq, 4))\n  780    val writeArb = Module(new Arbiter(new L1DataWriteReq, 2))\n  781:   data.io.write.valid := writeArb.io.out.valid\n  782    writeArb.io.out.ready := data.io.write.ready\n  783    data.io.write.bits := writeArb.io.out.bits\n  ...\n  786  \n  787    // tag read for new requests\n  788:   metaReadArb.io.in(4).valid := io.cpu.req.valid\n  789    metaReadArb.io.in(4).bits.idx := io.cpu.req.bits.addr >> blockOffBits\n  790    when (!metaReadArb.io.in(4).ready) { io.cpu.req.ready := Bool(false) }\n  791  \n  792    // data read for new requests\n  793:   readArb.io.in(3).valid := io.cpu.req.valid\n  794    readArb.io.in(3).bits.addr := io.cpu.req.bits.addr\n  795    readArb.io.in(3).bits.way_en := ~UInt(0, nWays)\n  ...\n  797  \n  798    // recycled requests\n  799:   metaReadArb.io.in(0).valid := s2_recycle\n  800    metaReadArb.io.in(0).bits.idx := s2_req.addr >> blockOffBits\n  801:   readArb.io.in(0).valid := s2_recycle\n  802    readArb.io.in(0).bits.addr := s2_req.addr\n  803    readArb.io.in(0).bits.way_en := ~UInt(0, nWays)\n  ...\n  807    val s1_tag_eq_way = wayMap((w: Int) => meta.io.resp(w).tag === (s1_addr >> untagBits)).asUInt\n  808    val s1_tag_match_way = wayMap((w: Int) => s1_tag_eq_way(w) && meta.io.resp(w).coh.isValid()).asUInt\n  809:   s1_clk_en := metaReadArb.io.out.valid //TODO: should be metaReadArb.io.out.fire(), but triggers Verilog backend bug\n  810    val s1_writeback = s1_clk_en && !s1_valid && !s1_replay\n  811    val s2_tag_match_way = RegEnable(s1_tag_match_way, s1_clk_en)\n  ...\n  865    writeArb.io.in(0).bits.wmask := UIntToOH(s3_req.addr.extract(rowOffBits-1,offsetlsb))\n  866    writeArb.io.in(0).bits.data := Fill(rowWords, s3_req.data)\n  867:   writeArb.io.in(0).valid := s3_valid\n  868    writeArb.io.in(0).bits.way_en :=  s3_way\n  869  \n  ...\n  875  \n  876    // miss handling\n  877:   mshrs.io.req.valid := s2_valid_masked && !s2_hit && (isPrefetch(s2_req.cmd) || isRead(s2_req.cmd) || isWrite(s2_req.cmd))\n  878    mshrs.io.req.bits := s2_req\n  879    mshrs.io.req.bits.tag_match := s2_tag_match\n  ...\n  885  \n  886    // replays\n  887:   readArb.io.in(1).valid := mshrs.io.replay.valid\n  888    readArb.io.in(1).bits := mshrs.io.replay.bits\n  889    readArb.io.in(1).bits.way_en := ~UInt(0, nWays)\n  890    mshrs.io.replay.ready := readArb.io.in(1).ready\n  891:   s1_replay := mshrs.io.replay.valid && readArb.io.in(1).ready\n  892    metaReadArb.io.in(1) <> mshrs.io.meta_read\n  893    metaWriteArb.io.in(0) <> mshrs.io.meta_write\n  894  \n  895    // probes and releases\n  896:   prober.io.req.valid := tl_out.b.valid && !lrsc_valid\n  897    tl_out.b.ready := prober.io.req.ready && !lrsc_valid\n  898    prober.io.req.bits := tl_out.b.bits\n  ...\n  905    // refills\n  906    val grant_has_data = edge.hasData(tl_out.d.bits)\n  907:   mshrs.io.mem_grant.valid := tl_out.d.fire()\n  908    mshrs.io.mem_grant.bits := tl_out.d.bits\n  909    tl_out.d.ready := writeArb.io.in(1).ready || !grant_has_data\n  ...\n  911     * the IOMSHRs from being written into the data array. It works because the\n  912     * IOMSHR ids start right the ones for the regular MSHRs. */\n  913:   writeArb.io.in(1).valid := tl_out.d.valid && grant_has_data &&\n  914                                 tl_out.d.bits.source < UInt(cfg.nMSHRs)\n  915    writeArb.io.in(1).bits.addr := mshrs.io.refill.addr\n  ...\n  918    writeArb.io.in(1).bits.data := tl_out.d.bits.data(encRowBits-1,0)\n  919    data.io.read <> readArb.io.out\n  920:   readArb.io.out.ready := !tl_out.d.valid || tl_out.d.ready // insert bubble if refill gets blocked\n  921    tl_out.e <> mshrs.io.mem_finish\n  922  \n  ...\n  933    // store->load bypassing\n  934    val s4_valid = Reg(next=s3_valid, init=Bool(false))\n  935:   val s4_req = RegEnable(s3_req, s3_valid && metaReadArb.io.out.valid)\n  936    val bypasses = List(\n  937      ((s2_valid_masked || s2_replay) && !s2_sc_fail, s2_req, amoalu.io.out),\n  ...\n  960  \n  961    // nack it like it's hot\n  962:   val s1_nack = dtlb.io.req.valid && dtlb.io.resp.miss || io.cpu.s2_nack ||\n  963                  s1_req.addr(idxMSB,idxLSB) === prober.io.meta_write.bits.idx && !prober.io.req.ready\n  964    val s2_nack_hit = RegEnable(s1_nack, s1_valid || s1_replay)\n  965:   when (s2_nack_hit) { mshrs.io.req.valid := Bool(false) }\n  966    val s2_nack_victim = s2_hit && mshrs.io.secondary_miss\n  967    val s2_nack_miss = !s2_hit && !mshrs.io.req.ready\n  ...\n  981    }\n  982  \n  983:   val cache_resp = Wire(Valid(new HellaCacheResp))\n  984:   cache_resp.valid := (s2_replay || s2_valid_masked && s2_hit) && !s2_data_correctable\n  985    cache_resp.bits := s2_req\n  986    cache_resp.bits.has_data := isRead(s2_req.cmd)\n  ...\n  989    cache_resp.bits.replay := s2_replay\n  990  \n  991:   val uncache_resp = Wire(Valid(new HellaCacheResp))\n  992    uncache_resp.bits := mshrs.io.resp.bits\n  993:   uncache_resp.valid := mshrs.io.resp.valid\n  994    mshrs.io.resp.ready := Reg(next= !(s1_valid || s1_replay))\n  995  \n  ...\n 1001    io.cpu.replay_next := (s1_replay && s1_read) || mshrs.io.replay_next\n 1002  \n 1003:   val s1_xcpt_valid = dtlb.io.req.valid && !s1_nack\n 1004    val s1_xcpt = dtlb.io.resp\n 1005    io.cpu.s2_xcpt := Mux(RegNext(s1_xcpt_valid), RegEnable(s1_xcpt, s1_clk_en), 0.U.asTypeOf(s1_xcpt))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/PTW.scala:\n   32  class TLBPTWIO(implicit p: Parameters) extends CoreBundle()(p)\n   33      with HasCoreParameters {\n   34:   val req = Decoupled(Valid(new PTWReq))\n   35:   val resp = Valid(new PTWResp).flip\n   36    val ptbr = new PTBR().asInput\n   37    val status = new MStatus().asInput\n   ..\n   50      with HasCoreParameters {\n   51    val ptbr = new PTBR().asInput\n   52:   val sfence = Valid(new SFenceReq).flip\n   53    val status = new MStatus().asInput\n   54    val pmp = Vec(nPMPs, new PMP).asInput\n   ..\n  110    val l2_refill_wire = Wire(Bool())\n  111  \n  112:   val arb = Module(new Arbiter(Valid(new PTWReq), n))\n  113    arb.io.in <> io.requestor.map(_.req)\n  114    arb.io.out.ready := (state === s_ready) && !l2_refill_wire\n  ...\n  116    val resp_valid = Reg(next = Vec.fill(io.requestor.size)(Bool(false)))\n  117  \n  118:   val clock_en = state =/= s_ready || l2_refill_wire || arb.io.out.valid || io.dpath.sfence.valid || io.dpath.customCSRs.disableDCacheClockGate\n  119    io.dpath.clock_enabled := usingVM && clock_en\n  120    val gated_clock =\n  ...\n  132    val r_pte = Reg(new PTE)\n  133  \n  134:   val mem_resp_valid = RegNext(io.mem.resp.valid)\n  135    val mem_resp_data = RegNext(io.mem.resp.bits.data)\n  136    io.mem.uncached_resp.map { resp =>\n  137:     assert(!(resp.valid && io.mem.resp.valid))\n  138      resp.ready := true\n  139:     when (resp.valid) {\n  140        mem_resp_valid := true\n  141        mem_resp_data := resp.bits.data\n  ...\n  173      val size = 1 << log2Up(pgLevels * 2)\n  174      val plru = new PseudoLRU(size)\n  175:     val valid = RegInit(0.U(size.W))\n  176      val tags = Reg(Vec(size, UInt(width = paddrBits)))\n  177      val data = Reg(Vec(size, UInt(width = ppnBits)))\n  178  \n  179:     val hits = tags.map(_ === pte_addr).asUInt & valid\n  180      val hit = hits.orR\n  181      when (mem_resp_valid && traverse && !hit && !invalidated) {\n  182:       val r = Mux(valid.andR, plru.way, PriorityEncoder(~valid))\n  183:       valid := valid | UIntToOH(r)\n  184        tags(r) := pte_addr\n  185        data(r) := pte.ppn\n  186      }\n  187      when (hit && state === s_req) { plru.access(OHToUInt(hits)) }\n  188:     when (io.dpath.sfence.valid && !io.dpath.sfence.bits.rs1) { valid := 0.U }\n  189  \n  190      for (i <- 0 until pgLevels-1)\n  ...\n  222  \n  223      val g = Reg(Vec(coreParams.nL2TLBWays, UInt(width = nL2TLBSets)))\n  224:     val valid = RegInit(Vec(Seq.fill(coreParams.nL2TLBWays)(0.U(nL2TLBSets.W))))\n  225      val (r_tag, r_idx) = Split(r_req.addr, idxBits)\n  226:     val r_valid_vec = valid.map(_(r_idx)).asUInt\n  227      val r_valid_vec_q = Reg(UInt(coreParams.nL2TLBWays.W))\n  228      val r_l2_plru_way = Reg(UInt(log2Ceil(coreParams.nL2TLBWays max 1).W))\n  ...\n  240        for (way <- 0 until coreParams.nL2TLBWays) {\n  241          when (wmask(way)) {\n  242:           valid(way) := valid(way) | mask\n  243            g(way) := Mux(r_pte.g, g(way) | mask, g(way) & ~mask)\n  244          }\n  245        }\n  246      }\n  247:     when (io.dpath.sfence.valid) {\n  248        for (way <- 0 until coreParams.nL2TLBWays) {\n  249:         valid(way) :=\n  250:           Mux(io.dpath.sfence.bits.rs1, valid(way) & ~UIntToOH(io.dpath.sfence.bits.addr(idxBits+pgIdxBits-1, pgIdxBits)),\n  251:           Mux(io.dpath.sfence.bits.rs2, valid(way) & g(way), 0.U))\n  252        }\n  253      }\n  254  \n  255      val s0_valid = !l2_refill && arb.io.out.fire()\n  256:     val s1_valid = RegNext(s0_valid && arb.io.out.bits.valid)\n  257      val s2_valid = RegNext(s1_valid)\n  258      val s1_rdata = ram.read(arb.io.out.bits.bits.addr(idxBits-1, 0), s0_valid)\n  ...\n  261      val s2_g_vec = RegEnable(Vec(g.map(_(r_idx))), s1_valid)\n  262      val s2_error = (0 until coreParams.nL2TLBWays).map(way => s2_valid_vec(way) && s2_rdata(way).error).orR\n  263:     when (s2_valid && s2_error) { valid.foreach { _ := 0.U }}\n  264  \n  265      val s2_entry_vec = s2_rdata.map(_.uncorrected.asTypeOf(new L2TLBEntry(nL2TLBSets)))\n  ...\n  287  \n  288    // if SFENCE occurs during walk, don't refill PTE cache or L2 TLB until next walk\n  289:   invalidated := io.dpath.sfence.valid || (invalidated && state =/= s_ready)\n  290  \n  291:   io.mem.req.valid := state === s_req || state === s_dummy1\n  292    io.mem.req.bits.phys := Bool(true)\n  293    io.mem.req.bits.cmd  := M_XRD\n  ...\n  315  \n  316    for (i <- 0 until io.requestor.size) {\n  317:     io.requestor(i).resp.valid := resp_valid(i)\n  318      io.requestor(i).resp.bits.ae := resp_ae\n  319      io.requestor(i).resp.bits.pte := r_pte\n  ...\n  334      is (s_ready) {\n  335        when (arb.io.out.fire()) {\n  336:         next_state := Mux(arb.io.out.bits.valid, s_req, s_ready)\n  337        }\n  338        count := pgLevels - minPgLevels - io.dpath.ptbr.additionalPgLevels\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/RocketCore.scala:\n  290    val id_scie_decoder = if (!rocketParams.useSCIE) Wire(new SCIEDecoderInterface) else {\n  291      val d = Module(new SCIEDecoder)\n  292:     assert(!io.imem.resp.valid || PopCount(d.io.unpipelined :: d.io.pipelined :: d.io.multicycle :: Nil) <= 1)\n  293      d.io.insn := id_raw_inst(0)\n  294      d.io\n  ...\n  313    val id_fence_succ = id_inst(0)(23,20)\n  314    val id_fence_next = id_ctrl.fence || id_ctrl.amo && id_amo_aq\n  315:   val id_mem_busy = !io.dmem.ordered || io.dmem.req.valid\n  316    when (!id_mem_busy) { id_reg_fence := false }\n  317    val id_rocc_busy = Bool(usingRoCC) &&\n  ...\n  399      val u = Module(new SCIEPipelined(xLen))\n  400      u.io.clock := Module.clock\n  401:     u.io.valid := ex_reg_valid && ex_scie_pipelined\n  402      u.io.insn := ex_reg_inst\n  403      u.io.rs1 := ex_rs(0)\n  ...\n  408    // multiplier and divider\n  409    val div = Module(new MulDiv(if (pipelinedMul) mulDivParams.copy(mulUnroll = 0) else mulDivParams, width = xLen))\n  410:   div.io.req.valid := ex_reg_valid && ex_ctrl.div\n  411    div.io.req.bits.dw := ex_ctrl.alu_dw\n  412    div.io.req.bits.fn := ex_ctrl.alu_fn\n  ...\n  416    val mul = pipelinedMul.option {\n  417      val m = Module(new PipelinedMultiplier(xLen, 2))\n  418:     m.io.req.valid := ex_reg_valid && ex_ctrl.mul\n  419      m.io.req.bits := div.io.req.bits\n  420      m\n  ...\n  422  \n  423    ex_reg_valid := !ctrl_killd\n  424:   ex_reg_replay := !take_pc && ibuf.io.inst(0).valid && ibuf.io.inst(0).bits.replay\n  425    ex_reg_xcpt := !ctrl_killd && id_xcpt\n  426:   ex_reg_xcpt_interrupt := !take_pc && ibuf.io.inst(0).valid && csr.io.interrupt\n  427  \n  428    when (!ctrl_killd) {\n  ...\n  489    // replay inst in ex stage?\n  490    val ex_pc_valid = ex_reg_valid || ex_reg_replay || ex_reg_xcpt_interrupt\n  491:   val wb_dcache_miss = wb_ctrl.mem && !io.dmem.resp.valid\n  492    val replay_ex_structural = ex_ctrl.mem && !io.dmem.req.ready ||\n  493                               ex_ctrl.div && !div.io.req.ready\n  ...\n  514    val mem_wrong_npc =\n  515      Mux(ex_pc_valid, mem_npc =/= ex_reg_pc,\n  516:     Mux(ibuf.io.inst(0).valid || ibuf.io.imem.valid, mem_npc =/= ibuf.io.pc, Bool(true)))\n  517    val mem_npc_misaligned = !csr.io.status.isa('c'-'a') && mem_npc(1) && !mem_reg_sfence\n  518    val mem_int_wdata = Mux(!mem_reg_xcpt && (mem_ctrl.jalr ^ mem_npc_misaligned), mem_br_target, mem_reg_wdata.asSInt).asUInt\n  ...\n  644    val dmem_resp_fpu =  io.dmem.resp.bits.tag(0).asBool\n  645    val dmem_resp_waddr = io.dmem.resp.bits.tag(5, 1)\n  646:   val dmem_resp_valid = io.dmem.resp.valid && io.dmem.resp.bits.has_data\n  647    val dmem_resp_replay = dmem_resp_valid && io.dmem.resp.bits.replay\n  648  \n  ...\n  708    io.trace := csr.io.trace\n  709    for (((iobpw, wphit), bp) <- io.bpwatch zip wb_reg_wphit zip csr.io.bp) {\n  710:     iobpw.valid(0) := wphit\n  711      iobpw.action := bp.control.action\n  712    }\n  ...\n  763      // speculate that a blocked D$ will unblock the cycle after a Grant\n  764      val blocked = Reg(Bool())\n  765:     blocked := !io.dmem.req.ready && io.dmem.clock_enabled && !io.dmem.perf.grant && (blocked || io.dmem.req.valid || io.dmem.s2_nack)\n  766      blocked && !io.dmem.perf.grant\n  767    }\n  768    val rocc_blocked = Reg(Bool())\n  769:   rocc_blocked := !wb_xcpt && !io.rocc.cmd.ready && (io.rocc.cmd.valid || rocc_blocked)\n  770  \n  771    val ctrl_stalld =\n  ...\n  776      id_ctrl.mem && dcache_blocked || // reduce activity during D$ misses\n  777      id_ctrl.rocc && rocc_blocked || // reduce activity while RoCC is busy\n  778:     id_ctrl.div && (!(div.io.req.ready || (div.io.resp.valid && !wb_wxd)) || div.io.req.valid) || // reduce odds of replay\n  779      !clock_en ||\n  780      id_do_fence ||\n  ...\n  782      id_reg_pause ||\n  783      io.traceStall\n  784:   ctrl_killd := !ibuf.io.inst(0).valid || ibuf.io.inst(0).bits.replay || take_pc_mem_wb || ctrl_stalld || csr.io.interrupt\n  785  \n  786:   io.imem.req.valid := take_pc\n  787    io.imem.req.bits.speculative := !take_pc_wb\n  788    io.imem.req.bits.pc :=\n  ...\n  795      imem_might_request_reg\n  796    }\n  797:   io.imem.sfence.valid := wb_reg_valid && wb_reg_sfence\n  798    io.imem.sfence.bits.rs1 := wb_reg_mem_size(0)\n  799    io.imem.sfence.bits.rs2 := wb_reg_mem_size(1)\n  ...\n  804    ibuf.io.inst(0).ready := !ctrl_stalld\n  805  \n  806:   io.imem.btb_update.valid := mem_reg_valid && !take_pc_wb && mem_wrong_npc && (!mem_cfi || mem_cfi_taken)\n  807    io.imem.btb_update.bits.isValid := mem_cfi\n  808    io.imem.btb_update.bits.cfiType :=\n  ...\n  816    io.imem.btb_update.bits.prediction := mem_reg_btb_resp\n  817  \n  818:   io.imem.bht_update.valid := mem_reg_valid && !take_pc_wb\n  819    io.imem.bht_update.bits.pc := io.imem.btb_update.bits.pc\n  820    io.imem.bht_update.bits.taken := mem_br_taken\n  ...\n  823    io.imem.bht_update.bits.prediction := mem_reg_btb_resp.bht\n  824  \n  825:   io.fpu.valid := !ctrl_killd && id_ctrl.fp\n  826    io.fpu.killx := ctrl_killx\n  827    io.fpu.killm := killm_common\n  ...\n  834    io.fpu.keep_clock_enabled := io.ptw.customCSRs.disableCoreClockGate\n  835  \n  836:   io.dmem.req.valid     := ex_reg_valid && ex_ctrl.mem\n  837    val ex_dcache_tag = Cat(ex_waddr, ex_ctrl.fp)\n  838    require(coreParams.dcacheReqTagBits >= ex_dcache_tag.getWidth)\n  ...\n  849    io.dmem.s2_kill := false\n  850    // don't let D$ go to sleep if we're probably going to use it soon\n  851:   io.dmem.keep_clock_enabled := ibuf.io.inst(0).valid && id_ctrl.mem && !csr.io.csr_stall\n  852  \n  853:   io.rocc.cmd.valid := wb_reg_valid && wb_ctrl.rocc && !replay_wb_common\n  854    io.rocc.exception := wb_xcpt && csr.io.status.xs.orR\n  855    io.rocc.cmd.bits.status := csr.io.status\n  ...\n  865    if (rocketParams.clockGate) {\n  866      long_latency_stall := csr.io.csr_stall || io.dmem.perf.blocked || id_reg_pause && !unpause\n  867:     clock_en := clock_en_reg || ex_pc_valid || (!long_latency_stall && io.imem.resp.valid)\n  868      clock_en_reg :=\n  869        ex_pc_valid || mem_pc_valid || wb_pc_valid || // instruction in flight\n  ...\n  872        usingFPU && !io.fpu.fcsr_rdy || // long-latency FPU in flight\n  873        io.dmem.replay_next || // long-latency load replaying\n  874:       (!long_latency_stall && (ibuf.io.inst(0).valid || io.imem.resp.valid)) // instruction pending\n  875  \n  876      assert(!(ex_pc_valid || mem_pc_valid || wb_pc_valid) || clock_en)\n  ...\n  878  \n  879    // evaluate performance counters\n  880:   val icache_blocked = !(io.imem.resp.valid || RegNext(io.imem.resp.valid))\n  881    csr.io.counters foreach { c => c.inc := RegNext(perfEvents.evaluate(c.eventSel)) }\n  882  \n  ...\n  887    coreMonitorBundle.hartid := io.hartid\n  888    coreMonitorBundle.timer := csr.io.time(31,0)\n  889:   coreMonitorBundle.valid := csr.io.trace(0).valid && !csr.io.trace(0).exception\n  890    coreMonitorBundle.pc := csr.io.trace(0).iaddr(vaddrBitsExtended-1, 0).sextTo(xLen)\n  891    coreMonitorBundle.wrenx := wb_wen && !wb_set_sboard\n  ...\n  908      val has_data = wb_wen && !wb_set_sboard\n  909  \n  910:     when (t.valid && !t.exception) {\n  911        when (wfd) {\n  912          printf (\"%d 0x%x (0x%x) f%d p%d 0xXXXXXXXXXXXXXXXX\\n\", t.priv, t.iaddr, t.insn, rd, rd+UInt(32))\n  ...\n  928    }\n  929    else {\n  930:     when (csr.io.trace(0).valid) {\n  931        printf(\"C%d: %d [%d] pc=[%x] W[r%d=%x][%d] R[r%d=%x] R[r%d=%x] inst=[%x] DASM(%x)\\n\",\n  932:          io.hartid, coreMonitorBundle.timer, coreMonitorBundle.valid,\n  933           coreMonitorBundle.pc,\n  934           Mux(wb_ctrl.wxd || wb_ctrl.wfd, coreMonitorBundle.wrdst, 0.U),\n  ...\n  950    xrfWriteBundle.hartid := io.hartid\n  951    xrfWriteBundle.timer := csr.io.time(31,0)\n  952:   xrfWriteBundle.valid := false.B\n  953    xrfWriteBundle.pc := 0.U\n  954    xrfWriteBundle.wrdst := rf_waddr\n  955:   xrfWriteBundle.wrenx := rf_wen && !(csr.io.trace(0).valid && wb_wen && (wb_waddr === rf_waddr))\n  956    xrfWriteBundle.wrenf := false.B\n  957    xrfWriteBundle.wrdata := rf_wdata\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/ScratchpadSlavePort.scala:\n   46      val dmem_req_valid = Wire(Bool())\n   47      when (state === s_wait1) { state := s_wait2 }\n   48:     when (state === s_init && tl_in.a.valid) { state := s_ready }\n   49:     when (io.dmem.resp.valid) { state := s_grant }\n   50      when (tl_in.d.fire()) { state := s_ready }\n   51      when (io.dmem.s2_nack) { state := s_replay }\n   ..\n   92      }\n   93  \n   94:     // ready_likely assumes that a valid response in s_wait2 is the vastly\n   95      // common case.  In the uncommon case, we'll erroneously send a request,\n   96      // then s1_kill it the following cycle.\n   97      val ready_likely = state.isOneOf(s_ready, s_wait2)\n   98:     val ready = state === s_ready || state === s_wait2 && io.dmem.resp.valid && tl_in.d.ready\n   99:     dmem_req_valid := (tl_in.a.valid && ready) || state === s_replay\n  100:     val dmem_req_valid_likely = (tl_in.a.valid && ready_likely) || state === s_replay\n  101  \n  102:     io.dmem.req.valid := dmem_req_valid_likely\n  103      tl_in.a.ready := io.dmem.req.ready && ready\n  104      io.dmem.req.bits := formCacheReq(Mux(state === s_replay, acq, tl_in.a.bits))\n  ...\n  108      io.dmem.s2_kill := false\n  109  \n  110:     tl_in.d.valid := io.dmem.resp.valid || state === s_grant\n  111      tl_in.d.bits := Mux(acq.opcode.isOneOf(TLMessages.PutFullData, TLMessages.PutPartialData),\n  112        edge.AccessAck(acq),\n  ...\n  115  \n  116      // Tie off unused channels\n  117:     tl_in.b.valid := Bool(false)\n  118      tl_in.c.ready := Bool(true)\n  119      tl_in.e.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/SimpleHellaCacheIF.scala:\n   20    val io = new Bundle {\n   21      val req = Decoupled(new HellaCacheReq).flip\n   22:     val nack = Valid(Bits(width = coreParams.dcacheReqTagBits)).flip\n   23:     val resp = Valid(new HellaCacheResp).flip\n   24      val replay = Decoupled(new HellaCacheReq)\n   25    }\n   ..\n   52  \n   53    // Keep sending the head of the nack queue until it succeeds\n   54:   io.replay.valid := nackq.io.deq.valid && !replaying\n   55    io.replay.bits := next_replay_req\n   56    // Don't allow new requests if there is are replays waiting\n   57    // or something being nacked.\n   58:   io.req.ready := !inflight.andR && !nackq.io.deq.valid && !io.nack.valid\n   59  \n   60    // Match on the tags to determine the index of nacks or responses\n   ..\n   62    val resp_onehot = Cat(reqs.map(_.tag === io.resp.bits.tag).reverse) & inflight\n   63  \n   64:   val replay_complete = io.resp.valid && replaying && io.resp.bits.tag === next_replay_req.tag\n   65:   val nack_head = io.nack.valid && nackq.io.deq.valid && io.nack.bits === next_replay_req.tag\n   66  \n   67    // Enqueue to the nack queue if there is a nack that is not in response to\n   68    // the previous replay\n   69:   nackq.io.enq.valid := io.nack.valid && !nack_head\n   70    nackq.io.enq.bits := OHToUInt(nack_onehot)\n   71:   assert(!nackq.io.enq.valid || nackq.io.enq.ready,\n   72      \"SimpleHellaCacheIF: ReplayQueue nack queue overflow\")\n   73  \n   74    // Dequeue from the nack queue if the last replay was successfully completed\n   75    nackq.io.deq.ready := replay_complete\n   76:   assert(!nackq.io.deq.ready || nackq.io.deq.valid,\n   77      \"SimpleHellaCacheIF: ReplayQueue nack queue underflow\")\n   78  \n   ..\n   80    // Clear it when it is successfully completed\n   81    inflight := (inflight | Mux(io.req.fire(), next_inflight_onehot, UInt(0))) &\n   82:                           ~Mux(io.resp.valid, resp_onehot, UInt(0))\n   83  \n   84    when (io.req.fire()) {\n   ..\n  105      req_arb.io.in(1).ready,\n  106      replayq.io.req.ready,\n  107:     io.requestor.req.valid)\n  108  \n  109    req_arb.io.in(0) <> replayq.io.replay\n  110:   req_arb.io.in(1).valid := req_helper.fire(req_arb.io.in(1).ready)\n  111    req_arb.io.in(1).bits := io.requestor.req.bits\n  112:   io.requestor.req.ready := req_helper.fire(io.requestor.req.valid)\n  113:   replayq.io.req.valid := req_helper.fire(replayq.io.req.ready)\n  114    replayq.io.req.bits := io.requestor.req.bits\n  115  \n  ...\n  128    io.cache.s2_kill := false.B\n  129  \n  130:   replayq.io.nack.valid := io.cache.s2_nack && s2_req_fire\n  131    replayq.io.nack.bits := s2_req_tag\n  132    replayq.io.resp := io.cache.resp\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/TLB.scala:\n   80    val tag = UInt(width = vpnBits)\n   81    val data = Vec(nSectors, UInt(width = new TLBEntryData().getWidth))\n   82:   val valid = Vec(nSectors, Bool())\n   83    def entry_data = data.map(_.asTypeOf(new TLBEntryData))\n   84  \n   85    private def sectorIdx(vpn: UInt) = vpn.extract(nSectors.log2-1, 0)\n   86    def getData(vpn: UInt) = OptimizationBarrier(data(sectorIdx(vpn)).asTypeOf(new TLBEntryData))\n   87:   def sectorHit(vpn: UInt) = valid.orR && sectorTagMatch(vpn)\n   88    def sectorTagMatch(vpn: UInt) = ((tag ^ vpn) >> nSectors.log2) === 0\n   89    def hit(vpn: UInt) = {\n   90      if (superpage && usingVM) {\n   91:       var tagMatch = valid.head\n   92        for (j <- 0 until pgLevels) {\n   93          val base = vpnBits - (j + 1) * pgLevelBits\n   ..\n   98      } else {\n   99        val idx = sectorIdx(vpn)\n  100:       valid(idx) && sectorTagMatch(vpn)\n  101      }\n  102    }\n  ...\n  119  \n  120      val idx = sectorIdx(tag)\n  121:     valid(idx) := true\n  122      data(idx) := entry.asUInt\n  123    }\n  124  \n  125:   def invalidate(): Unit = { valid.foreach(_ := false) }\n  126    def invalidateVPN(vpn: UInt): Unit = {\n  127      if (superpage) {\n  128        when (hit(vpn)) { invalidate() }\n  129      } else {\n  130:       when (sectorTagMatch(vpn)) { valid(sectorIdx(vpn)) := false }\n  131  \n  132        // For fragmented superpage mappings, we assume the worst (largest)\n  133        // case, and zap entries whose most-significant VPNs match\n  134        when (((tag ^ vpn) >> (pgLevelBits * (pgLevels - 1))) === 0) {\n  135:         for ((v, e) <- valid zip entry_data)\n  136            when (e.fragmented_superpage) { v := false }\n  137        }\n  ...\n  139    }\n  140    def invalidateNonGlobal(): Unit = {\n  141:     for ((v, e) <- valid zip entry_data)\n  142        when (!e.g) { v := false }\n  143    }\n  ...\n  154      val req = Decoupled(new TLBReq(lgMaxSize)).flip\n  155      val resp = new TLBResp().asOutput\n  156:     val sfence = Valid(new SFenceReq).asInput\n  157      val ptw = new TLBPTWIO\n  158      val kill = Bool(INPUT) // suppress a TLB refill, one cycle after a miss\n  ...\n  184    // share a single physical memory attribute checker (unshare if critical path)\n  185    val refill_ppn = io.ptw.resp.bits.pte.ppn(ppnBits-1, 0)\n  186:   val do_refill = Bool(usingVM) && io.ptw.resp.valid\n  187:   val invalidate_refill = state.isOneOf(s_request /* don't care */, s_wait_invalidate) || io.sfence.valid\n  188    val mpu_ppn = Mux(do_refill, refill_ppn,\n  189                  Mux(vm_enabled && special_entry.nonEmpty, special_entry.map(e => e.ppn(vpn, e.getData(vpn))).getOrElse(0.U), io.req.bits.vaddr >> pgIdxBits))\n  ...\n  327    val sectored_plru = new SetAssocLRU(cfg.nSets, sectored_entries(0).size, \"plru\")\n  328    val superpage_plru = new PseudoLRU(superpage_entries.size)\n  329:   when (io.req.valid && vm_enabled) {\n  330      when (sector_hits.orR) { sectored_plru.access(memIdx, OHToUInt(sector_hits)) }\n  331      when (superpage_hits.orR) { superpage_plru.access(OHToUInt(superpage_hits)) }\n  ...\n  355    io.resp.paddr := Cat(ppn, io.req.bits.vaddr(pgIdxBits-1, 0))\n  356  \n  357:   io.ptw.req.valid := state === s_request\n  358:   io.ptw.req.bits.valid := !io.kill\n  359    io.ptw.req.bits.bits.addr := r_refill_tag\n  360  \n  361    if (usingVM) {\n  362:     val sfence = io.sfence.valid\n  363      when (io.req.fire() && tlb_miss) {\n  364        state := s_request\n  ...\n  378        state := s_wait_invalidate\n  379      }\n  380:     when (io.ptw.resp.valid) {\n  381        state := s_ready\n  382      }\n  ...\n  395  \n  396      ccover(io.ptw.req.fire(), \"MISS\", \"TLB miss\")\n  397:     ccover(io.ptw.req.valid && !io.ptw.req.ready, \"PTW_STALL\", \"TLB miss, but PTW busy\")\n  398      ccover(state === s_wait_invalidate, \"SFENCE_DURING_REFILL\", \"flush TLB during TLB refill\")\n  399      ccover(sfence && !io.sfence.bits.rs1 && !io.sfence.bits.rs2, \"SFENCE_ALL\", \"flush TLB\")\n  ...\n  408  \n  409    def replacementEntry(set: Seq[TLBEntry], alt: UInt) = {\n  410:     val valids = set.map(_.valid.orR).asUInt\n  411      Mux(valids.andR, alt, PriorityEncoder(~valids))\n  412    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/scie/SCIE.scala:\n  104  class SCIEPipelinedInterface(xLen: Int) extends Bundle {\n  105    val clock = Input(Clock())\n  106:   val valid = Input(Bool())\n  107    val insn = Input(UInt(SCIE.iLen.W))\n  108    val rs1 = Input(UInt(xLen.W))\n  ...\n  118        |module SCIEPipelined #(parameter XLEN = 32) (\n  119        |    input clock,\n  120:       |    input valid,\n  121        |    input [${SCIE.iLen-1}:0] insn,\n  122        |    input [XLEN-1:0] rs1,\n  ...\n  153        |  always @(posedge clock)\n  154        |  begin\n  155:       |    /* Gating using the valid signal is optional, but saves power. */\n  156:       |    if (valid)\n  157        |    begin\n  158        |      /* Register Funct3[0] opcode bit for result muxing in next stage. */\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/BusErrorUnit.scala:\n    5  import Chisel._\n    6  import Chisel.ImplicitConversions._\n    7: import chisel3.util.Valid\n    8  import chisel3.DontCare\n    9  import freechips.rocketchip.config.Parameters\n   ..\n   17  \n   18  trait BusErrors extends Bundle {\n   19:   def toErrorList: List[Option[(Valid[UInt], String, String)]]\n   20  }\n   21  \n   ..\n   91      val new_value = Wire(UInt(value.getWidth.W), DontCare)\n   92      for ((((s, en), acc), i) <- (sources zip enable zip accrued).zipWithIndex; if s.nonEmpty) {\n   93:       when (s.get.valid) {\n   94          acc := true\n   95          when (en) {\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/FPU.scala:\n  183  \n  184    val fcsr_rm = Bits(INPUT, FPConstants.RM_SZ)\n  185:   val fcsr_flags = Valid(Bits(width = FPConstants.FLAGS_SZ))\n  186  \n  187    val store_data = Bits(OUTPUT, fLen)\n  ...\n  193    val dmem_resp_data = Bits(INPUT, fLen)\n  194  \n  195:   val valid = Bool(INPUT)\n  196    val fcsr_rdy = Bool(OUTPUT)\n  197    val nack_mem = Bool(OUTPUT)\n  ...\n  456    }\n  457    val io = new Bundle {\n  458:     val in = Valid(new FPInput).flip\n  459:     val out = Valid(new Output)\n  460    }\n  461  \n  462:   val in = RegEnable(io.in.bits, io.in.valid)\n  463:   val valid = Reg(next=io.in.valid)\n  464  \n  465    val dcmp = Module(new hardfloat.CompareRecFN(maxExpWidth, maxSigWidth))\n  ...\n  516    }\n  517  \n  518:   io.out.valid := valid\n  519    io.out.bits.lt := dcmp.io.lt || (dcmp.io.a.asSInt < 0.S && dcmp.io.b.asSInt >= 0.S)\n  520    io.out.bits.in := in\n  ...\n  523  class IntToFP(val latency: Int)(implicit p: Parameters) extends FPUModule()(p) with ShouldBeRetimed {\n  524    val io = new Bundle {\n  525:     val in = Valid(new IntToFPInput).flip\n  526:     val out = Valid(new FPResult)\n  527    }\n  528  \n  ...\n  563    }\n  564  \n  565:   io.out <> Pipe(in.valid, mux, latency-1)\n  566  }\n  567  \n  568  class FPToFP(val latency: Int)(implicit p: Parameters) extends FPUModule()(p) with ShouldBeRetimed {\n  569    val io = new Bundle {\n  570:     val in = Valid(new FPInput).flip\n  571:     val out = Valid(new FPResult)\n  572      val lt = Bool(INPUT) // from FPToInt\n  573    }\n  ...\n  623    }\n  624  \n  625:   io.out <> Pipe(in.valid, mux, latency-1)\n  626  }\n  627  \n  ...\n  669      roundingMode_stage0                      := Pipe(io.validin, io.roundingMode, postmul_regs).bits\n  670      detectTininess_stage0                    := Pipe(io.validin, io.detectTininess, postmul_regs).bits\n  671:     valid_stage0                             := Pipe(io.validin, false.B, postmul_regs).valid\n  672  \n  673      //------------------------------------------------------------------------\n  ...\n  681      roundRawFNToRecFN.io.roundingMode       := Pipe(valid_stage0, roundingMode_stage0, round_regs).bits\n  682      roundRawFNToRecFN.io.detectTininess     := Pipe(valid_stage0, detectTininess_stage0, round_regs).bits\n  683:     io.validout                             := Pipe(valid_stage0, false.B, round_regs).valid\n  684  \n  685      roundRawFNToRecFN.io.infiniteExc := Bool(false)\n  ...\n  694  \n  695    val io = new Bundle {\n  696:     val in = Valid(new FPInput).flip\n  697:     val out = Valid(new FPResult)\n  698    }\n  699  \n  700:   val valid = Reg(next=io.in.valid)\n  701    val in = Reg(new FPInput)\n  702:   when (io.in.valid) {\n  703      val one = UInt(1) << (t.sig + t.exp - 1)\n  704      val zero = (io.in.bits.in1 ^ io.in.bits.in2) & (UInt(1) << (t.sig + t.exp))\n  ...\n  711  \n  712    val fma = Module(new MulAddRecFNPipe((latency-1) min 2, t.exp, t.sig))\n  713:   fma.io.validin := valid\n  714    fma.io.op := in.fmaCmd\n  715    fma.io.roundingMode := in.rm\n  ...\n  735    }\n  736    val clock_en_reg = Reg(Bool())\n  737:   val clock_en = clock_en_reg || io.cp_req.valid\n  738    val gated_clock =\n  739      if (!useClockGating) clock\n  ...\n  744    val id_ctrl = fp_decoder.io.sigs\n  745  \n  746:   val ex_reg_valid = Reg(next=io.valid, init=Bool(false))\n  747:   val ex_reg_inst = RegEnable(io.inst, io.valid)\n  748:   val ex_reg_ctrl = RegEnable(id_ctrl, io.valid)\n  749    val ex_ra = List.fill(3)(Reg(UInt()))\n  750  \n  ...\n  757    @chiselName class FPUImpl extends NoChiselNamePrefix { // entering gated-clock domain\n  758  \n  759:   val req_valid = ex_reg_valid || io.cp_req.valid\n  760    val ex_cp_valid = io.cp_req.fire()\n  761    val mem_cp_valid = Reg(next=ex_cp_valid, init=Bool(false))\n  ...\n  773    val cp_ctrl = Wire(new FPUCtrlSigs)\n  774    cp_ctrl <> io.cp_req.bits\n  775:   io.cp_resp.valid := Bool(false)\n  776    io.cp_resp.bits.data := UInt(0)\n  777  \n  ...\n  787      i.hartid := io.hartid\n  788      i.timer := io.time(31,0)\n  789:     i.valid := false.B\n  790      i.wrenx := false.B\n  791      i.wrenf := false.B\n  ...\n  807  \n  808    val ex_rs = ex_ra.map(a => regfile(a))\n  809:   when (io.valid) {\n  810      when (id_ctrl.ren1) {\n  811        when (!id_ctrl.swap12) { ex_ra(0) := io.inst(19,15) }\n  ...\n  843  \n  844    val sfma = Module(new FPUFMAPipe(cfg.sfmaLatency, FType.S))\n  845:   sfma.io.in.valid := req_valid && ex_ctrl.fma && ex_ctrl.typeTagOut === S\n  846    sfma.io.in.bits := fuInput(Some(sfma.t))\n  847  \n  848    val fpiu = Module(new FPToInt)\n  849:   fpiu.io.in.valid := req_valid && (ex_ctrl.toint || ex_ctrl.div || ex_ctrl.sqrt || (ex_ctrl.fastpipe && ex_ctrl.wflags))\n  850    fpiu.io.in.bits := fuInput(None)\n  851    io.store_data := fpiu.io.out.bits.store\n  852    io.toint_data := fpiu.io.out.bits.toint\n  853:   when(fpiu.io.out.valid && mem_cp_valid && mem_ctrl.toint){\n  854      io.cp_resp.bits.data := fpiu.io.out.bits.toint\n  855:     io.cp_resp.valid := Bool(true)\n  856    }\n  857  \n  858    val ifpu = Module(new IntToFP(2))\n  859:   ifpu.io.in.valid := req_valid && ex_ctrl.fromint\n  860    ifpu.io.in.bits := fpiu.io.in.bits\n  861    ifpu.io.in.bits.in1 := Mux(ex_cp_valid, io.cp_req.bits.in1, io.fromint_data)\n  862  \n  863    val fpmu = Module(new FPToFP(2))\n  864:   fpmu.io.in.valid := req_valid && ex_ctrl.fastpipe\n  865    fpmu.io.in.bits := fpiu.io.in.bits\n  866    fpmu.io.lt := fpiu.io.out.bits.lt\n  ...\n  881      (fLen > 32).option({\n  882            val dfma = Module(new FPUFMAPipe(cfg.dfmaLatency, FType.D))\n  883:           dfma.io.in.valid := req_valid && ex_ctrl.fma && ex_ctrl.typeTagOut === D\n  884            dfma.io.in.bits := fuInput(Some(dfma.t))\n  885            Pipe(dfma, dfma.latency, (c: FPUCtrlSigs) => c.fma && c.typeTagOut === D, dfma.io.out.bits)\n  ...\n  887      (minFLen == 16).option({\n  888            val hfma = Module(new FPUFMAPipe(cfg.sfmaLatency, FType.H))\n  889:           hfma.io.in.valid := req_valid && ex_ctrl.fma && ex_ctrl.typeTagOut === H\n  890            hfma.io.in.bits := fuInput(Some(hfma.t))\n  891            Pipe(hfma, hfma.latency, (c: FPUCtrlSigs) => c.fma && c.typeTagOut === H, hfma.io.out.bits)\n  ...\n  947    when (wbInfo(0).cp && wen(0)) {\n  948      io.cp_resp.bits.data := wdata\n  949:     io.cp_resp.valid := Bool(true)\n  950    }\n  951    io.cp_req.ready := !ex_reg_valid\n  ...\n  953    val wb_toint_valid = wb_reg_valid && wb_ctrl.toint\n  954    val wb_toint_exc = RegEnable(fpiu.io.out.bits.exc, mem_ctrl.toint)\n  955:   io.fcsr_flags.valid := wb_toint_valid || divSqrt_wen || wen(0)\n  956    io.fcsr_flags.bits :=\n  957      Mux(wb_toint_valid, wb_toint_exc, UInt(0)) |\n  ...\n 1010    clock_en_reg := !useClockGating ||\n 1011      io.keep_clock_enabled || // chicken bit\n 1012:     io.valid || // ID stage\n 1013      req_valid || // EX stage\n 1014      mem_reg_valid || mem_cp_valid || // MEM stage\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/Interrupts.scala:\n   97  \n   98    def reportHalt(errors: Seq[CanHaveErrors]): Unit = {\n   99:     reportHalt(errors.flatMap(_.uncorrectable).map(_.valid).reduceOption(_||_))\n  100    }\n  101  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/LazyRoCC.scala:\n  108          fpArb.io.out_resp <> fpu.io.cp_resp\n  109        } else {\n  110:         fpu.io.cp_req.valid := false.B\n  111          fpu.io.cp_resp.ready := false.B\n  112        }\n  ...\n  145    }\n  146  \n  147:   when (io.mem.resp.valid) {\n  148      regfile(memRespTag) := io.mem.resp.bits.data\n  149      busy(memRespTag) := false.B\n  ...\n  164  \n  165    // PROC RESPONSE INTERFACE\n  166:   io.resp.valid := cmd.valid && doResp && !stallReg && !stallLoad\n  167:     // valid response if valid command, need a response, and no stalls\n  168    io.resp.bits.rd := cmd.bits.inst.rd\n  169      // Must respond with the appropriate tag or undefined behavior\n  ...\n  171      // Semantics is to always send out prior accumulator register value\n  172  \n  173:   io.busy := cmd.valid || busy.reduce(_||_)\n  174      // Be busy when have pending memory requests or committed possibility of pending requests\n  175    io.interrupt := false.B\n  ...\n  177  \n  178    // MEMORY REQUEST INTERFACE\n  179:   io.mem.req.valid := cmd.valid && doLoad && !stallReg && !stallResp\n  180    io.mem.req.bits.addr := addend\n  181    io.mem.req.bits.tag := addr\n  ...\n  215    when (ptw.req.fire()) { state := s_ptw_resp }\n  216  \n  217:   when (state === s_ptw_resp && ptw.resp.valid) {\n  218      pte := ptw.resp.bits.pte\n  219      state := s_resp\n  ...\n  222    when (io.resp.fire()) { state := s_idle }\n  223  \n  224:   ptw.req.valid := (state === s_ptw_req)\n  225:   ptw.req.bits.valid := true.B\n  226    ptw.req.bits.bits.addr := req_vpn\n  227  \n  228:   io.resp.valid := (state === s_resp)\n  229    io.resp.bits.rd := req_rd\n  230    io.resp.bits.data := Mux(pte.leaf(), Cat(pte.ppn, req_offset), -1.S(xLen.W).asUInt)\n  ...\n  232    io.busy := (state =/= s_idle)\n  233    io.interrupt := false.B\n  234:   io.mem.req.valid := false.B\n  235  }\n  236  \n  ...\n  279  \n  280    io.cmd.ready := (state === s_idle)\n  281:   io.resp.valid := (state === s_resp)\n  282    io.resp.bits.rd := resp_rd\n  283    io.resp.bits.data := count\n  284:   tl_out.a.valid := (state === s_acq)\n  285    tl_out.a.bits := edgesOut.Get(\n  286                         fromSource = 0.U,\n  ...\n  323    io.busy := (state =/= s_idle)\n  324    io.interrupt := false.B\n  325:   io.mem.req.valid := false.B\n  326    // Tie off unused channels\n  327    tl_out.b.ready := true.B\n  328:   tl_out.c.valid := false.B\n  329:   tl_out.e.valid := false.B\n  330  }\n  331  \n  ...\n  407    val cmdReadys = io.out.zip(opcodes).map { case (out, opcode) =>\n  408      val me = opcode.matches(cmd.bits.inst.opcode)\n  409:     out.valid := cmd.valid && me\n  410      out.bits := cmd.bits\n  411      out.ready && me\n  412    }\n  413    cmd.ready := cmdReadys.reduce(_ || _)\n  414:   io.busy := cmd.valid\n  415  \n  416    assert(PopCount(cmdReadys) <= 1.U,\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/AddressAdjuster.scala:\n  268        val a_local = Mux(a_adjustable, a_dynamic_local, isStaticallyLocal(parent.a.bits.address))\n  269        parent.a.ready := Mux(a_local, local.a.ready, remote.a.ready) && !a_stall\n  270:       local .a.valid := parent.a.valid &&  a_local && !a_stall\n  271:       remote.a.valid := parent.a.valid && !a_local && !a_stall\n  272        local .a.bits  :<= parent.a.bits\n  273        remote.a.bits  :<= parent.a.bits\n  ...\n  337        val local_d  = Wire(chiselTypeOf(parent.d)) // type-cast, because 'sink' width differs\n  338        local.d.ready := local_d.ready\n  339:       local_d.valid := local.d.valid\n  340        local_d.bits  :<= local.d.bits\n  341        val remote_d = Wire(chiselTypeOf(parent.d))\n  342        remote.d.ready := remote_d.ready\n  343:       remote_d.valid := remote.d.valid\n  344        remote_d.bits :<= remote.d.bits\n  345        remote_d.bits.sink := remote.d.bits.sink +& sink_threshold\n  ...\n  348        if (parentEdge.manager.anySupportAcquireB && parentEdge.client.anySupportProbe) {\n  349          // Merge probe channels\n  350:         assert (!local .b.valid || ((local .b.bits.address & mask.U) === local_prefix))\n  351:         assert (!remote.b.valid || ((remote.b.bits.address & mask.U) =/= local_prefix))\n  352          TLArbiter.robin(parentEdge, parent.b, local.b, remote.b)\n  353  \n  ...\n  355          val c_local = routeLocal(parent.c.bits.address)\n  356          parent.c.ready := Mux(c_local, local.c.ready, remote.c.ready)\n  357:         local .c.valid := parent.c.valid &&  c_local\n  358:         remote.c.valid := parent.c.valid && !c_local\n  359          local .c.bits  :<= parent.c.bits\n  360          remote.c.bits  :<= parent.c.bits\n  ...\n  363          val e_local = parent.e.bits.sink < sink_threshold\n  364          parent.e.ready := Mux(e_local, local.e.ready, remote.e.ready)\n  365:         local .e.valid := parent.e.valid &&  e_local\n  366:         remote.e.valid := parent.e.valid && !e_local\n  367          local .e.bits  :<= parent.e.bits\n  368          remote.e.bits  :<= parent.e.bits\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Arbiter.scala:\n   19  \n   20    val roundRobin: Policy = (width, valids, select) => if (width == 1) 1.U(1.W) else {\n   21:     val valid = valids(width-1, 0)\n   22:     assert (valid === valids)\n   23      val mask = RegInit(((BigInt(1) << width)-1).U(width-1,0))\n   24:     val filter = Cat(valid & ~mask, valid)\n   25      val unready = (rightOR(filter, width*2, width) >> 1) | (mask << width)\n   26      val readys = ~((unready >> width) & unready(width-1, 0))\n   27:     when (select && valid.orR) {\n   28:       mask := leftOR(readys & valid, width)\n   29      }\n   30      readys(width-1, 0)\n   ..\n  170    val beatsLeft  = RegInit(0.U(log2Ceil(numSources).W))\n  171    val first = lastWinner > numSources.U\n  172:   val valid = lfsr(0)\n  173    val ready = lfsr(15)\n  174    sink.ready := ready\n  175:   sources.zipWithIndex.map { // pattern: every even-indexed valid is driven the same random way\n  176:     case (s, i) => s.valid := (if (i % 2 == 1) false.B else valid)\n  177    }\n  178  \n  ...\n  180      if (print) { printf(\"TestRobin: %d\\n\", sink.bits) }\n  181      when (beatsLeft === 0.U) {\n  182:       assert(lastWinner =/= sink.bits, \"Round robin did not pick a new idx despite one being valid.\")\n  183        lastWinner := sink.bits\n  184        beatsLeft := sink.bits\n  ...\n  189    }\n  190    if (print) {\n  191:     when (!sink.fire()) { printf(\"TestRobin: idle (%d %d)\\n\", valid, ready) }\n  192    }\n  193  }\n  ...\n  197  {\n  198    def assertLowest(id: Int): Unit = {\n  199:     when (sources(id).valid) {\n  200:       assert((numSources-1 until id by -1).map(!sources(_).fire).foldLeft(true.B)(_&&_), s\"$id was valid but a higher valid source was granted ready.\")\n  201      }\n  202    }\n  203  \n  204:   sources.zipWithIndex.map { case (s, i) => s.valid := lfsr(i) }\n  205    sink.ready := lfsr(15)\n  206    when (sink.fire()) { (0 until numSources).foreach(assertLowest(_)) }\n  ...\n  212  {\n  213    def assertHighest(id: Int): Unit = {\n  214:     when (sources(id).valid) {\n  215:       assert((0 until id).map(!sources(_).fire).foldLeft(true.B)(_&&_), s\"$id was valid but a lower valid source was granted ready.\")\n  216      }\n  217    }\n  218  \n  219:   sources.zipWithIndex.map { case (s, i) => s.valid := lfsr(i) }\n  220    sink.ready := lfsr(15)\n  221    when (sink.fire()) { (0 until numSources).foreach(assertHighest(_)) }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/AsyncCrossing.scala:\n   36          cover(in.e, \"TL_ASYNC_CROSSING_SOURCE_E\", \"MemorySystem;;TLAsyncCrossingSource Channel E\")\n   37        } else {\n   38:         in.b.valid := Bool(false)\n   39          in.c.ready := Bool(true)\n   40          in.e.ready := Bool(true)\n   ..\n   72          in.e.ridx := UInt(0)\n   73          out.b.ready := Bool(true)\n   74:         out.c.valid := Bool(false)\n   75:         out.e.valid := Bool(false)\n   76        }\n   77      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/AtomicAutomata.scala:\n   54        managersNeedingHelp foreach { m => require (m.fifoId.isDefined) }\n   55        // We need to preserve FIFO semantics across FIFO domains, not managers\n   56:       // Suppose you have Put(42) Atomic(+1) both inflight; valid results: 42 or 43\n   57:       // If we allow Put(42) Get() Put(+1) concurrent; valid results: 42 43 OR undef\n   58        // Making non-FIFO work requires waiting for all Acks to come back (=> use FIFOFixer)\n   59        val domainsNeedingHelp = managersNeedingHelp.map(_.fifoId.get).distinct\n   ..\n  149          val a_allow = !a_cam_busy && (a_isSupported || a_cam_any_free)\n  150          in.a.ready := source_i.ready && a_allow\n  151:         source_i.valid := in.a.valid && a_allow\n  152          source_i.bits  := in.a.bits\n  153          when (!a_isSupported) { // minimal mux difference\n  ...\n  158          // Potentially take the message from the CAM\n  159          val source_c = Wire(in.a)\n  160:         source_c.valid := a_cam_any_put\n  161          source_c.bits := edgeOut.Put(\n  162            fromSource = a_cam_a.bits.source,\n  ...\n  208          val d_cam_corrupt = Mux1H(d_cam_sel_match, cam_d.map(_.corrupt))\n  209          val d_cam_sel_bypass = if (edgeOut.manager.minLatency > 0) Bool(false) else\n  210:                                out.d.bits.source === in.a.bits.source && in.a.valid && !a_isSupported\n  211          val d_cam_sel = (a_cam_sel_free zip d_cam_sel_match) map { case (a,d) => Mux(d_cam_sel_bypass, a, d) }\n  212          val d_cam_sel_any = d_cam_sel_bypass || d_cam_sel_match.reduce(_ || _)\n  ...\n  233          val d_replace = d_first && d_ack && d_cam_sel_match.reduce(_ || _)\n  234  \n  235:         in.d.valid := out.d.valid && !d_drop\n  236          out.d.ready := in.d.ready || d_drop\n  237  \n  ...\n  244          }\n  245        } else {\n  246:         out.a.valid := in.a.valid\n  247          in.a.ready := out.a.ready\n  248          out.a.bits := in.a.bits\n  249  \n  250:         in.d.valid := out.d.valid\n  251          out.d.ready := in.d.ready\n  252          in.d.bits := out.d.bits\n  ...\n  254  \n  255        if (edgeOut.manager.anySupportAcquireB && edgeIn.client.anySupportProbe) {\n  256:         in.b.valid := out.b.valid\n  257          out.b.ready := in.b.ready\n  258          in.b.bits := out.b.bits\n  259  \n  260:         out.c.valid := in.c.valid\n  261          in.c.ready := out.c.ready\n  262          out.c.bits := in.c.bits\n  263  \n  264:         out.e.valid := in.e.valid\n  265          in.e.ready := out.e.ready\n  266          out.e.bits := in.e.bits\n  267        } else {\n  268:         in.b.valid := Bool(false)\n  269          in.c.ready := Bool(true)\n  270          in.e.ready := Bool(true)\n  271          out.b.ready := Bool(true)\n  272:         out.c.valid := Bool(false)\n  273:         out.e.valid := Bool(false)\n  274        }\n  275      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/BlockDuringReset.scala:\n    8  import freechips.rocketchip.util.{BlockDuringReset, EnhancedChisel3Assign}\n    9  \n   10: /** BlockDuringReset ensures that no channel admits to be ready or valid while reset is raised. */\n   11  class TLBlockDuringReset(stretchResetCycles: Int = 0)\n   12                          (implicit p: Parameters) extends LazyModule\n   ..\n   23          out.e :<> BlockDuringReset(in .e, stretchResetCycles)\n   24        } else {\n   25:         in.b.valid  := false.B\n   26          in.c.ready  := true.B\n   27          in.e.ready  := true.B\n   28          out.b.ready := true.B\n   29:         out.c.valid := false.B\n   30:         out.e.valid := false.B\n   31        }\n   32      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Broadcast.scala:\n  123        val d_trackerOH = VecInit(trackers.map { t => t.need_d && t.source === d_normal.bits.source }).asUInt holdUnless d_first\n  124  \n  125:       assert (!out.d.valid || !d_drop || out.d.bits.opcode === TLMessages.AccessAck)\n  126  \n  127        val d_allow = Wire(Bool())\n  128        out.d.ready := (d_normal.ready && d_allow) || d_drop\n  129:       d_normal.valid := out.d.valid && d_allow && !d_drop\n  130        d_normal.bits := out.d.bits // truncates source\n  131        when (d_what(1)) { // TRANSFORM_*\n  ...\n  135        val d_mshr = OHToUInt(d_trackerOH)\n  136        d_normal.bits.sink := d_mshr\n  137:       assert (!d_normal.valid || (d_trackerOH.orR() || d_normal.bits.opcode === TLMessages.ReleaseAck))\n  138  \n  139        // A tracker response is anything neither dropped nor a ReleaseAck\n  ...\n  145  \n  146        d_allow := filter.io.update.ready || !d_response || !d_last\n  147:       filter.io.update.valid := out.d.valid && d_normal.ready && !d_drop && d_response && d_last\n  148        filter.io.update.bits.mshr := d_mshr\n  149        filter.io.update.bits.gaveT := d_what === TRANSFORM_T\n  ...\n  185  \n  186        val c_first = edgeIn.first(in.c)\n  187:       filter.io.release.valid := in.c.valid && c_first && (c_releasedata || c_release)\n  188        filter.io.release.bits.address := in.c.bits.address\n  189        filter.io.release.bits.keepB   := in.c.bits.param === TLPermissions.TtoB\n  190        filter.io.release.bits.cacheOH := whoC\n  191  \n  192:       releaseack.valid := in.c.valid && (filter.io.release.ready || !c_first) && c_release\n  193        releaseack.bits  := edgeIn.ReleaseAck(in.c.bits)\n  194  \n  195        val put_what = Mux(c_releasedata, TRANSFORM_B, DROP)\n  196        val put_who  = Mux(c_releasedata, in.c.bits.source, c_trackerSrc)\n  197:       putfull.valid := in.c.valid && (c_probeackdata || (c_releasedata && (filter.io.release.ready || !c_first)))\n  198        putfull.bits := edgeOut.Put(Cat(put_what, put_who), in.c.bits.address, in.c.bits.size, in.c.bits.data)._2\n  199        putfull.bits.user.lift(AMBAProt).foreach { x =>\n  ...\n  221  \n  222        // Probe whatever the FSM wants to do next\n  223:       in.b.valid := probe_busy\n  224        if (caches.size != 0) {\n  225          in.b.bits := edgeIn.Probe(probe_line << lineShift, probe_target, lineShift.U, probe_perms)._2\n  ...\n  243        in.a.ready := (!a_first || filter.io.request.ready) && trackerReady\n  244        (trackers zip selectTracker.asBools) foreach { case (t, select) =>\n  245:         t.in_a.valid := in.a.valid && select && (!a_first || filter.io.request.ready)\n  246          t.in_a.bits := in.a.bits\n  247          t.in_a_first := a_first\n  248        }\n  249  \n  250:       filter.io.request.valid := in.a.valid && a_first && trackerReady\n  251        filter.io.request.bits.mshr    := OHToUInt(selectTracker)\n  252        filter.io.request.bits.address := in.a.bits.address\n  ...\n  270        val sack = filter.io.response.fire() && leaveB && others =/= 0.U\n  271        (trackers zip responseMSHR) foreach { case (tracker, select) =>\n  272:         tracker.probe.valid := filter.io.response.fire() && select\n  273          tracker.probe.bits.count   := responseCount\n  274          tracker.probe.bits.cacheOH := responseCache\n  ...\n  278        // The outer TL connections may not be cached\n  279        out.b.ready := true.B\n  280:       out.c.valid := false.B\n  281:       out.e.valid := false.B\n  282  \n  283        // Collect all the filters together\n  ...\n  361  \n  362    io.request.ready := io.response.ready\n  363:   io.response.valid := io.request.valid\n  364  \n  365    io.response.bits.mshr    := io.request.bits.mshr\n  ...\n  402      val in_a  = Flipped(Decoupled(new TLBundleA(edgeIn.bundle)))\n  403      val out_a = Decoupled(new TLBundleA(edgeOut.bundle))\n  404:     val probe = Input(Valid(new ProbeTrackInfo(caches)))\n  405      val probenack = Input(Bool())\n  406      val probedack = Input(Bool())\n  ...\n  451  \n  452    cacheOH := cacheOH & ~io.clearOH\n  453:   when (io.probe.valid) {\n  454      count   := io.probe.bits.count\n  455      cacheOH := io.probe.bits.cacheOH\n  ...\n  484  \n  485    io.in_a.ready := (idle || !io.in_a_first) && i_data.ready\n  486:   i_data.valid := (idle || !io.in_a_first) && io.in_a.valid\n  487    i_data.bits.mask := io.in_a.bits.mask\n  488    i_data.bits.data := io.in_a.bits.data\n  ...\n  494  \n  495    o_data.ready := io.out_a.ready && probe_done\n  496:   io.out_a.valid := o_data.valid && probe_done\n  497    io.out_a.bits.opcode  := Mux(acquire, TLMessages.Get, opcode)\n  498    io.out_a.bits.param   := Mux(acquire, 0.U, param)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Buffer.scala:\n   43          out.e <> e(in .e)\n   44        } else {\n   45:         in.b.valid := Bool(false)\n   46          in.c.ready := Bool(true)\n   47          in.e.ready := Bool(true)\n   48          out.b.ready := Bool(true)\n   49:         out.c.valid := Bool(false)\n   50:         out.e.valid := Bool(false)\n   51        }\n   52      }\n   ..\n  119          out.e <> e(in .e)\n  120        } else {\n  121:         in.b.valid := Bool(false)\n  122          in.c.ready := Bool(true)\n  123          in.e.ready := Bool(true)\n  124          out.b.ready := Bool(true)\n  125:         out.c.valid := Bool(false)\n  126:         out.e.valid := Bool(false)\n  127        }\n  128      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Bundle_ACancel.scala:\n   34    def monitorAndNotCancel(): TLBundle = {\n   35      val out = Wire(new TLBundle(params))\n   36:     out.a.valid := a.validQual()\n   37      out.a.bits  := a.bits\n   38      out.a.ready := a.ready\n   ..\n   52    def apply(in: TLBundle) = {\n   53      val out = Wire(new TLBundle_ACancel(in.params))\n   54:     out.a.earlyValid := in.a.valid\n   55      out.a.lateCancel := false.B\n   56      out.a.bits := in.a.bits\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Bundles.scala:\n  270          c.ready := Bool(false)\n  271          e.ready := Bool(false)\n  272:         b.valid := Bool(false)\n  273:         d.valid := Bool(false)\n  274        case OUTPUT =>\n  275:         a.valid := Bool(false)\n  276:         c.valid := Bool(false)\n  277:         e.valid := Bool(false)\n  278          b.ready := Bool(false)\n  279          d.ready := Bool(false)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/CacheCork.scala:\n   69          in.a.ready := Mux(toD, a_d.ready, a_a.ready)\n   70  \n   71:         a_a.valid := in.a.valid && !toD\n   72          a_a.bits := in.a.bits\n   73          a_a.bits.source := in.a.bits.source << 1 | Mux(isPut, UInt(1), UInt(0))\n   ..\n   81  \n   82          // Upgrades are instantly successful\n   83:         a_d.valid := in.a.valid && toD\n   84          a_d.bits := edgeIn.Grant(\n   85            fromSink = UInt(0),\n   ..\n   90          // Take ReleaseData from C to A; Release from C to D\n   91          val c_a = Wire(out.a)\n   92:         c_a.valid := in.c.valid && in.c.bits.opcode === ReleaseData\n   93          c_a.bits := edgeOut.Put(\n   94            fromSource = in.c.bits.source << 1,\n   ..\n  101          // Releases without Data succeed instantly\n  102          val c_d = Wire(in.d)\n  103:         c_d.valid := in.c.valid && in.c.bits.opcode === Release\n  104          c_d.bits := edgeIn.ReleaseAck(in.c.bits)\n  105  \n  106:         assert (!in.c.valid || in.c.bits.opcode === Release || in.c.bits.opcode === ReleaseData)\n  107          in.c.ready := Mux(in.c.bits.opcode === Release, c_d.ready, c_a.ready)\n  108  \n  ...\n  112          // Block B; should never happen\n  113          out.b.ready := Bool(false)\n  114:         assert (!out.b.valid)\n  115  \n  116          // Track in-flight sinkIds\n  117          val pool = Module(new IDPool(sinkIds))\n  118:         pool.io.free.valid := in.e.fire()\n  119          pool.io.free.bits  := in.e.bits.sink\n  120  \n  ...\n  123          val d_grant = in_d.bits.opcode === GrantData || in_d.bits.opcode === Grant\n  124          pool.io.alloc.ready := in.d.fire() && d_first && d_grant\n  125:         in.d.valid := in_d.valid && (pool.io.alloc.valid || !d_first || !d_grant)\n  126:         in_d.ready := in.d.ready && (pool.io.alloc.valid || !d_first || !d_grant)\n  127          in.d.bits := in_d.bits\n  128          in.d.bits.sink := pool.io.alloc.bits holdUnless d_first\n  ...\n  138          val aWOk = edgeIn.manager.fastProperty(in.a.bits.address, !_.supportsPutFull.none, (b:Boolean) => Bool(b))\n  139          val dWOk = wSourceVec(d_d.bits.source)\n  140:         val bypass = Bool(edgeIn.manager.minLatency == 0) && in.a.valid && in.a.bits.source === d_d.bits.source\n  141          val dWHeld = Mux(bypass, aWOk, dWOk) holdUnless d_first\n  142  \n  ...\n  163  \n  164          // Tie off unused ports\n  165:         in.b.valid := Bool(false)\n  166:         out.c.valid := Bool(false)\n  167:         out.e.valid := Bool(false)\n  168        }\n  169      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Delayer.scala:\n   15    lazy val module = new LazyModuleImp(this) {\n   16      def feed[T <: Data](sink: DecoupledIO[T], source: DecoupledIO[T], noise: T): Unit = {\n   17:       val allow = UInt((q * 65535.0).toInt) <= LFSRNoiseMaker(16, source.valid)\n   18:       sink.valid := source.valid && allow\n   19        source.ready := sink.ready && allow\n   20        sink.bits := source.bits\n   21:       when (!sink.valid) { sink.bits := noise }\n   22      }\n   23  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Edges.scala:\n  240    def first(bits: TLChannel, fire: Bool): Bool = firstlastHelper(bits, fire)._1\n  241    def first(x: DecoupledIO[TLChannel]): Bool = first(x.bits, x.fire())\n  242:   def first(x: ValidIO[TLChannel]): Bool = first(x.bits, x.valid)\n  243  \n  244    def last(bits: TLChannel, fire: Bool): Bool = firstlastHelper(bits, fire)._2\n  245    def last(x: DecoupledIO[TLChannel]): Bool = last(x.bits, x.fire())\n  246:   def last(x: ValidIO[TLChannel]): Bool = last(x.bits, x.valid)\n  247  \n  248    def done(bits: TLChannel, fire: Bool): Bool = firstlastHelper(bits, fire)._3\n  249    def done(x: DecoupledIO[TLChannel]): Bool = done(x.bits, x.fire())\n  250:   def done(x: ValidIO[TLChannel]): Bool = done(x.bits, x.valid)\n  251  \n  252    def firstlast(bits: TLChannel, fire: Bool): (Bool, Bool, Bool) = {\n  ...\n  255    }\n  256    def firstlast(x: DecoupledIO[TLChannel]): (Bool, Bool, Bool) = firstlast(x.bits, x.fire())\n  257:   def firstlast(x: ValidIO[TLChannel]): (Bool, Bool, Bool) = firstlast(x.bits, x.valid)\n  258  \n  259    def count(bits: TLChannel, fire: Bool): (Bool, Bool, Bool, UInt) = {\n  ...\n  262    }\n  263    def count(x: DecoupledIO[TLChannel]): (Bool, Bool, Bool, UInt) = count(x.bits, x.fire())\n  264:   def count(x: ValidIO[TLChannel]): (Bool, Bool, Bool, UInt) = count(x.bits, x.valid)\n  265  \n  266    def addr_inc(bits: TLChannel, fire: Bool): (Bool, Bool, Bool, UInt) = {\n  ...\n  269    }\n  270    def addr_inc(x: DecoupledIO[TLChannel]): (Bool, Bool, Bool, UInt) = addr_inc(x.bits, x.fire())\n  271:   def addr_inc(x: ValidIO[TLChannel]): (Bool, Bool, Bool, UInt) = addr_inc(x.bits, x.valid)\n  272  \n  273    // Does the request need T permissions to be executed?\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/FIFOFixer.scala:\n   85        out.a <> in.a\n   86        in.d <> out.d\n   87:       out.a.valid := in.a.valid && (a_notFIFO || !stall)\n   88        in.a.ready := out.a.ready && (a_notFIFO || !stall)\n   89  \n   ..\n   93          out.e <> in .e\n   94        } else {\n   95:         in.b.valid := Bool(false)\n   96          in.c.ready := Bool(true)\n   97          in.e.ready := Bool(true)\n   98          out.b.ready := Bool(true)\n   99:         out.c.valid := Bool(false)\n  100:         out.e.valid := Bool(false)\n  101        }\n  102  \n  103  //Functional cover properties\n  104       \n  105:       cover(in.a.valid && stall, \"COVER FIFOFIXER STALL\", \"Cover: Stall occured for a valid transaction\")\n  106  \n  107        val SourceIdFIFOed = RegInit(UInt(0, width = edgeIn.client.endSourceId))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Filter.scala:\n   60        // In case the inner interface removes Acquire, tie-off the channels\n   61        if (!edgeIn.manager.anySupportAcquireB) {\n   62:         in.b.valid := Bool(false)\n   63          in.c.ready := Bool(true)\n   64          in.e.ready := Bool(true)\n   65          out.b.ready := Bool(true)\n   66:         out.c.valid := Bool(false)\n   67:         out.e.valid := Bool(false)\n   68        }\n   69      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Fragmenter.scala:\n  200          val acknum_fragment = dFragnum << log2Ceil(minSize/beatBytes)\n  201          val acknum_size = dsizeOH1 >> log2Ceil(beatBytes)\n  202:         assert (!out.d.valid || (acknum_fragment & acknum_size) === UInt(0))\n  203          val dFirst_acknum = acknum_fragment | Mux(dHasData, acknum_size, UInt(0))\n  204          val ack_decrement = Mux(dHasData, UInt(1), dsizeOH >> log2Ceil(beatBytes))\n  ...\n  222          val drop = !dHasData && !Mux(doEarlyAck, dFirst, dLast)\n  223          out.d.ready := in.d.ready || drop\n  224:         in.d.valid  := out.d.valid && !drop\n  225          in.d.bits   := out.d.bits // pass most stuff unchanged\n  226          in.d.bits.source := out.d.bits.source >> addedBits\n  ...\n  250          val maxHints       = managers.map(m => if (m.supportsHint) maxDownSize else 0)\n  251  \n  252:         // We assume that the request is valid => size 0 is impossible\n  253          val lgMinSize = UInt(log2Ceil(minSize))\n  254          val maxLgArithmetics = maxArithmetics.map(m => if (m == 0) lgMinSize else UInt(log2Ceil(m)))\n  ...\n  315  \n  316          // Tie off unused channels\n  317:         in.b.valid := Bool(false)\n  318          in.c.ready := Bool(true)\n  319          in.e.ready := Bool(true)\n  320          out.b.ready := Bool(true)\n  321:         out.c.valid := Bool(false)\n  322:         out.e.valid := Bool(false)\n  323        }\n  324      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Fuzzer.scala:\n   24    val select = ~(leftOR(bitmap) << 1) & bitmap\n   25    io.alloc.bits := OHToUInt(select)\n   26:   io.alloc.valid := bitmap.orR()\n   27  \n   28    val clr = Wire(init = UInt(0, width = numIds))\n   ..\n   33  \n   34    bitmap := (bitmap & ~clr) | set\n   35:   assert (!io.free.valid || !(bitmap & ~clr)(io.free.bits)) // No double freeing\n   36  }\n   37  \n   ..\n  197      // Wire up Fuzzer flow control\n  198      val a_gen = if (nOperations>0) num_reqs =/= UInt(0) else Bool(true)\n  199:     out.a.valid := !reset && a_gen && legal && (!a_first || idMap.io.alloc.valid)\n  200      idMap.io.alloc.ready := a_gen && legal && a_first && out.a.ready\n  201:     idMap.io.free.valid := d_first && out.d.fire()\n  202      idMap.io.free.bits := out.d.bits.source\n  203  \n  204      out.a.bits  := bits\n  205      out.b.ready := Bool(true)\n  206:     out.c.valid := Bool(false)\n  207      out.d.ready := Bool(true)\n  208:     out.e.valid := Bool(false)\n  209  \n  210      // Increment the various progress-tracking states\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/HintHandler.scala:\n   73          mux.bits.echo :<= repeater.io.deq.bits.echo // control only\n   74  \n   75:         mux.valid := repeater.io.deq.valid\n   76          repeater.io.deq.ready := mux.ready\n   77  \n   ..\n  102        in.d.bits.source := out.d.bits.source >> 1\n  103        in.d.bits.opcode := Mux(transform, TLMessages.HintAck, out.d.bits.opcode)\n  104:       in.d.valid := out.d.valid && !drop\n  105        out.d.ready := in.d.ready ||  drop\n  106  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Monitor.scala:\n  367  \n  368    def legalizeFormat(bundle: TLBundle, edge: TLEdge) = {\n  369:     when (bundle.a.valid) { legalizeFormatA(bundle.a.bits, edge) }\n  370:     when (bundle.d.valid) { legalizeFormatD(bundle.d.bits, edge) }\n  371      if (edge.client.anySupportProbe && edge.manager.anySupportAcquireB) {\n  372:       when (bundle.b.valid) { legalizeFormatB(bundle.b.bits, edge) }\n  373:       when (bundle.c.valid) { legalizeFormatC(bundle.c.bits, edge) }\n  374:       when (bundle.e.valid) { legalizeFormatE(bundle.e.bits, edge) }\n  375      } else {\n  376:       monAssert (!bundle.b.valid, \"'B' channel valid and not TL-C\" + extra)\n  377:       monAssert (!bundle.c.valid, \"'C' channel valid and not TL-C\" + extra)\n  378:       monAssert (!bundle.e.valid, \"'E' channel valid and not TL-C\" + extra)\n  379      }\n  380    }\n  ...\n  387      val source  = Reg(UInt())\n  388      val address = Reg(UInt())\n  389:     when (a.valid && !a_first) {\n  390        monAssert (a.bits.opcode === opcode, \"'A' channel opcode changed within multibeat operation\" + extra)\n  391        monAssert (a.bits.param  === param,  \"'A' channel param changed within multibeat operation\" + extra)\n  ...\n  410      val source  = Reg(UInt())\n  411      val address = Reg(UInt())\n  412:     when (b.valid && !b_first) {\n  413        monAssert (b.bits.opcode === opcode, \"'B' channel opcode changed within multibeat operation\" + extra)\n  414        monAssert (b.bits.param  === param,  \"'B' channel param changed within multibeat operation\" + extra)\n  ...\n  457      val my_size      = Reg(UInt())\n  458  \n  459:     val a_first = bundle.a.valid && edge.first(bundle.a.bits, bundle.a.fire())\n  460:     val d_first = bundle.d.valid && edge.first(bundle.d.bits, bundle.d.fire())\n  461  \n  462      val my_a_first_beat = a_first && (bundle.a.bits.source === sym_source)\n  ...\n  515      val source  = Reg(UInt())\n  516      val address = Reg(UInt())\n  517:     when (c.valid && !c_first) {\n  518        monAssert (c.bits.opcode === opcode, \"'C' channel opcode changed within multibeat operation\" + extra)\n  519        monAssert (c.bits.param  === param,  \"'C' channel param changed within multibeat operation\" + extra)\n  ...\n  539      val sink    = Reg(UInt())\n  540      val denied  = Reg(Bool())\n  541:     when (d.valid && !d_first) {\n  542        assume (d.bits.opcode === opcode, \"'D' channel opcode changed within multibeat operation\" + extra)\n  543        assume (d.bits.param  === param,  \"'D' channel param changed within multibeat operation\" + extra)\n  ...\n  646      a_sizes_set_interm.suggestName(\"a_sizes_set_interm\")\n  647  \n  648:     when (bundle.a.valid && a_first && edge.isRequest(bundle.a.bits)) {\n  649        a_set_wo_ready := UIntToOH(bundle.a.bits.source)\n  650      }\n  ...\n  669  \n  670      val d_release_ack = bundle.d.bits.opcode === TLMessages.ReleaseAck\n  671:     when (bundle.d.valid && d_first && edge.isResponse(bundle.d.bits) && !d_release_ack) {\n  672        d_clr_wo_ready := UIntToOH(bundle.d.bits.source)\n  673      }\n  ...\n  678        d_sizes_clr   := size_to_numfullbits(1.U << log_a_size_bus_size.U) << (bundle.d.bits.source << log_a_size_bus_size.U)\n  679      }\n  680:     when (bundle.d.valid && d_first && edge.isResponse(bundle.d.bits) && !d_release_ack) {\n  681:       val same_cycle_resp = bundle.a.valid && a_first && edge.isRequest(bundle.a.bits) && (bundle.a.bits.source === bundle.d.bits.source)\n  682        assume(((inflight)(bundle.d.bits.source)) || same_cycle_resp, \"'D' channel acknowledged for nothing inflight\" + extra)\n  683  \n  ...\n  692        }\n  693      }\n  694:     when(bundle.d.valid && d_first && a_first && bundle.a.valid && (bundle.a.bits.source === bundle.d.bits.source) && !d_release_ack) {\n  695        assume((!bundle.d.ready) || bundle.a.ready, \"ready check\")\n  696      }\n  ...\n  754      c_sizes_set_interm.suggestName(\"c_sizes_set_interm\")\n  755  \n  756:     when (bundle.c.valid && c_first && edge.isRequest(bundle.c.bits)) {\n  757        c_set_wo_ready := UIntToOH(bundle.c.bits.source)\n  758      }\n  ...\n  777  \n  778      val d_release_ack = bundle.d.bits.opcode === TLMessages.ReleaseAck\n  779:     when (bundle.d.valid && d_first && edge.isResponse(bundle.d.bits) && d_release_ack) {\n  780        d_clr_wo_ready := UIntToOH(bundle.d.bits.source)\n  781      }\n  ...\n  787      }\n  788  \n  789:     when (bundle.d.valid && d_first && edge.isResponse(bundle.d.bits) && d_release_ack) {\n  790:       val same_cycle_resp = bundle.c.valid && c_first && edge.isRequest(bundle.c.bits) && (bundle.c.bits.source === bundle.d.bits.source)\n  791        assume(((inflight)(bundle.d.bits.source)) || same_cycle_resp, \"'D' channel acknowledged for nothing inflight\" + extra)\n  792        when (same_cycle_resp) {\n  ...\n  797      }\n  798  \n  799:     when(bundle.d.valid && d_first && c_first && bundle.c.valid && (bundle.c.bits.source === bundle.d.bits.source) && d_release_ack) {\n  800        assume((!bundle.d.ready) || bundle.c.ready, \"ready check\")\n  801      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Parameters.scala:\n  597    // The safe version will check the entire address\n  598    def findSafe(address: UInt) = Vec(slaves.map(_.address.map(_.contains(address)).reduce(_ || _)))\n  599:   // The fast version assumes the address is valid (you probably want fastProperty instead of this function)\n  600    def findFast(address: UInt) = {\n  601      val routingMask = AddressDecoder(slaves.map(_.address))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/PatternPusher.scala:\n   74      assert (end || Vec(plegal)(step), s\"Pattern pusher ${name} tried to push an illegal request\")\n   75  \n   76:     a.valid := io.run && ready && !end && !flight\n   77      a.bits  := Vec(pbits)(step)\n   78      d.ready := Bool(true)\n   ..\n   80      // Tie off unused channels\n   81      tl_out.b.ready := Bool(true)\n   82:     tl_out.c.valid := Bool(false)\n   83:     tl_out.e.valid := Bool(false)\n   84    }\n   85  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/RAMModel.scala:\n   10  // We detect concurrent puts that put memory into an undefined state.\n   11  // put0, put0Ack, put1, put1Ack => ok: defined\n   12: // put0, put1, put0Ack, put1Ack => ok: put1 clears valid (it sees busy>0)\tdefined for FIFO\n   13: // put0, put1, put1Ack, put0Ack => ok: put1 clears valid (it sees busy>0)\tdefined for FIFO\n   14: // When the region is FIFO, all writes leave 'valid' set (concurrent puts have defined behaviour)\n   15  \n   16  // We detect concurrent puts that invalidate an inflight get.\n   ..\n   50        // Block traffic while wiping Mems\n   51        in.a.ready := out.a.ready && !wipe\n   52:       out.a.valid := in.a.valid && !wipe\n   53        out.a.bits  := in.a.bits\n   54        out.d.ready := in.d.ready && !wipe\n   55:       in.d.valid := out.d.valid && !wipe\n   56        in.d.bits  := out.d.bits\n   57  \n   58        // BCE unsupported\n   59:       in.b.valid := Bool(false)\n   60:       out.c.valid := Bool(false)\n   61:       out.e.valid := Bool(false)\n   62        out.b.ready := Bool(true)\n   63        in.c.ready := Bool(true)\n   ..\n   81        // This must be registers b/c we build a CAM from it\n   82        val flight = Reg(Vec(endSourceId, new TLRAMModel.FlightMonitor(params)))\n   83:       val valid = Reg(Vec(endSourceId, Bool()))\n   84  \n   85        // We want to cross flight data from A to D in the same cycle (for combinational TL2 devices)\n   ..\n   90  \n   91        when (in.a.fire()) { flight(in.a.bits.source) := a_flight }\n   92:       val bypass = if (edge.manager.minLatency > 0) Bool(false) else in.a.valid && in.a.bits.source === out.d.bits.source\n   93        val d_flight = RegEnable(Mux(bypass, a_flight, flight(out.d.bits.source)), edge.first(out.d))\n   94  \n   ..\n  119          assert (a.opcode =/= TLMessages.AcquireBlock && a.opcode =/= TLMessages.AcquirePerm)\n  120  \n  121:         // Mark the operation as valid\n  122:         valid(a.source) := Bool(true)\n  123  \n  124          // Increase the per-byte flight counter for the whole transaction\n  ...\n  154        val a_waddr = Mux(wipe, wipeIndex, a_addr_hi)\n  155        val a_shadow = shadow.map(_.read(a_waddr))\n  156:       val a_known_old = !(Cat(a_shadow.map(!_.valid).reverse) & a_mask).orR\n  157        val alu = Module(new Atomics(a.params))\n  158        alu.io.write := Bool(false)\n  ...\n  176          val amo = a.opcode === TLMessages.ArithmeticData || a.opcode === TLMessages.LogicalData\n  177          val beat_amo = a.size <= UInt(log2Ceil(beatBytes))\n  178:         data.valid := Mux(wipe, Bool(false), (!busy || a_fifo) && (!amo || (a_known_old && beat_amo)))\n  179          data.value := alu.io.data_out(8*(i+1)-1, 8*i)\n  180          when (shadow_wen(i)) {\n  ...\n  219        val d_dec = d_dec_bytes.map(_ + d_dec_tree)\n  220        val d_shadow = shadow.map(_.read(d_addr_hi))\n  221:       val d_valid = valid(d.source) holdUnless d_first\n  222  \n  223        // CRC check\n  ...\n  253            // NOTE: D channel carries uninterrupted multibeast op, so updating on last is fine\n  254            for (i <- 0 until endSourceId) {\n  255:             // Does this modification overlap a Get? => wipe it's valid\n  256              val f_base = flight(i).base\n  257              val f_size = flight(i).size\n  ...\n  259              val d_bits = UIntToOH1(d_size, addressBits)\n  260              val overlap = ~(~(f_base ^ d_base) | (f_bits | d_bits)) === UInt(0)\n  261:             when (overlap) { valid(i) := Bool(false) }\n  262            }\n  263          }\n  ...\n  283                when (d_flight.opcode === TLMessages.LogicalData) { printf(\"l \") }\n  284                printf(\" 0x%x := 0x%x\", d_addr, got)\n  285:               when (!shadow.valid) {\n  286                  printf(\", undefined (uninitialized or prior overlapping puts)\\n\")\n  287                } .elsewhen (d_inc(i) =/= d_dec(i)) {\n  ...\n  345  \n  346    class ByteMonitor(params: MonitorParameters) extends GenericParameterizedBundle(params) {\n  347:     val valid = Bool()\n  348      val value = UInt(width = 8)\n  349    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/RationalCrossing.scala:\n    5  // This clock crossing behaves almost identically to a TLBuffer(2):\n    6  //   - It adds one cycle latency to each clock domain.\n    7: //   - All outputs of TLRational are registers (bits, valid, and ready).\n    8  //   - It costs 3*bits registers as opposed to 2*bits in a TLBuffer(2)\n    9  \n   ..\n   32          out.e <> ToRational(in.e, direction)\n   33        } else {\n   34:         in.b.valid   := Bool(false)\n   35          in.c.ready   := Bool(true)\n   36          in.e.ready   := Bool(true)\n   37          out.b.ready  := Bool(true)\n   38:         out.c.valid  := Bool(false)\n   39:         out.e.valid  := Bool(false)\n   40          out.b.sink   := UInt(0)\n   41          out.c.source := UInt(0)\n   ..\n   64        } else {\n   65          out.b.ready := Bool(true)\n   66:         out.c.valid := Bool(false)\n   67:         out.e.valid := Bool(false)\n   68:         in.b.valid  := Bool(false)\n   69          in.c.ready  := Bool(true)\n   70          in.e.ready  := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/RegisterRouter.scala:\n   84  \n   85      // No flow control needed\n   86:     in.valid  := a.valid\n   87      a.ready   := in.ready\n   88:     d.valid   := out.valid\n   89      out.ready := d.ready\n   90  \n   ..\n   99  \n  100      // Tie off unused channels\n  101:     bundleIn.b.valid := Bool(false)\n  102      bundleIn.c.ready := Bool(true)\n  103      bundleIn.e.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/SourceShrinker.scala:\n   38  \n   39        out.b.ready := Bool(true)\n   40:       out.c.valid := Bool(false)\n   41:       out.e.valid := Bool(false)\n   42:       in.b.valid := Bool(false)\n   43        in.c.ready := Bool(true)\n   44        in.e.ready := Bool(true)\n   ..\n   60          val block = a_first && full\n   61          in.a.ready := out.a.ready && !block\n   62:         out.a.valid := in.a.valid && !block\n   63          out.a.bits := in.a.bits\n   64          out.a.bits.source := nextFree holdUnless a_first\n   65  \n   66:         val bypass = Bool(edgeOut.manager.minLatency == 0) && in.a.valid && !full && a_first && nextFree === out.d.bits.source\n   67          in.d <> out.d\n   68          in.d.bits.source := Mux(bypass, in.a.bits.source, sourceIdMap(out.d.bits.source))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/SRAM.scala:\n   13  \n   14  class TLRAMErrors(val params: ECCParams, val addrBits: Int) extends Bundle with CanHaveErrors {\n   15:   val correctable   = (params.code.canCorrect && params.notifyErrors).option(Valid(UInt(addrBits.W)))\n   16:   val uncorrectable = (params.code.canDetect  && params.notifyErrors).option(Valid(UInt(addrBits.W)))\n   17  }\n   18  \n   ..\n  102       * For reads:\n  103       *   - stage A sets up the read\n  104:      *   - stage R drives the uncorrected data with valid based on ECC validity\n  105       *   - stage D sets up the correction, if any\n  106       *\n  ...\n  170      notifyNode.foreach { nnode =>\n  171        nnode.bundle.correctable.foreach { c =>\n  172:         c.valid := d_need_fix && d_full && (d_atomic || d_read || d_sublane)\n  173          c.bits  := d_address\n  174        }\n  175        nnode.bundle.uncorrectable.foreach { u =>\n  176:         u.valid := d_error && d_full && (d_atomic || d_read || d_sublane)\n  177          u.bits  := d_address\n  178        }\n  ...\n  216      in.d.bits.corrupt := Mux(d_mux, d_error, r_error) && out_aad\n  217  \n  218:     val mem_active_valid = Seq(CoverBoolean(in.d.valid, Seq(\"mem_active\")))\n  219      val data_error = Seq(\n  220        CoverBoolean(!d_need_fix && !d_error , Seq(\"no_data_error\")),\n  ...\n  238  \n  239      // Pipeline control\n  240:     in.d.valid := (d_full && d_respond) || (r_full && r_respond && !d_wb && !r_replay)\n  241      val d_ready = !d_respond || in.d.ready\n  242      val r_ready = !d_wb && !r_replay && (!d_full || d_ready) && (!r_respond || (!d_win && in.d.ready))\n  ...\n  323  \n  324      // Tie off unused channels\n  325:     in.b.valid := false.B\n  326      in.c.ready := true.B\n  327      in.e.ready := true.B\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/ToAHB.scala:\n  134          in.a.ready := Bool(false)\n  135        } .elsewhen (pre.full) /* retry beat (or continue burst) */ {\n  136:         post.send  := !d_block && (!pre.write || in.a.valid)\n  137          post.data  := in.a.bits.data\n  138          a_commit   := !d_block && !pre.write // only read beats commit to a D beat answer\n  ...\n  198        // We need a skidpad to capture D output:\n  199        // We cannot know if the D response will be accepted until we have\n  200:       // presented it on D as valid.  We also can't back-pressure AHB in the\n  201        // data phase.  Therefore, we must have enough space to save the all\n  202        // commited AHB requests (A+D phases = 2). To decouple d_ready from\n  ...\n  205        val d = Wire(in.d)\n  206        in.d :<> Queue(d, depth, flow=true)\n  207:       assert (!d.valid || d.ready)\n  208  \n  209        val d_flight = RegInit(UInt(0, width = 2))\n  ...\n  226        }\n  227  \n  228:       d.valid := d_valid && d_flow\n  229        d.bits  := edgeIn.AccessAck(d_source, d_size, out.hrdata)\n  230        d.bits.opcode := Mux(d_hint, TLMessages.HintAck, Mux(d_write, TLMessages.AccessAck, TLMessages.AccessAckData))\n  ...\n  282  \n  283        // AHB has no cache coherence\n  284:       in.b.valid := Bool(false)\n  285        in.c.ready := Bool(true)\n  286        in.e.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/ToAPB.scala:\n   52  \n   53        // APB has no cache coherence\n   54:       in.b.valid := Bool(false)\n   55        in.c.ready := Bool(true)\n   56        in.e.ready := Bool(true)\n   ..\n   58        // We need a skidpad to capture D output:\n   59        // We cannot know if the D response will be accepted until we have\n   60:       // presented it on D as valid.  We also can't back-pressure APB in the\n   61        // data phase.  Therefore, we must have enough space to save the data\n   62        // phase result.  Whenever we have a queued response, we can not allow\n   ..\n   69  \n   70        val a_enable = RegInit(Bool(false))\n   71:       val a_sel    = a.valid && RegNext(!in.d.valid || in.d.ready)\n   72        val a_write  = edgeIn.hasData(a.bits)\n   73  \n   ..\n   98  \n   99        a.ready := a_enable && out.pready\n  100:       d.valid := a_enable && out.pready\n  101:       assert (!d.valid || d.ready)\n  102  \n  103        d.bits.opcode  := Mux(d_write, TLMessages.AccessAck, TLMessages.AccessAckData)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/ToAXI4.scala:\n  153        out.ar.bits := queue_arw.bits\n  154        out.aw.bits := queue_arw.bits\n  155:       out.ar.valid := queue_arw.valid && !queue_arw.bits.wen\n  156:       out.aw.valid := queue_arw.valid &&  queue_arw.bits.wen\n  157        queue_arw.ready := Mux(queue_arw.bits.wen, out.aw.ready, out.ar.ready)\n  158  \n  ...\n  195        val stall = sourceStall(in.a.bits.source) && a_first\n  196        in.a.ready := !stall && Mux(a_isPut, (doneAW || out_arw.ready) && out_w.ready, out_arw.ready)\n  197:       out_arw.valid := !stall && in.a.valid && Mux(a_isPut, !doneAW && out_w.ready, Bool(true))\n  198  \n  199:       out_w.valid := !stall && in.a.valid && a_isPut && (doneAW || out_arw.ready)\n  200        out_w.bits.data := in.a.bits.data\n  201        out_w.bits.strb := in.a.bits.mask\n  ...\n  208        // Give R higher priority than B, unless B has been delayed for 8 cycles\n  209        val b_delay = Reg(UInt(width=3))\n  210:       when (out.b.valid && !out.b.ready) {\n  211          b_delay := b_delay + UInt(1)\n  212        } .otherwise {\n  213          b_delay := UInt(0)\n  214        }\n  215:       val r_wins = (out.r.valid && b_delay =/= UInt(7)) || r_holds_d\n  216  \n  217        out.r.ready := in.d.ready && r_wins\n  218        out.b.ready := in.d.ready && !r_wins\n  219:       in.d.valid := Mux(r_wins, out.r.valid, out.b.valid)\n  220  \n  221        // If the first beat of the AXI RRESP is RESP_DECERR, treat this as a denied\n  ...\n  270  \n  271        // Tie off unused channels\n  272:       in.b.valid := Bool(false)\n  273        in.c.ready := Bool(true)\n  274        in.e.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/WidthWidget.scala:\n   69  \n   70        in.ready := out.ready || !last\n   71:       out.valid := in.valid && last\n   72        out.bits := in.bits\n   73  \n   ..\n  125  \n  126        out.bits := in.bits\n  127:       out.valid := in.valid\n  128        in.ready := out.ready\n  129  \n  ...\n  147          // nothing to do; pass it through\n  148          out.bits := in.bits\n  149:         out.valid := in.valid\n  150          in.ready := out.ready\n  151        } else if (edgeIn.manager.beatBytes > edgeOut.manager.beatBytes) {\n  ...\n  187          edgeIn.client.unusedSources.foreach { id => sources(id) := 0.U }\n  188  \n  189:         val bypass = in.a.valid && in.a.bits.source === source\n  190          if (edgeIn.manager.minLatency > 0) sources(source)\n  191          else Mux(bypass, a_sel, sources(source))\n  ...\n  198          splice(edgeOut, out.b, edgeIn,  in.b,  sourceMap)\n  199          splice(edgeIn,  in.c,  edgeOut, out.c, sourceMap)\n  200:         out.e.valid := in.e.valid\n  201          out.e.bits := in.e.bits\n  202          in.e.ready := out.e.ready\n  203        } else {\n  204:         in.b.valid := false.B\n  205          in.c.ready := true.B\n  206          in.e.ready := true.B\n  207          out.b.ready := true.B\n  208:         out.c.valid := false.B\n  209:         out.e.valid := false.B\n  210        }\n  211      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Xbar.scala:\n  177      for (i <- 0 until select.size) {\n  178        filtered(i).bits := (if (force.lift(i).getOrElse(false)) IdentityModule(input.bits) else input.bits)\n  179:       filtered(i).valid := input.valid && (select(i) || (select.size == 1).B)\n  180      }\n  181      input.ready := Mux1H(select, filtered.map(_.ready))\n  ...\n  251          in(i).b.ready := true.B\n  252          in(i).b.bits  := DontCare\n  253:         io_in(i).b.valid := false.B\n  254          io_in(i).b.bits  := DontCare\n  255        }\n  ...\n  259          in(i).c.bits.source := io_in(i).c.bits.source | r.start.U\n  260        } else {\n  261:         in(i).c.valid := false.B\n  262          in(i).c.bits  := DontCare\n  263          io_in(i).c.ready := true.B\n  ...\n  271          in(i).d.ready := true.B\n  272          in(i).d.bits  := DontCare\n  273:         io_in(i).d.valid := false.B\n  274          io_in(i).d.bits  := DontCare\n  275        }\n  ...\n  278          in(i).e :<> io_in(i).e\n  279        } else {\n  280:         in(i).e.valid := false.B\n  281          in(i).e.bits  := DontCare\n  282          io_in(i).e.ready := true.B\n  ...\n  304          out(o).b :<> io_out(o).b\n  305        } else {\n  306:         out(o).b.valid := false.B\n  307          out(o).b.bits  := DontCare\n  308          io_out(o).b.ready := true.B\n  ...\n  315          out(o).c.ready := true.B\n  316          out(o).c.bits  := DontCare\n  317:         io_out(o).c.valid := false.B\n  318          io_out(o).c.bits  := DontCare\n  319        }\n  ...\n  323          out(o).d.bits.sink := io_out(o).d.bits.sink | r.start.U\n  324        } else {\n  325:         out(o).d.valid := false.B\n  326          out(o).d.bits  := DontCare\n  327          io_out(o).d.ready := true.B\n  ...\n  335          out(o).e.ready := true.B\n  336          out(o).e.bits  := DontCare\n  337:         io_out(o).e.valid := false.B\n  338          io_out(o).e.bits  := DontCare\n  339        }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Arbiters.scala:\n   28    val choice = if (rr) {\n   29      PriorityMux(\n   30:       rotateLeft(Vec(io.in.map(_.valid)), lockIdx + UInt(1)),\n   31        rotateLeft(Vec((0 until arbN).map(UInt(_))), lockIdx + UInt(1)))\n   32    } else {\n   33:     PriorityEncoder(io.in.map(_.valid))\n   34    }\n   35  \n   ..\n   40    }\n   41  \n   42:   io.out.valid := io.in(chosen).valid\n   43    io.out.bits := io.in(chosen).bits\n   44  }\n   ..\n  112  \n  113      val req_helper = DecoupledHelper(\n  114:       req_arb.io.out.valid,\n  115        route_q.io.enq.ready,\n  116        io.out_req.ready)\n  117  \n  118      io.out_req.bits := req_arb.io.out.bits\n  119:     io.out_req.valid := req_helper.fire(io.out_req.ready)\n  120  \n  121      route_q.io.enq.bits := req_arb.io.chosen\n  122:     route_q.io.enq.valid := req_helper.fire(route_q.io.enq.ready)\n  123  \n  124:     req_arb.io.out.ready := req_helper.fire(req_arb.io.out.valid)\n  125  \n  126      val resp_sel = route_q.io.deq.bits\n  ...\n  128      val resp_helper = DecoupledHelper(\n  129        resp_ready,\n  130:       route_q.io.deq.valid,\n  131:       io.out_resp.valid)\n  132  \n  133      val resp_valid = resp_helper.fire(resp_ready)\n  134      for (i <- 0 until n) {\n  135        io.in_resp(i).bits := io.out_resp.bits\n  136:       io.in_resp(i).valid := resp_valid && resp_sel === UInt(i)\n  137      }\n  138  \n  139:     route_q.io.deq.ready := resp_helper.fire(route_q.io.deq.valid)\n  140:     io.out_resp.ready := resp_helper.fire(io.out_resp.valid)\n  141    } else {\n  142      io.out_req <> io.in_req.head\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/AsyncQueue.scala:\n  127      // TODO: write some sort of sanity check assertion for users\n  128      // that denote don't reset when there is activity\n  129:     //    assert (!(reset || !sio.sink_reset_n) || !io.enq.valid, \"Enqueue while sink is reset and AsyncQueueSource is unprotected\")\n  130      //    assert (!reset_rise || prev_idx_match.asBool, \"Sink reset while AsyncQueueSource not empty\")\n  131    }\n  ...\n  144    val ridx = withReset(reset.asAsyncReset)(GrayCounter(bits+1, io.deq.fire(), !source_ready, \"ridx_bin\"))\n  145    val widx = AsyncResetSynchronizerShiftReg(io.async.widx, params.sync, Some(\"widx_gray\"))\n  146:   val valid = source_ready && ridx =/= widx\n  147  \n  148    // The mux is safe because timing analysis ensures ridx has reached the register\n  ...\n  153    io.async.index.foreach { _ := index }\n  154    // This register does not NEED to be reset, as its contents will not\n  155:   // be considered unless the asynchronously reset deq valid register is set.\n  156    // It is possible that bits latches when the source domain is reset / has power cut\n  157    // This is safe, because isolation gates brought mem low before the zeroed widx reached us\n  158    val deq_bits_nxt = io.async.mem(if (params.narrow) 0.U else index)\n  159:   io.deq.bits := ClockCrossingReg(deq_bits_nxt, en = valid, doInit = false, name = Some(\"deq_bits_reg\"))\n  160  \n  161:   val valid_reg = withReset(reset.asAsyncReset)(RegNext(next=valid, init=false.B).suggestName(\"valid_reg\"))\n  162:   io.deq.valid := valid_reg && source_ready\n  163  \n  164    val ridx_reg = withReset(reset.asAsyncReset)(RegNext(next=ridx, init=0.U).suggestName(\"ridx_gray\"))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Blockable.scala:\n   22        val blocked: T = Wire(chiselTypeOf(data))\n   23        blocked := data\n   24:       when (enable_blocking) { blocked.valid := false.B }\n   25        blocked\n   26      }\n   ..\n   30      def blockWhile(enable_blocking: Bool, data: DecoupledIO[T]): DecoupledIO[T] = {\n   31        val res = Wire(chiselTypeOf(data))\n   32:       res.valid  := data.valid\n   33        data.ready := res.ready\n   34        res.bits   := data.bits\n   35        when (enable_blocking) {\n   36:         res.valid  := false.B\n   37          data.ready := false.B\n   38        }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Broadcaster.scala:\n   23      val save = Reg(typ)\n   24  \n   25:     io.out.head.valid := idx === UInt(0) && io.in.valid\n   26      io.out.head.bits := io.in.bits\n   27      for (i <- 1 until n) {\n   28:       io.out(i).valid := idx === UInt(i)\n   29        io.out(i).bits := save\n   30      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/CoreMonitor.scala:\n   13    val hartid = UInt(width = xLen.W)\n   14    val timer = UInt(width = 32.W)\n   15:   val valid = Bool()\n   16    val pc = UInt(width = xLen.W)\n   17    val wrdst = UInt(width = 5.W)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/CreditedIO.scala:\n   72      require (depth >= 1)\n   73      val enq = Wire(DecoupledIO(genType))\n   74:     enq.valid := debit\n   75      enq.bits := bits\n   76:     assert (!enq.valid || enq.ready)\n   77      val res = Queue.irrevocable(enq, depth, pipe=true, flow=flow)\n   78      credit := res.fire()\n   ..\n  111      val res = Wire(CreditedIO(chiselTypeOf(x.bits)))\n  112      val dec = res.toSender(depth, pipe)\n  113:     dec.valid := x.valid\n  114      dec.bits := x.bits\n  115      x.ready := dec.ready\n  ...\n  120      val res = Wire(CreditedIO(chiselTypeOf(x.bits)))\n  121      val irr = res.toReceiver(depth, flow)\n  122:     x.valid := irr.valid\n  123      x.bits := irr.bits\n  124      irr.ready := x.ready\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/HellaQueue.scala:\n   29    // BUG! does not hold the output of the SRAM when !ready\n   30    // ... However, HellaQueue is correct due to the pipe stage\n   31:   val ren = io.deq.ready && (atLeastTwo || !io.deq.valid && !empty)\n   32:   val raddr = Mux(io.deq.valid, Mux(deq_done, UInt(0), deq_ptr + UInt(1)), deq_ptr)\n   33    val ram_out_valid = Reg(next = ren)\n   34  \n   35:   io.deq.valid := Mux(empty, io.enq.valid, ram_out_valid)\n   36    io.enq.ready := !full\n   37    io.deq.bits := Mux(empty, io.enq.bits, ram.read(raddr, ren))\n   ..\n   49    def apply[T <: Data](enq: DecoupledIO[T], entries: Int) = {\n   50      val q = Module((new HellaQueue(entries)) { enq.bits })\n   51:     q.io.enq.valid := enq.valid // not using <> so that override is allowed\n   52      q.io.enq.bits := enq.bits\n   53      enq.ready := q.io.enq.ready\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/IDPool.scala:\n   11  \n   12    val io = IO(new Bundle {\n   13:     val free = Flipped(Valid(UInt(idWidth.W)))\n   14      val alloc = if (revocableSelect) Decoupled(UInt(idWidth.W)) else Irrevocable(UInt(idWidth.W))\n   15    })\n   ..\n   18    val bitmap = RegInit(UInt(numIds.W), -1.S(numIds.W).asUInt)\n   19    val select = RegInit(0.U(idWidth.W))\n   20:   val valid  = RegInit(true.B)\n   21  \n   22:   io.alloc.valid := (if (lateValid)       bitmap.orR              else valid)\n   23    io.alloc.bits  := (if (revocableSelect) PriorityEncoder(bitmap) else select)\n   24  \n   25    val taken  = Mux(io.alloc.ready, UIntToOH(io.alloc.bits, numIds), 0.U)\n   26:   val given  = Mux(io.free .valid, UIntToOH(io.free .bits, numIds), 0.U)\n   27    val bitmap1 = (bitmap & ~taken) | given\n   28    val select1 = PriorityEncoder(bitmap1)\n   29    val valid1  = (  (bitmap.orR && !((PopCount(bitmap) === 1.U) && io.alloc.ready))  // bitmap not zero, and not allocating last bit\n   30:                 || io.free.valid)\n   31  \n   32    // Clock gate the bitmap\n   33:   when (io.alloc.ready || io.free.valid) {\n   34      bitmap := bitmap1\n   35:     valid  := valid1\n   36    }\n   37  \n   38    // Make select irrevocable\n   39:   when (io.alloc.ready || (!io.alloc.valid && io.free.valid)) {\n   40      select := select1\n   41    }\n   42  \n   43    // No double freeing\n   44:   assert (!io.free.valid || !(bitmap & ~taken)(io.free.bits))\n   45  \n   46    // pre-calculations for timing\n   47    if (!lateValid) {\n   48:     assert (valid === bitmap.orR)\n   49    }\n   50    if (!revocableSelect) {\n   51:     when (io.alloc.valid && RegNext(io.alloc.ready || (!io.alloc.valid && io.free.valid))) {\n   52        assert (select === PriorityEncoder(bitmap))\n   53      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/LanePositionedQueue.scala:\n   14  \n   15    val ready = Input (UInt(readyBits1.W))\n   16:   val valid = Output(UInt(validBits1.W))\n   17    val bits  = Output(Vec(lanes, gen))\n   18  \n   ..\n   25  \n   26    def cap_valid(l: Int = lanes) = if (l == maxValid) {\n   27:     valid\n   28    } else {\n   29:     val lo = if (l==1) 0.U else valid(log2Ceil(l)-1,0)\n   30:     Mux(valid >= l.U, l.U, lo)\n   31    }\n   32  \n   ..\n   40    }\n   41  \n   42:   def clamp_ready(x: UInt): Unit = { ready := min(x, valid, lanes) }\n   43:   def clamp_valid(x: UInt): Unit = { valid := min(x, ready, lanes) }\n   44  \n   45    // Feed from LPQ from another\n   46    def driveWith(x: LanePositionedDecoupledIO[T], selfRotation: UInt = 0.U, xRotation: UInt = 0.U): Unit = {\n   47      val limit = lanes min x.lanes\n   48:     val moved = min(ready, x.valid, limit)\n   49:     valid := moved\n   50      x.ready := moved\n   51  \n   ..\n   83    val depthBitsU = log2Up(depth)\n   84  \n   85:   // enq.valid elements are enqueued; enq.valid must be <= enq.ready min lanes\n   86    val enq = Flipped(new LanePositionedDecoupledIO(gen, lanes, depth))\n   87:   // deq.ready elements are dequeued; deq.ready must be <= deq.valid min lanes\n   88    val deq = new LanePositionedDecoupledIO(gen, depth, lanes)\n   89  \n   ..\n   97    // Rewind the deq/read pointer to the free pointer\n   98    // Same-cycle free is included in the 'rewound' pointer state\n   99:   // deq.valid may go to 0 for a few cycles after rewind\n  100    val rewind = if (args.rewind) Some(Input(Bool())) else None\n  101  \n  102    // Advance the commited space; ready only if commit.bits would not pass enq\n  103:   // commit.ready includes same-cycle space from enq.valid\n  104    val commit = if (args.commit) Some(Flipped(Decoupled(UInt(depthBitsU.W)))) else None\n  105    // Restore the enq/write pointer to the commit pointer\n  ...\n  175    }\n  176  \n  177:   val (enq_lane, enq_wrap) = lane(io.enq.valid)\n  178    val (deq_lane, deq_wrap) = lane(io.deq.ready)\n  179    val (enq_row,  enq_row1) = row(enq_wrap)\n  ...\n  181  \n  182    val capBits1 = log2Ceil(capacity+1)\n  183:   val nDeq    = RegInit(       0.U(capBits1.W)) // deq.valid\n  184    val nFree   = RegInit(       0.U(capBits1.W)) // free.ready\n  185    val nEnq    = RegInit(capacity.U(capBits1.W)) // enq.ready\n  ...\n  187  \n  188    val freed     = io.free  .map(x => Mux(x.fire(), x.bits, 0.U)).getOrElse(io.deq.ready)\n  189:   val committed = io.commit.map(x => Mux(x.fire(), x.bits, 0.U)).getOrElse(io.enq.valid)\n  190    io.free.foreach   { x => x.ready := x.bits <= nFree   + io.deq.ready }\n  191:   io.commit.foreach { x => x.ready := x.bits <= nCommit + io.enq.valid }\n  192  \n  193    // Note: can be negative (abort coincides with commit of all remaining enq)\n  ...\n  197    val nDeq_next    = nDeq    + committed    - io.deq.ready\n  198    val nFree_next   = rewindSize             + io.deq.ready\n  199:   val nEnq_next    = nEnq    + freed        - io.enq.valid\n  200:   val nCommit_next = abortSize              + io.enq.valid\n  201  \n  202    nDeq    := nDeq_next\n  ...\n  237    io.deq_0_lane := deq_lane\n  238    io.enq.ready := (if (pipe) nEnq +& freed     else nEnq)\n  239:   io.deq.valid := (if (flow) nDeq +& committed else nDeq)\n  240  \n  241    // Constraints the user must uphold\n  242:   assert (io.enq.valid <= io.enq.ready)\n  243:   assert (io.deq.ready <= io.deq.valid)\n  244:   assert (io.enq.valid <= lanes.U)\n  245    assert (io.deq.ready <= lanes.U)\n  246  \n  247:   val enq_vmask = UIntToOH1(io.enq.valid +& enq_lane, 2*lanes-1).pad(2*lanes)\n  248    val enq_lmask = (if (lanes==1) 0.U else UIntToOH1( enq_lane, lanes-1)).pad(2*lanes)\n  249    val enq_mask  = enq_vmask & ~enq_lmask\n  ...\n  348  \n  349    // The contract between the abort FSM and deq readers is:\n  350:   //   If enq_refill_idle, then all valid data is in SRAM\n  351    //   If !enq_refill_idle, then partial data must be bypassed\n  352  \n  ...\n  396  \n  397    // Block deq while deq_refilling after rewinding\n  398:   when (!deq_refill_idle) { io.deq.valid := 0.U }\n  399    // Block enq while enq_refilling after abort\n  400    when (!enq_refill_idle) { io.enq.ready := 0.U }\n  ...\n  526  \n  527    def cap(x: UInt) = Mux(x > lanes.U, lanes.U, x) +& 1.U\n  528:   q.io.enq.valid := (LFSR64() * cap(q.io.enq.ready)) >> 64\n  529:   q.io.deq.ready := (LFSR64() * cap(q.io.deq.valid)) >> 64\n  530  \n  531:   enq := enq + q.io.enq.valid\n  532    deq := deq + q.io.deq.ready\n  533  \n  534    q.io.commit.foreach { c =>\n  535:     val legal = enq + q.io.enq.valid - com\n  536      assert (c.ready || c.bits > legal)\n  537:     c.valid := LFSR64()(0)\n  538      c.bits  := ((legal + 1.U) * LFSR64()) >> 63 // 50% likely to be legal\n  539      when (c.fire()) { com := com + c.bits }\n  ...\n  543      val legal = deq + q.io.deq.ready - abt\n  544      assert (f.ready || f.bits > legal)\n  545:     f.valid := LFSR64()(0)\n  546      f.bits  := ((legal + 1.U) * LFSR64()) >> 63\n  547      when (f.fire()) { abt := abt + f.bits }\n  ...\n  565    q.io.enq.bits := VecInit.tabulate(lanes) { i =>\n  566      val pos = Mux(i.U >= q.io.enq_0_lane, i.U, (i + lanes).U) - q.io.enq_0_lane\n  567:     Mux (pos >= q.io.enq.valid, 0.U, enq + pos)\n  568    }\n  569  \n  570    q.io.deq.bits.zipWithIndex.foreach { case (d, i) =>\n  571      val pos = Mux(i.U >= q.io.deq_0_lane, i.U, (i + lanes).U) - q.io.deq_0_lane\n  572:     assert (pos >= q.io.deq.valid || d === deq + pos)\n  573    }\n  574  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Misc.scala:\n   63    }\n   64    def apply[T <: Data](valids: Seq[ValidIO[T]]): ValidIO[T] = {\n   65:     val out = Wire(Valid(valids.head.bits.cloneType))\n   66:     out.valid := valids.map(_.valid).reduce(_ || _)\n   67      out.bits := MuxCase(valids.head.bits,\n   68:       valids.map(v => (v.valid -> v.bits)))\n   69      out\n   70    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/MultiLaneQueue.scala:\n   22  \n   23    io.enq_ready := io.enq_valid <= queue.io.enq.ready\n   24:   queue.io.enq.valid := Mux(io.enq_ready, io.enq_valid, 0.U)\n   25    queue.io.enq.bits := RotateVector.left(io.enq_bits, queue.io.enq_0_lane)\n   26  \n   27:   io.deq_valid := io.deq_ready <= queue.io.deq.valid\n   28    queue.io.deq.ready := Mux(io.deq_valid, io.deq_ready, 0.U)\n   29    io.deq_bits := RotateVector.right(queue.io.deq.bits, queue.io.deq_0_lane)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/MultiPortQueue.scala:\n    9    val io = IO(new Bundle {\n   10      val enq = Flipped(Vec(enq_lanes, Decoupled(gen)))\n   11:     // NOTE: deq.{valid,bits} depend on deq.ready of lower-indexed ports\n   12      val deq = Vec(deq_lanes, Decoupled(gen))\n   13    })\n   ..\n   22    def gather[T <: Data](sparse: Seq[DecoupledIO[T]], dense: LanePositionedDecoupledIO[T], offset: UInt = 0.U): Unit = {\n   23      // Compute per-enq-port ready\n   24:     val enq_valid = DensePrefixSum(sparse.map(_.valid.asUInt))(_ +& _)\n   25      val low_ready = if (dense.lanes == 1) 0.U else dense.ready(log2Ceil(dense.lanes)-1, 0)\n   26      val cap_ready = Mux(dense.ready >= dense.lanes.U, dense.lanes.U, low_ready)\n   27      val ready = if (dense.lanes >= sparse.size) dense.ready else cap_ready\n   28:     dense.valid := Mux(enq_valid.last <= ready, enq_valid.last, ready)\n   29      (sparse zip (0.U +: enq_valid)) foreach { case (s, v) => s.ready := v < ready }\n   30  \n   ..\n   32      val popBits = log2Ceil(dense.lanes + sparse.size)\n   33      val lowHoles = dense.lanes.U(popBits.W) - offset\n   34:     val highHoles = sparse.map(x => WireInit(UInt(popBits.W), !x.valid))\n   35      val enq_dense = Gather(\n   36        Seq.fill(dense.lanes) { 0.U.asTypeOf(chiselTypeOf(sparse.head.bits)) } ++ sparse.map(_.bits),\n   ..\n   48  \n   49    def scatter[T <: Data](sparse: Seq[DecoupledIO[T]], dense: LanePositionedDecoupledIO[T], offset: UInt = 0.U): Unit = {\n   50:     // Computer per-deq-port valid\n   51      val deq_ready = DensePrefixSum(sparse.map(_.ready.asUInt))(_ +& _)\n   52:     val low_valid = if (dense.lanes == 1) 0.U else dense.valid(log2Ceil(dense.lanes)-1, 0)\n   53:     val cap_valid = Mux(dense.valid >= dense.lanes.U, dense.lanes.U, low_valid)\n   54:     val valid = if (dense.lanes >= sparse.size) dense.valid else cap_valid\n   55:     dense.ready := Mux(deq_ready.last <= valid, deq_ready.last, valid)\n   56:     (sparse zip (0.U +: deq_ready)) foreach { case (s, r) => s.valid := r < valid }\n   57  \n   58      // Scatter data from rotated lanes to deq ports\n   ..\n   85    io.finished := done\n   86  \n   87:   val valid = LFSR64()(lanes-1, 0)\n   88    val ready = LFSR64()(lanes-1, 0)\n   89  \n   ..\n   91    deq := deq + PopCount(q.io.deq.map(_.fire()))\n   92  \n   93:   val enq_bits = RipplePrefixSum(enq +: valid.asBools.map(x => WireInit(UInt(bits.W), x)))(_ + _)\n   94    val deq_bits = RipplePrefixSum(deq +: ready.asBools.map(x => WireInit(UInt(bits.W), x)))(_ + _)\n   95  \n   96    for (i <- 0 until lanes) {\n   97:     q.io.enq(i).valid := valid(i)\n   98:     q.io.enq(i).bits  := Mux(valid(i), enq_bits(i), 0.U)\n   99      q.io.deq(i).ready := ready(i)\n  100      assert (!q.io.deq(i).fire() || q.io.deq(i).bits === deq_bits(i))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/MultiWidthFifo.scala:\n   44        io.out.fire() -> (size - UInt(1))))\n   45  \n   46:     io.out.valid := size > UInt(0)\n   47      io.out.bits := rdata(tail)\n   48      io.in.ready := size < UInt(n)\n   ..\n   74  \n   75      io.count := size >> UInt(log2Up(nBeats))\n   76:     io.out.valid := io.count > UInt(0)\n   77      io.out.bits := rdata(tail)\n   78      io.in.ready := size < UInt(n * nBeats)\n   ..\n  100    val (lb_recv_cnt, lb_recv_done) = Counter(little2big.io.out.fire(), 4)\n  101  \n  102:   big2little.io.in.valid := bl_send\n  103    big2little.io.in.bits := bl_data(bl_send_cnt)\n  104    big2little.io.out.ready := bl_recv\n  105  \n  106:   little2big.io.in.valid := lb_send\n  107    little2big.io.in.bits := lb_data(lb_send_cnt)\n  108    little2big.io.out.ready := lb_recv\n  ...\n  147    val lb_start_recv = Reg(next = lb_send_done)\n  148  \n  149:   assert(!little2big.io.out.valid || little2big.io.out.bits === lb_recv_data,\n  150      \"Little to Big data mismatch\")\n  151:   assert(!big2little.io.out.valid || big2little.io.out.bits === bl_recv_data,\n  152      \"Bit to Little data mismatch\")\n  153  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/package.scala:\n   85    }\n   86  \n   87:   /** Any Data subtype that has a Bool member named valid. */\n   88:   type DataCanBeValid = Data { val valid: Bool }\n   89  \n   90    implicit class SeqMemToAugmentedSeqMem[T <: Data](private val x: SeqMem[T]) extends AnyVal {\n   ..\n  290    * \n  291    * In terms of [[Flipped]] with a producer 'p' and 'consumer' c:\n  292:   * c :<= p // means drive all unflipped fields of 'c' from 'p' (e.g.: c.valid := p.valid)\n  293    * c :=> p // means drive all flipped fields of 'p' from 'c' (e.g.: `p.ready := c.ready`)\n  294    * c :<> p // do both of the above\n  ...\n  303    * c := p is equivalent to 'c :<= p' + 'p :=> c'. In other words, drive ALL fields of 'c' from 'p' regardless of their direction.\n  304    * \n  305:   * Contrast this with 'c :<> p' which will connect a ready-valid producer\n  306    * 'p' to a consumer 'c'.\n  307    * If you flip this to 'p :<> c', it works the way you would expect (flipping the role of producer/consumer).\n  ...\n  312    * (usually because you got the IO direction wrong) instead of silently succeeding.\n  313    * \n  314:   * What if you want to connect all of the signals (e.g. ready/valid/bits)\n  315    * from producer 'p' to a monitor 'm'?\n  316    * For example in order to tap the connection to monitor traffic on an existing connection.\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Property.scala:\n  147    }\n  148    def apply[T <: Data](rv: ReadyValidIO[T], label: String, message: String)(implicit sourceInfo: SourceInfo): Unit = {\n  149:     apply( rv.valid &&  rv.ready, label + \"_FIRE\",  message + \": valid and ready\")\n  150:     apply( rv.valid && !rv.ready, label + \"_STALL\", message + \": valid and not ready\")\n  151:     apply(!rv.valid &&  rv.ready, label + \"_IDLE\",  message + \": not valid and ready\")\n  152:     apply(!rv.valid && !rv.ready, label + \"_FULL\",  message + \": not valid and not ready\")\n  153    }\n  154  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/RationalCrossing.scala:\n   53    val bits0  = Output(gen)\n   54    val bits1  = Output(gen)\n   55:   val valid  = Output(Bool())\n   56    val source = Output(UInt(2.W))\n   57    val ready  = Input(Bool())\n   ..\n   85    val equal = count === deq.sink\n   86  \n   87:   deq.valid  := enq.valid\n   88    deq.source := count\n   89    deq.bits0  := enq.bits\n   ..\n  124    enq.sink  := count\n  125    deq.bits  := Mux(equal, enq.bits0, enq.bits1)\n  126:   deq.valid := Mux(equal, enq.valid, count(1) =/= enq.source(0))\n  127  \n  128    when (deq.fire()) { count := Cat(count(0), !count(1)) }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ReadyValidCancel.scala:\n    8  /** A [[Bundle]] that adds `earlyValid` and `lateCancel` bits to some data.\n    9    * This indicates that the user expects a \"ValidCancel\" interface between a producer and a consumer.\n   10:   * Here, the producer asserts the `earlyValid` bit when data on the `bits` line might contain valid data.\n   11:   * The producer also asserts the `lateCancel` bit low to confirm the valid, or high to squash the valid.\n   12    * `lateCancel` is a DontCare when `earlyValid` is low.\n   13    * This differs from [[ReadyValidCancel]] as there is no `ready` line that the consumer can use\n   14    * to put back pressure on the producer.\n   15:   * @param gen the type of data to be wrapped in Valid/Cancel\n   16    */\n   17  class ValidCancel[+T <: Data](gen: T) extends Bundle {\n   ..\n   22    override def cloneType: this.type = ValidCancel(gen).asInstanceOf[this.type]\n   23  \n   24:   /** Down-converts a ValidCancel output to a Valid bundle, dropping early/late timing split. */\n   25:   def andNotCancel(): Valid[T] = {\n   26:     val out = Wire(new Valid(gen))\n   27:     out.valid := validQual()\n   28      out.bits  := bits\n   29      out\n   ..\n   42    * the producer uses the interface as-is (outputs bits)\n   43    * while the consumer uses the flipped interface (inputs bits).\n   44:   * @param gen the type of data to be wrapped in Ready/Valid/Cancel\n   45    */\n   46  class ReadyValidCancel[+T <: Data](gen: T) extends ValidCancel(gen)\n   ..\n   54    def asDecoupled(): DecoupledIO[T] = {\n   55      val out = Wire(new DecoupledIO(gen))\n   56:     out.valid := validQual()\n   57      out.bits  := bits\n   58      ready := out.ready\n   ..\n   69    def apply[T <: Data](in: ReadyValidIO[T]): ReadyValidCancel[T] = {\n   70      val out = Wire(new ReadyValidCancel(chiselTypeOf(in.bits)))\n   71:     out.earlyValid := in.valid\n   72      out.lateCancel := false.B\n   73      out.bits := in.bits\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ReorderQueue.scala:\n   22  \n   23  class ReorderDequeueIO[T <: Data](dType: T, tagWidth: Int) extends Bundle {\n   24:   val valid = Bool(INPUT)\n   25    val tag = UInt(INPUT, tagWidth)\n   26    val data = dType.cloneType.asOutput\n   ..\n   55      io.deq.matches := roq_matches.reduce(_ || _)\n   56  \n   57:     when (io.enq.valid && io.enq.ready) {\n   58        roq_data(roq_enq_addr) := io.enq.bits.data\n   59        roq_tags(roq_enq_addr) := io.enq.bits.tag\n   ..\n   61      }\n   62  \n   63:     when (io.deq.valid) {\n   64        roq_free(OHToUInt(roq_deq_onehot)) := Bool(true)\n   65      }\n   ..\n   74      io.deq.matches := !roq_free(io.deq.tag)\n   75  \n   76:     when (io.enq.valid && io.enq.ready) {\n   77        roq_data(io.enq.bits.tag) := io.enq.bits.data\n   78        roq_free(io.enq.bits.tag) := Bool(false)\n   79      }\n   80  \n   81:     when (io.deq.valid) {\n   82        roq_free(io.deq.tag) := Bool(true)\n   83      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Repeater.scala:\n   21  \n   22    // When !full, a repeater is pass-through\n   23:   io.deq.valid := io.enq.valid || full\n   24    io.enq.ready := io.deq.ready && !full\n   25    io.deq.bits := Mux(full, saved, io.enq.bits)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Replacement.scala:\n   16    def hit: Unit\n   17    def access(touch_way: UInt): Unit\n   18:   def access(touch_ways: Seq[Valid[UInt]]): Unit\n   19    def state_read: UInt\n   20    def get_next_state(state: UInt, touch_way: UInt): UInt\n   21:   def get_next_state(state: UInt, touch_ways: Seq[Valid[UInt]]): UInt = {\n   22:     touch_ways.foldLeft(state)((prev, touch_way) => Mux(touch_way.valid, get_next_state(prev, touch_way.bits), prev))\n   23    }\n   24    def get_replace_way(state: UInt): UInt\n   ..\n   46    def hit = {}\n   47    def access(touch_way: UInt) = {}\n   48:   def access(touch_ways: Seq[Valid[UInt]]) = {}\n   49    def get_next_state(state: UInt, touch_way: UInt) = 0.U //DontCare\n   50    def get_replace_way(state: UInt) = way\n   ..\n   53  abstract class SeqReplacementPolicy {\n   54    def access(set: UInt): Unit\n   55:   def update(valid: Bool, hit: Bool, set: UInt, way: UInt): Unit\n   56    def way: UInt\n   57  }\n   ..\n   59  abstract class SetAssocReplacementPolicy {\n   60    def access(set: UInt, touch_way: UInt): Unit\n   61:   def access(sets: Seq[UInt], touch_ways: Seq[Valid[UInt]]): Unit\n   62    def way(set: UInt): UInt\n   63  }\n   ..\n   66    val logic = new RandomReplacement(n_ways)\n   67    def access(set: UInt) = { }\n   68:   def update(valid: Bool, hit: Bool, set: UInt, way: UInt) = {\n   69:     when (valid && !hit) { logic.miss }\n   70    }\n   71    def way = logic.way\n   ..\n  114      state_reg := get_next_state(state_reg, touch_way)\n  115    }\n  116:   def access(touch_ways: Seq[Valid[UInt]]): Unit = {\n  117:     when (touch_ways.map(_.valid).orR) {\n  118        state_reg := get_next_state(state_reg, touch_ways)\n  119      }\n  120      for (i <- 1 until touch_ways.size) {\n  121:       cover(PopCount(touch_ways.map(_.valid)) === i.U, s\"LRU_UpdateCount$i\", s\"LRU Update $i simultaneous\")\n  122      }\n  123    }\n  ...\n  172      state_reg := get_next_state(state_reg, touch_way)\n  173    }\n  174:   def access(touch_ways: Seq[Valid[UInt]]): Unit = {\n  175:     when (touch_ways.map(_.valid).orR) {\n  176        state_reg := get_next_state(state_reg, touch_ways)\n  177      }\n  178      for (i <- 1 until touch_ways.size) {\n  179:       cover(PopCount(touch_ways.map(_.valid)) === i.U, s\"PLRU_UpdateCount$i\", s\"PLRU Update $i simultaneous\")\n  180      }\n  181    }\n  ...\n  285    }\n  286  \n  287:   def update(valid: Bool, hit: Bool, set: UInt, way: UInt) = {\n  288      val update_way = Mux(hit, way, plru_way)\n  289      next_state := logic.get_next_state(current_state, update_way)\n  290:     when (valid) { state.write(set, next_state) }\n  291    }\n  292  \n  ...\n  309    }\n  310  \n  311:   def access(sets: Seq[UInt], touch_ways: Seq[Valid[UInt]]) = {\n  312      require(sets.size == touch_ways.size, \"internal consistency check: should be same number of simultaneous updates for sets and touch_ways\")\n  313      for (set <- 0 until n_sets) {\n  314        val set_touch_ways = (sets zip touch_ways).map { case (touch_set, touch_way) =>\n  315:         Pipe(touch_way.valid && (touch_set === set.U), touch_way.bits, 0)}\n  316:       when (set_touch_ways.map(_.valid).orR) {\n  317          state_vec(set) := logic.get_next_state(state_vec(set), set_touch_ways)\n  318        }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ScatterGather.scala:\n    7  \n    8  object Gather {\n    9:   // Compress all the valid data to the lowest indices\n   10    def apply[T <: Data](data: Seq[ValidIO[T]]): Vec[T] = apply(data, DensePrefixSum)\n   11    def apply[T <: Data](data: Seq[ValidIO[T]], prefixSum: PrefixSum): Vec[T] = {\n   12      val popBits = log2Ceil(data.size)\n   13:     val holes = data.map(x => WireInit(UInt(popBits.W), (!x.valid).asUInt))\n   14      apply(data.map(_.bits), prefixSum(holes)(_ + _))\n   15    }\n   ..\n   42    def apply[T <: Data](data: Seq[ValidIO[T]], prefixSum: PrefixSum): Vec[T] = {\n   43      val popBits = log2Ceil(data.size)\n   44:     val holes = data.map(x => WireInit(UInt(popBits.W), (!x.valid).asUInt))\n   45      apply(data.map(_.bits), prefixSum(holes)(_ + _))\n   46    }\n   ..\n   80    // Put 0, 1, 2, 3 ... at all of the lanes with mask=1\n   81    val sum = RipplePrefixSum(0.U(bits.W) +: mask.asBools.map { x => WireInit(UInt(bits.W), x) })(_+_)\n   82:   val input = Wire(Vec(size, Valid(UInt(bits.W))))\n   83    for (i <- 0 until size) {\n   84:     input(i).valid := mask(i)\n   85      input(i).bits := Mux(mask(i), sum(i), sum.last)\n   86    }\n   ..\n   97    mask := mask + !io.finished\n   98  \n   99:   val input = Wire(Vec(size, Valid(UInt(bits.W))))\n  100    for (i <- 0 until size) {\n  101:     input(i).valid := mask(i)\n  102      input(i).bits := i.U\n  103    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ShiftQueue.scala:\n   19    })\n   20  \n   21:   private val valid = RegInit(VecInit(Seq.fill(entries) { false.B }))\n   22    private val elts = Reg(Vec(entries, gen))\n   23  \n   24    for (i <- 0 until entries) {\n   25:     def paddedValid(i: Int) = if (i == -1) true.B else if (i == entries) false.B else valid(i)\n   26  \n   27:     val wdata = if (i == entries-1) io.enq.bits else Mux(valid(i+1), elts(i+1), io.enq.bits)\n   28      val wen =\n   29        Mux(io.deq.ready,\n   30:           paddedValid(i+1) || io.enq.fire() && ((i == 0 && !flow).B || valid(i)),\n   31:           io.enq.fire() && paddedValid(i-1) && !valid(i))\n   32      when (wen) { elts(i) := wdata }\n   33  \n   34:     valid(i) :=\n   35        Mux(io.deq.ready,\n   36:           paddedValid(i+1) || io.enq.fire() && ((i == 0 && !flow).B || valid(i)),\n   37:           io.enq.fire() && paddedValid(i-1) || valid(i))\n   38    }\n   39  \n   40:   io.enq.ready := !valid(entries-1)\n   41:   io.deq.valid := valid(0)\n   42    io.deq.bits := elts.head\n   43  \n   44    if (flow) {\n   45:     when (io.enq.valid) { io.deq.valid := true.B }\n   46:     when (!valid(0)) { io.deq.bits := io.enq.bits }\n   47    }\n   48  \n   ..\n   51    }\n   52  \n   53:   io.mask := valid.asUInt\n   54    io.count := PopCount(io.mask)\n   55  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Timer.scala:\n   12  class Timer(initCount: Int, maxInflight: Int) extends Module {\n   13    val io = new Bundle {\n   14:     val start = Valid(UInt(width = log2Up(maxInflight))).flip\n   15:     val stop = Valid(UInt(width = log2Up(maxInflight))).flip\n   16:     val timeout = Valid(UInt(width = log2Up(maxInflight)))\n   17    }\n   18  \n   ..\n   23    when (active) { countdown := countdown - UInt(1) }\n   24  \n   25:   when (io.start.valid) {\n   26      inflight(io.start.bits) := Bool(true)\n   27      countdown := UInt(initCount - 1)\n   28    }\n   29  \n   30:   when (io.stop.valid) { inflight(io.stop.bits) := Bool(false) }\n   31  \n   32:   io.timeout.valid := countdown === UInt(0) && active\n   33    io.timeout.bits := PriorityEncoder(inflight)\n   34  \n   35:   assert(!io.stop.valid || inflight(io.stop.bits),\n   36           \"Timer stop for transaction that's not inflight\")\n   37  }\n\n1346 matches across 118 files\n\n\nSearching 386 files for \"Valid\" (case sensitive, whole word)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala:\n   49      val tail = RegInit(0.U(32.W))\n   50  \n   51:     val s1 = RegInit(0.U.asTypeOf(new chisel3.Valid(in.a.bits.cloneType)));chisel3.dontTouch(s1)\n   52      s1.bits := in.a.bits\n   53  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/DebugTransport.scala:\n  200  \n  201    //--------------------------------------------------------\n  202:   // Drive Ready Valid Interface\n  203  \n  204    val dmiReqValidCheck = WireInit(false.B)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/dm_registers.scala:\n  650    val reserved0 = UInt(3.W)\n  651  \n  652:   /* Size of the Program Buffer, in 32-bit words. Valid sizes are 0 - 16.\n  653    */\n  654    val progbufsize = UInt(5.W)\n  ...\n  697  \n  698    /* Number of {\\tt data} registers that are implemented as part of the\n  699:             abstract command interface. Valid sizes are 1 -- 12.\n  700    */\n  701    val datacount = UInt(4.W)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/groundtest/DummyPTW.scala:\n   16    }\n   17  \n   18:   val req_arb = Module(new RRArbiter(Valid(new PTWReq), n))\n   19    req_arb.io.in <> io.requestors.map(_.req)\n   20    req_arb.io.out.ready := Bool(true)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/groundtest/Status.scala:\n    7  \n    8  class GroundTestStatus extends Bundle {\n    9:   val timeout = Valid(UInt(width = 4))\n   10:   val error = Valid(UInt(width = 4))\n   11  }\n   12  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/jtag/JtagShifter.scala:\n    6  import chisel3.experimental.DataMirror\n    7  import chisel3.internal.firrtl.KnownWidth\n    8: import chisel3.util.{Cat, Valid}\n    9  \n   10  import freechips.rocketchip.config.Parameters\n   ..\n  138    class ModIO extends ChainIO {\n  139      val capture = Capture(genCapture)\n  140:     val update = Valid(genUpdate)  // valid high when in update state (single cycle), contents may change any time after\n  141    }\n  142    val io = IO(new ModIO)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/BTB.scala:\n  189  class BTB(implicit p: Parameters) extends BtbModule {\n  190    val io = new Bundle {\n  191:     val req = Valid(new BTBReq).flip\n  192:     val resp = Valid(new BTBResp)\n  193:     val btb_update = Valid(new BTBUpdate).flip\n  194:     val bht_update = Valid(new BHTUpdate).flip\n  195:     val bht_advance = Valid(new BTBResp).flip\n  196:     val ras_update = Valid(new RASUpdate).flip\n  197:     val ras_head = Valid(UInt(width = vaddrBits))\n  198      val flush = Bool().asInput\n  199    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/CSR.scala:\n  222    val time = UInt(OUTPUT, xLen)\n  223    val fcsr_rm = Bits(OUTPUT, FPConstants.RM_SZ)\n  224:   val fcsr_flags = Valid(Bits(width = FPConstants.FLAGS_SZ)).flip\n  225    val set_fs_dirty = coreParams.haveFSDirty.option(Bool(INPUT))\n  226    val rocc_interrupt = Bool(INPUT)\n  ...\n  242      val vxrm = UInt(2.W).asOutput\n  243      val set_vs_dirty = Input(Bool())\n  244:     val set_vconfig = Valid(new VConfig).flip\n  245:     val set_vstart = Valid(vstart).flip\n  246      val set_vxsat = Bool().asInput\n  247    })\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/DCache.scala:\n   27  class DCacheErrors(implicit p: Parameters) extends L1HellaCacheBundle()(p)\n   28      with CanHaveErrors {\n   29:   val correctable = (cacheParams.tagCode.canCorrect || cacheParams.dataCode.canCorrect).option(Valid(UInt(width = paddrBits)))\n   30:   val uncorrectable = (cacheParams.tagCode.canDetect || cacheParams.dataCode.canDetect).option(Valid(UInt(width = paddrBits)))\n   31:   val bus = Valid(UInt(width = paddrBits))\n   32  }\n   33  \n   ..\n   43  class DCacheDataArray(implicit p: Parameters) extends L1HellaCacheModule()(p) {\n   44    val io = new Bundle {\n   45:     val req = Valid(new DCacheDataReq).flip\n   46      val resp = Vec(nWays, UInt(width = req.bits.wdata.getWidth)).asOutput\n   47    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/Frontend.scala:\n   47    val might_request = Bool(OUTPUT)\n   48    val clock_enabled = Bool(INPUT)\n   49:   val req = Valid(new FrontendReq)\n   50:   val sfence = Valid(new SFenceReq)\n   51    val resp = Decoupled(new FrontendResp).flip\n   52:   val btb_update = Valid(new BTBUpdate)\n   53:   val bht_update = Valid(new BHTUpdate)\n   54:   val ras_update = Valid(new RASUpdate)\n   55    val flush_icache = Bool(OUTPUT)\n   56    val npc = UInt(INPUT, width = vaddrBitsExtended)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/HellaCache.scala:\n  172    val s2_paddr = UInt(INPUT, paddrBits) // translated address\n  173  \n  174:   val resp = Valid(new HellaCacheResp).flip\n  175    val replay_next = Bool(INPUT)\n  176    val s2_xcpt = (new HellaCacheExceptions).asInput\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/ICache.scala:\n   49      with HasL1ICacheParameters\n   50      with CanHaveErrors {\n   51:   val correctable = (cacheParams.tagCode.canDetect || cacheParams.dataCode.canDetect).option(Valid(UInt(width = paddrBits)))\n   52:   val uncorrectable = (cacheParams.itimAddr.nonEmpty && cacheParams.dataCode.canDetect).option(Valid(UInt(width = paddrBits)))\n   53:   val bus = Valid(UInt(width = paddrBits))\n   54  }\n   55  \n   ..\n  120    val s2_prefetch = Bool(INPUT) // should I$ prefetch next line on a miss?\n  121  \n  122:   val resp = Valid(new ICacheResp(outer))\n  123    val invalidate = Bool(INPUT)\n  124  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/Multiplier.scala:\n    5  \n    6  import chisel3._\n    7: import chisel3.util.{Cat, log2Up, log2Ceil, log2Floor, Log2, Decoupled, Enum, Fill, Valid, Pipe}\n    8  import Chisel.ImplicitConversions._\n    9  import freechips.rocketchip.util._\n   ..\n  186  class PipelinedMultiplier(width: Int, latency: Int, nXpr: Int = 32) extends Module with ShouldBeRetimed {\n  187    val io = IO(new Bundle {\n  188:     val req = Flipped(Valid(new MultiplierReq(width, log2Ceil(nXpr))))\n  189:     val resp = Valid(new MultiplierResp(width, log2Ceil(nXpr)))\n  190    })\n  191  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/NBDcache.scala:\n   57      val resp = Decoupled(new HellaCacheResp)\n   58      val mem_access = Decoupled(new TLBundleA(edge.bundle))\n   59:     val mem_ack = Valid(new TLBundleD(edge.bundle)).flip\n   60      val replay_next = Bool(OUTPUT)\n   61    }\n   ..\n  146  \n  147      val mem_acquire  = Decoupled(new TLBundleA(edge.bundle))\n  148:     val mem_grant = Valid(new TLBundleD(edge.bundle)).flip\n  149      val mem_finish = Decoupled(new TLBundleE(edge.bundle))\n  150  \n  ...\n  310  \n  311      val mem_acquire  = Decoupled(new TLBundleA(edge.bundle))\n  312:     val mem_grant = Valid(new TLBundleD(edge.bundle)).flip\n  313      val mem_finish = Decoupled(new TLBundleE(edge.bundle))\n  314  \n  ...\n  981    }\n  982  \n  983:   val cache_resp = Wire(Valid(new HellaCacheResp))\n  984    cache_resp.valid := (s2_replay || s2_valid_masked && s2_hit) && !s2_data_correctable\n  985    cache_resp.bits := s2_req\n  ...\n  989    cache_resp.bits.replay := s2_replay\n  990  \n  991:   val uncache_resp = Wire(Valid(new HellaCacheResp))\n  992    uncache_resp.bits := mshrs.io.resp.bits\n  993    uncache_resp.valid := mshrs.io.resp.valid\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/PTW.scala:\n   32  class TLBPTWIO(implicit p: Parameters) extends CoreBundle()(p)\n   33      with HasCoreParameters {\n   34:   val req = Decoupled(Valid(new PTWReq))\n   35:   val resp = Valid(new PTWResp).flip\n   36    val ptbr = new PTBR().asInput\n   37    val status = new MStatus().asInput\n   ..\n   50      with HasCoreParameters {\n   51    val ptbr = new PTBR().asInput\n   52:   val sfence = Valid(new SFenceReq).flip\n   53    val status = new MStatus().asInput\n   54    val pmp = Vec(nPMPs, new PMP).asInput\n   ..\n  110    val l2_refill_wire = Wire(Bool())\n  111  \n  112:   val arb = Module(new Arbiter(Valid(new PTWReq), n))\n  113    arb.io.in <> io.requestor.map(_.req)\n  114    arb.io.out.ready := (state === s_ready) && !l2_refill_wire\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/SimpleHellaCacheIF.scala:\n   20    val io = new Bundle {\n   21      val req = Decoupled(new HellaCacheReq).flip\n   22:     val nack = Valid(Bits(width = coreParams.dcacheReqTagBits)).flip\n   23:     val resp = Valid(new HellaCacheResp).flip\n   24      val replay = Decoupled(new HellaCacheReq)\n   25    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/TLB.scala:\n  154      val req = Decoupled(new TLBReq(lgMaxSize)).flip\n  155      val resp = new TLBResp().asOutput\n  156:     val sfence = Valid(new SFenceReq).asInput\n  157      val ptw = new TLBPTWIO\n  158      val kill = Bool(INPUT) // suppress a TLB refill, one cycle after a miss\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/BusErrorUnit.scala:\n    5  import Chisel._\n    6  import Chisel.ImplicitConversions._\n    7: import chisel3.util.Valid\n    8  import chisel3.DontCare\n    9  import freechips.rocketchip.config.Parameters\n   ..\n   17  \n   18  trait BusErrors extends Bundle {\n   19:   def toErrorList: List[Option[(Valid[UInt], String, String)]]\n   20  }\n   21  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/FPU.scala:\n  183  \n  184    val fcsr_rm = Bits(INPUT, FPConstants.RM_SZ)\n  185:   val fcsr_flags = Valid(Bits(width = FPConstants.FLAGS_SZ))\n  186  \n  187    val store_data = Bits(OUTPUT, fLen)\n  ...\n  456    }\n  457    val io = new Bundle {\n  458:     val in = Valid(new FPInput).flip\n  459:     val out = Valid(new Output)\n  460    }\n  461  \n  ...\n  523  class IntToFP(val latency: Int)(implicit p: Parameters) extends FPUModule()(p) with ShouldBeRetimed {\n  524    val io = new Bundle {\n  525:     val in = Valid(new IntToFPInput).flip\n  526:     val out = Valid(new FPResult)\n  527    }\n  528  \n  ...\n  568  class FPToFP(val latency: Int)(implicit p: Parameters) extends FPUModule()(p) with ShouldBeRetimed {\n  569    val io = new Bundle {\n  570:     val in = Valid(new FPInput).flip\n  571:     val out = Valid(new FPResult)\n  572      val lt = Bool(INPUT) // from FPToInt\n  573    }\n  ...\n  694  \n  695    val io = new Bundle {\n  696:     val in = Valid(new FPInput).flip\n  697:     val out = Valid(new FPResult)\n  698    }\n  699  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Broadcast.scala:\n  402      val in_a  = Flipped(Decoupled(new TLBundleA(edgeIn.bundle)))\n  403      val out_a = Decoupled(new TLBundleA(edgeOut.bundle))\n  404:     val probe = Input(Valid(new ProbeTrackInfo(caches)))\n  405      val probenack = Input(Bool())\n  406      val probedack = Input(Bool())\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/SRAM.scala:\n   13  \n   14  class TLRAMErrors(val params: ECCParams, val addrBits: Int) extends Bundle with CanHaveErrors {\n   15:   val correctable   = (params.code.canCorrect && params.notifyErrors).option(Valid(UInt(addrBits.W)))\n   16:   val uncorrectable = (params.code.canDetect  && params.notifyErrors).option(Valid(UInt(addrBits.W)))\n   17  }\n   18  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/IDPool.scala:\n   11  \n   12    val io = IO(new Bundle {\n   13:     val free = Flipped(Valid(UInt(idWidth.W)))\n   14      val alloc = if (revocableSelect) Decoupled(UInt(idWidth.W)) else Irrevocable(UInt(idWidth.W))\n   15    })\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Misc.scala:\n   63    }\n   64    def apply[T <: Data](valids: Seq[ValidIO[T]]): ValidIO[T] = {\n   65:     val out = Wire(Valid(valids.head.bits.cloneType))\n   66      out.valid := valids.map(_.valid).reduce(_ || _)\n   67      out.bits := MuxCase(valids.head.bits,\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ReadyValidCancel.scala:\n   13    * This differs from [[ReadyValidCancel]] as there is no `ready` line that the consumer can use\n   14    * to put back pressure on the producer.\n   15:   * @param gen the type of data to be wrapped in Valid/Cancel\n   16    */\n   17  class ValidCancel[+T <: Data](gen: T) extends Bundle {\n   ..\n   22    override def cloneType: this.type = ValidCancel(gen).asInstanceOf[this.type]\n   23  \n   24:   /** Down-converts a ValidCancel output to a Valid bundle, dropping early/late timing split. */\n   25:   def andNotCancel(): Valid[T] = {\n   26:     val out = Wire(new Valid(gen))\n   27      out.valid := validQual()\n   28      out.bits  := bits\n   ..\n   42    * the producer uses the interface as-is (outputs bits)\n   43    * while the consumer uses the flipped interface (inputs bits).\n   44:   * @param gen the type of data to be wrapped in Ready/Valid/Cancel\n   45    */\n   46  class ReadyValidCancel[+T <: Data](gen: T) extends ValidCancel(gen)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Replacement.scala:\n   16    def hit: Unit\n   17    def access(touch_way: UInt): Unit\n   18:   def access(touch_ways: Seq[Valid[UInt]]): Unit\n   19    def state_read: UInt\n   20    def get_next_state(state: UInt, touch_way: UInt): UInt\n   21:   def get_next_state(state: UInt, touch_ways: Seq[Valid[UInt]]): UInt = {\n   22      touch_ways.foldLeft(state)((prev, touch_way) => Mux(touch_way.valid, get_next_state(prev, touch_way.bits), prev))\n   23    }\n   ..\n   46    def hit = {}\n   47    def access(touch_way: UInt) = {}\n   48:   def access(touch_ways: Seq[Valid[UInt]]) = {}\n   49    def get_next_state(state: UInt, touch_way: UInt) = 0.U //DontCare\n   50    def get_replace_way(state: UInt) = way\n   ..\n   59  abstract class SetAssocReplacementPolicy {\n   60    def access(set: UInt, touch_way: UInt): Unit\n   61:   def access(sets: Seq[UInt], touch_ways: Seq[Valid[UInt]]): Unit\n   62    def way(set: UInt): UInt\n   63  }\n   ..\n  114      state_reg := get_next_state(state_reg, touch_way)\n  115    }\n  116:   def access(touch_ways: Seq[Valid[UInt]]): Unit = {\n  117      when (touch_ways.map(_.valid).orR) {\n  118        state_reg := get_next_state(state_reg, touch_ways)\n  ...\n  172      state_reg := get_next_state(state_reg, touch_way)\n  173    }\n  174:   def access(touch_ways: Seq[Valid[UInt]]): Unit = {\n  175      when (touch_ways.map(_.valid).orR) {\n  176        state_reg := get_next_state(state_reg, touch_ways)\n  ...\n  309    }\n  310  \n  311:   def access(sets: Seq[UInt], touch_ways: Seq[Valid[UInt]]) = {\n  312      require(sets.size == touch_ways.size, \"internal consistency check: should be same number of simultaneous updates for sets and touch_ways\")\n  313      for (set <- 0 until n_sets) {\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ScatterGather.scala:\n   80    // Put 0, 1, 2, 3 ... at all of the lanes with mask=1\n   81    val sum = RipplePrefixSum(0.U(bits.W) +: mask.asBools.map { x => WireInit(UInt(bits.W), x) })(_+_)\n   82:   val input = Wire(Vec(size, Valid(UInt(bits.W))))\n   83    for (i <- 0 until size) {\n   84      input(i).valid := mask(i)\n   ..\n   97    mask := mask + !io.finished\n   98  \n   99:   val input = Wire(Vec(size, Valid(UInt(bits.W))))\n  100    for (i <- 0 until size) {\n  101      input(i).valid := mask(i)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/Timer.scala:\n   12  class Timer(initCount: Int, maxInflight: Int) extends Module {\n   13    val io = new Bundle {\n   14:     val start = Valid(UInt(width = log2Up(maxInflight))).flip\n   15:     val stop = Valid(UInt(width = log2Up(maxInflight))).flip\n   16:     val timeout = Valid(UInt(width = log2Up(maxInflight)))\n   17    }\n   18  \n\n81 matches across 27 files\n\n\nSearching 386 files for \"asTypeOf\" (case sensitive, whole word)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala:\n   49      val tail = RegInit(0.U(32.W))\n   50  \n   51:     val s1 = RegInit(0.U.asTypeOf(chisel3.Valid(in.a.bits.cloneType)));chisel3.dontTouch(s1)\n   52      s1.bits := in.a.bits\n   53  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/Debug.scala:\n  332      //               register accesses, which will keep returning 'busy' to the debugger interface.\n  333  \n  334:     val DMCONTROLReset = WireInit(0.U.asTypeOf(new DMCONTROLFields()))\n  335:     val DMCONTROLNxt = WireInit(0.U.asTypeOf(new DMCONTROLFields()))\n  336:     val DMCONTROLReg = RegNext(next=DMCONTROLNxt, init=0.U.asTypeOf(DMCONTROLNxt)).suggestName(\"DMCONTROLReg\")\n  337  \n  338      val hartsel_mask = if (nComponents > 1) ((1 << p(MaxHartIdBits)) - 1).U else 0.U\n  339:     val DMCONTROLWrData = WireInit(0.U.asTypeOf(new DMCONTROLFields()))\n  340      val dmactiveWrEn        = WireInit(false.B)\n  341      val ndmresetWrEn        = WireInit(false.B)\n  ...\n  372      // (implying nonexistence according to the Debug Spec).\n  373  \n  374:     val HARTINFORdData = WireInit(0.U.asTypeOf(new HARTINFOFields()))\n  375      if (cfg.atzero) when (dmAuthenticated) {\n  376        HARTINFORdData.dataaccess  := true.B\n  ...\n  390        // The following need to be declared even if supportHartArray is false due to reference\n  391        // at compile time by dmiNode.regmap\n  392:     val HAWINDOWSELWrData = WireInit(0.U.asTypeOf(new HAWINDOWSELFields()))\n  393      val HAWINDOWSELWrEn   = WireInit(false.B)\n  394  \n  395:     val HAWINDOWRdData = WireInit(0.U.asTypeOf(new HAWINDOWFields()))\n  396:     val HAWINDOWWrData = WireInit(0.U.asTypeOf(new HAWINDOWFields()))\n  397      val HAWINDOWWrEn   = WireInit(false.B)\n  398  \n  ...\n  402      }\n  403  \n  404:     val HAWINDOWSELNxt = WireInit(0.U.asTypeOf(new HAWINDOWSELFields()))\n  405:     val HAWINDOWSELReg = RegNext(next=HAWINDOWSELNxt, init=0.U.asTypeOf(HAWINDOWSELNxt))\n  406  \n  407      if (supportHartArray) {\n  408:       val HAWINDOWSELReset = WireInit(0.U.asTypeOf(new HAWINDOWSELFields()))\n  409  \n  410        HAWINDOWSELNxt := HAWINDOWSELReg\n  ...\n  427          val sliceMask = if (nComponents > ((ii*haWindowSize) + haWindowSize-1)) (BigInt(1) << haWindowSize) - 1  // All harts in this slice exist\n  428                          else (BigInt(1)<<(nComponents - (ii*haWindowSize))) - 1         // Partial last slice\n  429:         val HAMASKRst = WireInit(0.U.asTypeOf(new HAWINDOWFields()))\n  430:         val HAMASKNxt = WireInit(0.U.asTypeOf(new HAWINDOWFields()))\n  431:         val HAMASKReg = RegNext(next=HAMASKNxt, init=0.U.asTypeOf(HAMASKNxt))\n  432  \n  433          when (ii.U === HAWINDOWSELReg.hawindowsel) {\n  ...\n  469      val hrmask    = Wire(Vec(nComponents, Bool()))\n  470      val hrmaskNxt = Wire(Vec(nComponents, Bool()))\n  471:     val hrmaskReg = RegNext(next=hrmaskNxt, init=0.U.asTypeOf(hrmaskNxt)).suggestName(\"hrmaskReg\")\n  472  \n  473      hrmaskNxt := hrmaskReg\n  ...\n  550  \n  551      val debugIntNxt = WireInit(VecInit(Seq.fill(nComponents) {false.B} ))\n  552:     val debugIntRegs = RegNext(next=debugIntNxt, init=0.U.asTypeOf(debugIntNxt)).suggestName(\"debugIntRegs\")\n  553  \n  554      debugIntNxt := debugIntRegs\n  ...\n  607      if (cfg.hasHartResets) {\n  608        val hartResetNxt = Wire(Vec(nComponents, Bool()))\n  609:       val hartResetReg = RegNext(next=hartResetNxt, init=0.U.asTypeOf(hartResetNxt))\n  610  \n  611        for (component <- 0 until nComponents) {\n  ...\n  883      //----DMSTATUS\n  884  \n  885:     val DMSTATUSRdData = WireInit(0.U.asTypeOf(new DMSTATUSFields()))\n  886      DMSTATUSRdData.authenticated := dmAuthenticated\n  887      DMSTATUSRdData.version       := 2.U    // Version 0.13\n  ...\n  929      //----DMCS2 (Halt Groups)\n  930  \n  931:     val DMCS2RdData    = WireInit(0.U.asTypeOf(new DMCS2Fields()))\n  932:     val DMCS2WrData    = WireInit(0.U.asTypeOf(new DMCS2Fields()))\n  933      val hgselectWrEn   = WireInit(false.B)\n  934      val hgwriteWrEn    = WireInit(false.B)\n  ...\n 1072  \n 1073      val haltedSummary = Cat(haltedStatus.map(_.orR).reverse)\n 1074:     val HALTSUM1RdData = haltedSummary.asTypeOf(new HALTSUM1Fields())\n 1075  \n 1076      val selectedHaltedStatus = Mux((selectedHartReg >> 5) > numHaltedStatus.U, 0.U, haltedStatus(selectedHartReg >> 5))\n 1077:     val HALTSUM0RdData = selectedHaltedStatus.asTypeOf(new HALTSUM0Fields())\n 1078  \n 1079      // Since we only support 1024 harts, we don't implement HALTSUM2 or HALTSUM3\n ....\n 1081      //----ABSTRACTCS\n 1082  \n 1083:     val ABSTRACTCSReset = WireInit(0.U.asTypeOf(new ABSTRACTCSFields()))\n 1084      ABSTRACTCSReset.datacount   := cfg.nAbstractDataWords.U\n 1085      ABSTRACTCSReset.progbufsize := cfg.nProgramBufferWords.U\n 1086  \n 1087      val ABSTRACTCSReg       = Reg(new ABSTRACTCSFields())\n 1088:     val ABSTRACTCSWrData    = WireInit(0.U.asTypeOf(new ABSTRACTCSFields()))\n 1089      val ABSTRACTCSRdData    = WireInit(ABSTRACTCSReg)\n 1090  \n ....\n 1128      //---- ABSTRACTAUTO\n 1129  \n 1130:     val ABSTRACTAUTOReset     = WireInit(0.U.asTypeOf(new ABSTRACTAUTOFields()))\n 1131      val ABSTRACTAUTOReg       = Reg(new ABSTRACTAUTOFields())\n 1132:     val ABSTRACTAUTOWrData    = WireInit(0.U.asTypeOf(new ABSTRACTAUTOFields()))\n 1133      val ABSTRACTAUTORdData    = WireInit(ABSTRACTAUTOReg)\n 1134  \n ....\n 1169      //---- COMMAND\n 1170  \n 1171:     val COMMANDReset = WireInit(0.U.asTypeOf(new COMMANDFields()))\n 1172      val COMMANDReg = Reg(new COMMANDFields())\n 1173  \n 1174      val COMMANDWrDataVal    = WireInit(0.U(32.W))\n 1175:     val COMMANDWrData       = WireInit(COMMANDWrDataVal.asTypeOf(new COMMANDFields()))\n 1176      val COMMANDWrEnMaybe    = WireInit(false.B)\n 1177      val COMMANDWrEnLegal    = WireInit(false.B)\n ....\n 1380      val goAbstract   = WireInit(false.B)\n 1381      val goCustom     = WireInit(false.B)\n 1382:     val jalAbstract  = WireInit(Instructions.JAL.value.U.asTypeOf(new GeneratedUJ()))\n 1383      jalAbstract.setImm(ABSTRACT(cfg) - WHERETO)\n 1384  \n ....\n 1400      }\n 1401  \n 1402:     val flags = WireInit(VecInit(Seq.fill(1 << selectedHartReg.getWidth) {0.U.asTypeOf(new flagBundle())} ))\n 1403      assert ((hartSelFuncs.hartSelToHartId(selectedHartReg) < flags.size.U),\n 1404        s\"HartSel to HartId Mapping is illegal for this Debug Implementation, because HartID must be < ${flags.size} for it to work.\")\n ....\n 1414      //----------------------------\n 1415  \n 1416:     val accessRegisterCommandWr  = WireInit(COMMANDWrData.asUInt().asTypeOf(new ACCESS_REGISTERFields()))\n 1417:     val accessRegisterCommandReg = WireInit(COMMANDReg.asUInt().asTypeOf(new ACCESS_REGISTERFields()))\n 1418  \n 1419      // TODO: Quick Access\n ....\n 1474        val offset = if (cfg.atzero) DATA else (DATA-0x800) & 0xFFF\n 1475        val base = if (cfg.atzero) 0.U else Mux(accessRegisterCommandReg.regno(0), 8.U, 9.U)\n 1476:       inst.opcode := (Instructions.LW.value.U.asTypeOf(new GeneratedI())).opcode\n 1477        inst.rd     := (accessRegisterCommandReg.regno & 0x1F.U)\n 1478        inst.funct3 := accessRegisterCommandReg.size\n ....\n 1486        val offset = if (cfg.atzero) DATA else (DATA-0x800) & 0xFFF\n 1487        val base = if (cfg.atzero) 0.U else Mux(accessRegisterCommandReg.regno(0), 8.U, 9.U)\n 1488:       inst.opcode := (Instructions.SW.value.U.asTypeOf(new GeneratedS())).opcode\n 1489        inst.immlo  := (offset & 0x1F).U\n 1490        inst.funct3 := accessRegisterCommandReg.size\n ....\n 1498        val inst = Wire(new GeneratedCSR())\n 1499        val base = Mux(accessRegisterCommandReg.regno(0), 8.U, 9.U)     // use s0 as base for odd regs, s1 as base for even regs\n 1500:       inst := (Instructions.CSRRW.value.U.asTypeOf(new GeneratedCSR()))\n 1501        inst.imm := CSRs.dscratch1.U\n 1502        inst.rs1 := base\n ....\n 1506  \n 1507      val nop = Wire(new GeneratedI())\n 1508:     nop := Instructions.ADDI.value.U.asTypeOf(new GeneratedI())\n 1509      nop.rd   := 0.U\n 1510      nop.rs1  := 0.U\n ....\n 1512  \n 1513      val isa = Wire(new GeneratedI())\n 1514:     isa := Instructions.ADDIW.value.U.asTypeOf(new GeneratedI())\n 1515      isa.rd   := 0.U\n 1516      isa.rs1  := 0.U\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/DebugTransport.scala:\n  248    //--------------------------------------------------------\n  249    // Actual JTAG TAP\n  250:   val idcode = WireInit(0.U.asTypeOf(new JTAGIdcodeBundle()))\n  251    idcode.always1    := 1.U\n  252    idcode.version    := io.jtag_version\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/Periphery.scala:\n  254        tckHalfPeriod: Int = 2,\n  255        cmdDelay: Int = 2,\n  256:       psd: PSDTestMode = 0.U.asTypeOf(new PSDTestMode()))\n  257        (implicit p: Parameters): Unit =  {\n  258      connectDebugClockAndReset(debugOpt, c)\n  ...\n  309    def tieoffDebug(debugOpt: Option[DebugIO], resetctrlOpt: Option[ResetCtrlIO] = None, psdio: Option[PSDIO] = None)(implicit p: Parameters): Bool = {\n  310  \n  311:     psdio.foreach(_.psd.foreach { _ <> 0.U.asTypeOf(new PSDTestMode()) } )\n  312      resetctrlOpt.map { rcio => rcio.hartIsInReset.map { _ := false.B }}\n  313      debugOpt.map { debug =>\n\n/share/code/rocket-chip-dongdeji/src/main/scala/devices/debug/SBA.scala:\n   44      val SBCSFieldsReg = Reg(new SBCSFields()).suggestName(\"SBCSFieldsReg\")\n   45  \n   46:     val SBCSFieldsRegReset = WireInit(0.U.asTypeOf(new SBCSFields()))\n   47      SBCSFieldsRegReset.sbversion   := 1.U(1.W) // This code implements a version of the spec after January 1, 2018\n   48      SBCSFieldsRegReset.sbbusy      := (sb2tl.module.io.sbStateOut =/= SystemBusAccessState.Idle.id.U)\n   ..\n   55      SBCSFieldsRegReset.sbaccess8   := (cfg.maxSupportedSBAccess >=   8).B\n   56  \n   57:     val SBCSRdData         = WireInit(0.U.asTypeOf(new SBCSFields())).suggestName(\"SBCSRdData\")\n   58  \n   59      val SBCSWrDataVal      = WireInit(0.U(32.W))\n   60:     val SBCSWrData         = WireInit(SBCSWrDataVal.asTypeOf(new SBCSFields()))\n   61      \n   62      val sberrorWrEn        = WireInit(false.B)\n   ..\n  238      \n  239      when (~dmAuthenticated) {    // Read value must be 0 if not authenticated\n  240:       SBCSRdData := 0.U.asTypeOf(new SBCSFields())\n  241      }\n  242  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/BundleBridge.scala:\n  166  \n  167    def orReduction[T <: Data](registered: Boolean)(seq: Seq[T]): T = {\n  168:     val x = seq.reduce((a,b) => (a.asUInt | b.asUInt).asTypeOf(seq.head))\n  169      if (registered) safeRegNext(x) else x\n  170    }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/formal/FormalUtils.scala:\n  227        TernaryIf(case_var.asUInt===select.asUInt, ret_val.asUInt, 0.U)\n  228      })\n  229:     sel_vec.reduce( _ | _).asTypeOf(sel_ret(0)._2)\n  230    }\n  231  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/groundtest/DummyPTW.scala:\n   32    val s2_valid = Reg(next = req_arb.io.out.valid && req_arb.io.out.bits.valid)\n   33  \n   34:   val s2_resp = Wire(init = 0.U.asTypeOf(new PTWResp))\n   35    s2_resp.pte.ppn := s2_ppn\n   36    s2_resp.pte.reserved_for_software := UInt(0)\n   ..\n   48      requestor.resp.valid := s2_valid && s2_chosen === UInt(i)\n   49      requestor.resp.bits := s2_resp\n   50:     requestor.status := 0.U.asTypeOf(requestor.status)\n   51      requestor.ptbr.mode := requestor.ptbr.pgLevelsToMode(pgLevels).U\n   52      requestor.ptbr.asid := UInt(0)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/jtag/JtagShifter.scala:\n  158  \n  159    val updateBits = Cat(regs.reverse)(updateWidth-1, 0)\n  160:   io.update.bits := updateBits.asTypeOf(io.update.bits)\n  161  \n  162    val captureBits = io.capture.bits.asUInt()\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/CSR.scala:\n  255  object VType {\n  256    def fromUInt(that: UInt, ignore_vill: Boolean = false)(implicit p: Parameters): VType = {\n  257:     val res = 0.U.asTypeOf(new VType)\n  258:     val in = that.asTypeOf(res)\n  259      val vill = (in.max_vsew < in.vsew) || !in.lmul_ok || in.reserved =/= 0 || in.vill\n  260      when (!vill || ignore_vill) {\n  ...\n  515      reg_dscratch1.map(r => CSRs.dscratch1 -> r)\n  516  \n  517:   val read_mnstatus = WireInit(0.U.asTypeOf(new MStatus()))\n  518    read_mnstatus.mpp := io.status.mpp\n  519    val nmi_csrs = if (!usingNMI) LinkedHashMap() else LinkedHashMap[Int,Bits](\n  ...\n  584      val read_sie = reg_mie & read_mideleg\n  585      val read_sip = read_mip & read_mideleg\n  586:     val read_sstatus = Wire(init = 0.U.asTypeOf(new MStatus))\n  587      read_sstatus.sd := io.status.sd\n  588      read_sstatus.uxl := io.status.uxl\n  ...\n  615    if (reg_pmp.nonEmpty) {\n  616      require(reg_pmp.size <= CSR.maxPMPs)\n  617:     val read_pmp = reg_pmp.padTo(CSR.maxPMPs, 0.U.asTypeOf(new PMP))\n  618      for (i <- 0 until read_pmp.size by pmpCfgPerCSR)\n  619        read_mapping += (CSRs.pmpcfg0 + pmpCfgIndex(i)) -> read_pmp.map(_.cfg).slice(i, i + pmpCfgPerCSR).asUInt\n  ...\n  938        // io.interrupts.seip.  We don't want the value on the PLIC line to\n  939        // inadvertently be OR'd into read_mip.seip.\n  940:       val new_mip = readModifyWriteCSR(io.rw.cmd, reg_mip.asUInt, io.rw.wdata).asTypeOf(new MIP)\n  941        if (usingSupervisor) {\n  942          reg_mip.ssip := new_mip.ssip\n  ...\n 1053            }\n 1054            when (decoded_addr(CSRs.tdata1)) {\n 1055:             bp.control := wdata.asTypeOf(bp.control)\n 1056  \n 1057              val prevChain = if (i == 0) false.B else reg_bp(i-1).control.chain\n ....\n 1059              val nextChain = if (i >= nBreakpoints-1) true.B else reg_bp(i+1).control.chain\n 1060              val nextDMode = if (i >= nBreakpoints-1) true.B else reg_bp(i+1).control.dmode\n 1061:             val newBPC = readModifyWriteCSR(io.rw.cmd, bp.control.asUInt, io.rw.wdata).asTypeOf(bp.control)\n 1062              val dMode = newBPC.dmode && reg_debug && (prevDMode || !prevChain)\n 1063              bp.control.dmode := dMode\n ....\n 1120      when (reset.asBool) {\n 1121        reg_vconfig.get.vl := 0.U\n 1122:       reg_vconfig.get.vtype := 0.U.asTypeOf(new VType)\n 1123        reg_vconfig.get.vtype.vill := true\n 1124      }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/DCache.scala:\n  284        }\n  285        val s1_meta = tag_array.read(metaIdx, metaReq.valid && !metaReq.bits.write)\n  286:       val s1_meta_uncorrected = s1_meta.map(tECC.decode(_).uncorrected.asTypeOf(new L1Metadata))\n  287        val s1_tag = s1_paddr >> tagLSB\n  288        val s1_meta_hit_way = s1_meta_uncorrected.map(r => r.coh.isValid() && r.tag === s1_tag).asUInt\n  ...\n  330    val s2_meta_uncorrectable_errors = s1_meta_decoded.map(m => RegEnable(m.uncorrectable, s1_meta_clk_en)).asUInt\n  331    val s2_meta_error_uncorrectable = s2_meta_uncorrectable_errors.orR\n  332:   val s2_meta_corrected = s1_meta_decoded.map(m => RegEnable(m.corrected, s1_meta_clk_en).asTypeOf(new L1Metadata))\n  333    val s2_meta_error = (s2_meta_uncorrectable_errors | s2_meta_correctable_errors).orR\n  334    val s2_flush_valid = s2_flush_valid_pre_tag_ecc && !s2_meta_error\n  ...\n  899  \n  900    val s1_xcpt_valid = tlb.io.req.valid && !s1_isSlavePortAccess && !s1_nack\n  901:   io.cpu.s2_xcpt := Mux(RegNext(s1_xcpt_valid), s2_tlb_xcpt, 0.U.asTypeOf(s2_tlb_xcpt))\n  902  \n  903    if (usingDataScratchpad) {\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/IBuf.scala:\n   94        io.inst(i).valid := valid(j) && full_insn\n   95        io.inst(i).bits.xcpt0 := xcpt(j)\n   96:       io.inst(i).bits.xcpt1 := Mux(exp.io.rvc, 0.U, xcpt(j+1).asUInt).asTypeOf(new FrontendExceptions)\n   97        io.inst(i).bits.replay := replay\n   98        io.inst(i).bits.rvc := exp.io.rvc\n   ..\n  107        io.inst(i).valid := valid(i)\n  108        io.inst(i).bits.xcpt0 := xcpt(i)\n  109:       io.inst(i).bits.xcpt1 := 0.U.asTypeOf(new FrontendExceptions)\n  110        io.inst(i).bits.replay := ic_replay(i)\n  111        io.inst(i).bits.rvc := false\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/ICache.scala:\n  304  \n  305    val s1_clk_en = s1_valid || s1_slaveValid\n  306:   val s2_tag_hit = RegEnable(Mux(s1_dont_read, 0.U.asTypeOf(s1_tag_hit), s1_tag_hit), s1_clk_en)\n  307    val s2_hit_way = OHToUInt(s2_tag_hit)\n  308    val s2_scratchpad_word_addr = Cat(s2_hit_way, Mux(s2_slaveValid, s1s3_slaveAddr, io.s2_vaddr)(untagBits-1, log2Ceil(wordBits/8)), UInt(0, log2Ceil(wordBits/8)))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/NBDcache.scala:\n 1003    val s1_xcpt_valid = dtlb.io.req.valid && !s1_nack\n 1004    val s1_xcpt = dtlb.io.resp\n 1005:   io.cpu.s2_xcpt := Mux(RegNext(s1_xcpt_valid), RegEnable(s1_xcpt, s1_clk_en), 0.U.asTypeOf(s1_xcpt))\n 1006    io.cpu.s2_uncached := false.B\n 1007    io.cpu.s2_paddr := s2_req.addr\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/PMP.scala:\n  137  class PMPHomogeneityChecker(pmps: Seq[PMP])(implicit p: Parameters) {\n  138    def apply(addr: UInt, pgLevel: UInt): Bool = {\n  139:     pmps.foldLeft((true.B, 0.U.asTypeOf(new PMP))) { case ((h, prev), pmp) =>\n  140        (h && pmp.homogeneous(addr, pgLevel, prev), pmp)\n  141      }._1\n  ...\n  156  \n  157    val default = if (io.pmp.isEmpty) true.B else io.prv > PRV.S\n  158:   val pmp0 = WireInit(0.U.asTypeOf(new PMP))\n  159    pmp0.cfg.r := default\n  160    pmp0.cfg.w := default\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/PTW.scala:\n  263      when (s2_valid && s2_error) { valid.foreach { _ := 0.U }}\n  264  \n  265:     val s2_entry_vec = s2_rdata.map(_.uncorrected.asTypeOf(new L2TLBEntry(nL2TLBSets)))\n  266      val s2_hit_vec = (0 until coreParams.nL2TLBWays).map(way => s2_valid_vec(way) && (r_tag === s2_entry_vec(way).tag))\n  267      val s2_hit = s2_valid && s2_hit_vec.orR\n\n/share/code/rocket-chip-dongdeji/src/main/scala/rocket/TLB.scala:\n   81    val data = Vec(nSectors, UInt(width = new TLBEntryData().getWidth))\n   82    val valid = Vec(nSectors, Bool())\n   83:   def entry_data = data.map(_.asTypeOf(new TLBEntryData))\n   84  \n   85    private def sectorIdx(vpn: UInt) = vpn.extract(nSectors.log2-1, 0)\n   86:   def getData(vpn: UInt) = OptimizationBarrier(data(sectorIdx(vpn)).asTypeOf(new TLBEntryData))\n   87    def sectorHit(vpn: UInt) = valid.orR && sectorTagMatch(vpn)\n   88    def sectorTagMatch(vpn: UInt) = ((tag ^ vpn) >> nSectors.log2) === 0\n\n/share/code/rocket-chip-dongdeji/src/main/scala/tile/FPU.scala:\n  289    }\n  290  \n  291:   def unpackIEEE(x: UInt) = x.asTypeOf(ieeeBundle)\n  292  \n  293    def recode(x: UInt) = hardfloat.recFNFromFN(exp, sig, x)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/LanePositionedQueue.scala:\n  455      Mux(!isPow2(rows).B && deq_row_half === (rows/2-2).U, 0.U,\n  456      deq_row_half + 2.U))))))\n  457:   val ram_o = ecc.decode(ram.read(read_row, ren)).corrected.asTypeOf(Vec(2*lanes, gen))\n  458    when (wen && !ren) { ram.write(write_row, ecc.encode(ram_i.asUInt)) }\n  459  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/MultiPortQueue.scala:\n   34      val highHoles = sparse.map(x => WireInit(UInt(popBits.W), !x.valid))\n   35      val enq_dense = Gather(\n   36:       Seq.fill(dense.lanes) { 0.U.asTypeOf(chiselTypeOf(sparse.head.bits)) } ++ sparse.map(_.bits),\n   37        Seq.fill(dense.lanes) { lowHoles } ++ DensePrefixSum(lowHoles +: highHoles)(_ + _).tail)\n   38  \n   ..\n   57  \n   58      // Scatter data from rotated lanes to deq ports\n   59:     val bits = dense.bits ++ dense.bits ++ Seq.fill(sparse.size) { 0.U.asTypeOf(chiselTypeOf(sparse.head.bits)) }\n   60      val popBits = log2Ceil(dense.lanes + sparse.size)\n   61      val lowHoles = dense.lanes.U(popBits.W) - offset\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/ShiftReg.scala:\n   46      name.foreach{ chain.suggestName(_) }\n   47      chain.io.d := in.asUInt\n   48:     chain.io.q.asTypeOf(in)\n   49    }\n   50  }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/util/SynchronizerReg.scala:\n  209      cdc_reg.io.d := in.asUInt\n  210      cdc_reg.io.en := en\n  211:     cdc_reg.io.q.asTypeOf(in)\n  212    }\n  213  }\n\n77 matches across 22 files\n\n\nSearching 61 files for \"aqure\" (case sensitive, whole word)\n\n0 matches\n\nSearching 61 files for \"require\" (case sensitive, whole word)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/ahb/AHBLite.scala:\n   14    lazy val module = new LazyModuleImp(this) {\n   15      (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>\n   16:       require (edgeOut.slave.lite) // or else this adapter is pointless\n   17  \n   18        out.hmastlock.get := in.hlock.get\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/ahb/Parameters.scala:\n   20    device: Option[Device] = None)\n   21  {\n   22:   address.foreach { a => require (a.finite) }\n   23:     address.combinations(2).foreach { case Seq(x,y) => require (!x.overlaps(y)) }\n   24  \n   25    val name = nodePath.lastOption.map(_.lazyModule.name).getOrElse(\"disconnected\")\n   ..\n   30  \n   31    // The device had better not support a transfer larger than it's alignment\n   32:   require (minAlignment >= maxTransfer)\n   33  \n   34    def toResource: ResourceAddress = {\n   ..\n   49    requestKeys:    Seq[BundleKeyBase]   = Nil)\n   50  {\n   51:   require (!slaves.isEmpty)\n   52:   require (isPow2(beatBytes))\n   53  \n   54    val minMaxTransfer = slaves.map(_.minMaxTransfer).min // useful for fragmentation\n   ..\n   57  \n   58    // Check the link is not pointlessly wide\n   59:   require (maxTransfer >= beatBytes)\n   60    // Check that the link can be implemented in AHB\n   61:   require (maxTransfer <= beatBytes * AHBParameters.maxTransfer)\n   62  \n   63    // Require disjoint ranges for addresses\n   64    slaves.combinations(2).foreach { case Seq(x,y) =>\n   65      x.address.foreach { a => y.address.foreach { b =>\n   66:       require (!a.overlaps(b))\n   67      } }\n   68    }\n   ..\n   85    lite:       Boolean)\n   86  {\n   87:   require (dataBits >= 8)\n   88:   require (addrBits >= 1)\n   89:   require (isPow2(dataBits))\n   90  \n   91    // Bring the globals into scope\n   ..\n   97  \n   98    def union(x: AHBBundleParameters) = {\n   99:     require (x.lite == lite)\n  100      AHBBundleParameters(\n  101        max(addrBits, x.addrBits),\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/ahb/RegisterRouter.scala:\n   21      lite = true)))\n   22  {\n   23:   require (address.contiguous)\n   24  \n   25    // Calling this method causes the matching AHB bundle to be\n   ..\n  106    extends AHBRegisterRouterBase(AddressSet(base, size-1), interrupts, concurrency, beatBytes, undefZero, executable)\n  107  {\n  108:   require (isPow2(size))\n  109:   // require (size >= 4096) ... not absolutely required, but highly recommended\n  110  \n  111    lazy val module = moduleBuilder(bundleBuilder(AHBRegBundleArg()), this)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/ahb/ToTL.scala:\n  142        // Although the AHB spec says:\n  143        //   \"A slave only has to provide valid data when a transfer completes with\n  144:       //    an OKAY response. ERROR responses do not require valid read data.\"\n  145        // We choose, nevertheless, to provide the read data for the failed request.\n  146        // Unfortunately, this comes at the cost of a bus-wide register.\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/ahb/Xbar.scala:\n   22    lazy val module = new LazyModuleImp(this) {\n   23      if (node.edges.in.size >= 1) {\n   24:       require (node.edges.in.size == 1, \"AHBFanout does not support multiple masters\")\n   25:       require (node.edges.out.size > 0, \"AHBFanout requires at least one slave\")\n   26:       node.edges.out.foreach { eo => require (eo.slave.lite, s\"AHBFanout only supports AHB-Lite slaves (${eo.slave.slaves.map(_.name)})\") }\n   27  \n   28        // Require consistent bus widths\n   ..\n   31        edgesOut.foreach { edge =>\n   32          val port = edge.slave\n   33:         require (port.beatBytes == port0.beatBytes,\n   34            s\"${port.slaves.map(_.name)} ${port.beatBytes} vs ${port0.slaves.map(_.name)} ${port0.beatBytes}\")\n   35        }\n   ..\n   64    lazy val module = new LazyModuleImp(this) {\n   65      if (node.edges.in.size >= 1) {\n   66:       require (node.edges.out.size == 1, \"AHBArbiter requires exactly one slave\")\n   67:       require (node.edges.in.size == 1, \"TODO: support more than one master\")\n   68  \n   69        val (in,  _) = node.in(0)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/apb/Parameters.scala:\n   20    device: Option[Device] = None)\n   21  {\n   22:   address.foreach { a => require (a.finite) }\n   23:     address.combinations(2).foreach { case Seq(x,y) => require (!x.overlaps(y)) }\n   24  \n   25    val name = nodePath.lastOption.map(_.lazyModule.name).getOrElse(\"disconnected\")\n   ..\n   43    requestKeys:    Seq[BundleKeyBase]   = Nil)\n   44  {\n   45:   require (!slaves.isEmpty)\n   46:   require (isPow2(beatBytes))\n   47  \n   48    val maxAddress = slaves.map(_.maxAddress).max\n   ..\n   51    slaves.combinations(2).foreach { case Seq(x,y) =>\n   52      x.address.foreach { a => y.address.foreach { b =>\n   53:       require (!a.overlaps(b))\n   54      } }\n   55    }\n   ..\n   71    responseFields: Seq[BundleFieldBase] = Nil)\n   72  {\n   73:   require (dataBits >= 8)\n   74:   require (addrBits >= 1)\n   75:   require (isPow2(dataBits))\n   76  \n   77    // Bring the globals into scope\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/apb/RegisterRouter.scala:\n   18      beatBytes  = beatBytes)))\n   19  {\n   20:   require (address.contiguous)\n   21  \n   22    // Calling this method causes the matching APB bundle to be\n   ..\n   87    extends APBRegisterRouterBase(AddressSet(base, size-1), interrupts, concurrency, beatBytes, undefZero, executable)\n   88  {\n   89:   require (isPow2(size))\n   90:   // require (size >= 4096) ... not absolutely required, but highly recommended\n   91  \n   92    lazy val module = moduleBuilder(bundleBuilder(APBRegBundleArg()), this)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/apb/ToTL.scala:\n   46        // We don't want to handle the case where the data is returned immediately\n   47        // on the same cycle that we send the transaction. Require and verify.\n   48:       require (edgeOut.manager.minLatency >= 1)\n   49        assert (!(in.psel && !in.penable && out.d.valid))\n   50  \n   ..\n   53        // The double negative here is to work around Chisel's broken implementation of widening ~x.\n   54        val aligned_addr =  ~(~in.paddr | (beatBytes-1).U)\n   55:       require(beatBytes == in.params.dataBits/8,\n   56                s\"TL beatBytes(${beatBytes}) doesn't match expected APB data width(${in.params.dataBits})\")\n   57        val data_size = UInt(log2Ceil(beatBytes))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/apb/Xbar.scala:\n   22    lazy val module = new LazyModuleImp(this) {\n   23      if (node.edges.in.size >= 1) {\n   24:       require (node.edges.in.size == 1, \"APBFanout does not support multiple masters\")\n   25:       require (node.edges.out.size > 0, \"APBFanout requires at least one slave\")\n   26  \n   27        val (in, _) = node.in(0)\n   ..\n   32        edgesOut.foreach { edge =>\n   33          val port = edge.slave\n   34:         require (port.beatBytes == port0.beatBytes,\n   35            s\"${port.slaves.map(_.name)} ${port.beatBytes} vs ${port0.slaves.map(_.name)} ${port0.beatBytes}\")\n   36        }\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Deinterleaver.scala:\n   22  class AXI4Deinterleaver(maxReadBytes: Int, buffer: BufferParams = BufferParams.default)(implicit p: Parameters) extends LazyModule\n   23  {\n   24:   require (maxReadBytes >= 1, s\"AXI4Deinterleaver: maxReadBytes must be at least 1, not $maxReadBytes\")\n   25:   require (isPow2(maxReadBytes), s\"AXI4Deinterleaver: maxReadBytes must be a power of two, not $maxReadBytes\")\n   26  \n   27    private def maxBeats(slave: AXI4SlavePortParameters): Int =\n   ..\n  115          in.r.bits  := deq_bits(deq_id)\n  116          val deq_OH_bools = deq_OH.asBools\n  117:         require(deq_OH_bools.size == qs.size, s\"deq_OH.size != qs.size (${deq_OH_bools.size} vs ${qs.size})\")\n  118          (deq_OH_bools zip qs) foreach { case (s, q) =>\n  119            q.deq.ready := s && in.r.fire()\n  ...\n  121  \n  122          val enq_OH_bools = enq_OH.asBools\n  123:         require(enq_OH_bools.size == qs.size, s\"enq_OH.size != qs.size (${enq_OH_bools.size} vs ${qs.size})\")\n  124          // Feed response into matching Q\n  125          val enq_readys = VecInit(qs.map(_.enq.ready))\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Delayer.scala:\n   13  {\n   14    val node = AXI4AdapterNode()\n   15:   require (0.0 <= q && q < 1)\n   16  \n   17    lazy val module = new LazyModuleImp(this) {\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Filter.scala:\n   15        val out = Sfilter(s)\n   16        out.foreach { o => // Confirm the filter only REMOVES capability\n   17:         o.address.foreach { a => require (s.address.map(_.contains(a)).reduce(_||_)) }\n   18:         require (o.regionType <= s.regionType)\n   19          // we allow executable to be changed both ways\n   20:         require (s.supportsWrite.contains(o.supportsWrite))\n   21:         require (s.supportsRead .contains(o.supportsRead))\n   22:         require (!o.interleavedId.isDefined || s.interleavedId == o.interleavedId)\n   23        }\n   24        out\n   ..\n   26      masterFn = { mp => mp.copy(masters = mp.masters.flatMap { m =>\n   27        val out = Mfilter(m)\n   28:       out.foreach { o => require (m.id.contains(o.id)) }\n   29        out\n   30      })})\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Fragmenter.scala:\n   38        // We don't support fragmenting to sub-beat accesses\n   39        slaves.foreach { s =>\n   40:         require (!s.supportsRead  || s.supportsRead.contains(beatBytes))\n   41:         require (!s.supportsWrite || s.supportsWrite.contains(beatBytes))\n   42        }\n   43  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/IdIndexer.scala:\n   21  class AXI4IdIndexer(idBits: Int)(implicit p: Parameters) extends LazyModule\n   22  {\n   23:   require (idBits >= 0, s\"AXI4IdIndexer: idBits must be > 0, not $idBits\")\n   24  \n   25    val node = AXI4AdapterNode(\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Parameters.scala:\n   21    device: Option[Device] = None) // The device will not interleave responses (R+B)\n   22  {\n   23:   address.foreach { a => require (a.finite) }\n   24:   address.combinations(2).foreach { case Seq(x,y) => require (!x.overlaps(y), s\"$x and $y overlap\") }\n   25  \n   26    val name = nodePath.lastOption.map(_.lazyModule.name).getOrElse(\"disconnected\")\n   ..\n   30  \n   31    // The device had better not support a transfer larger than its alignment\n   32:   require (minAlignment >= maxTransfer,\n   33      s\"minAlignment ($minAlignment) must be >= maxTransfer ($maxTransfer)\")\n   34  \n   ..\n   50    requestKeys:    Seq[BundleKeyBase]   = Nil)\n   51  {\n   52:   require (!slaves.isEmpty)\n   53:   require (isPow2(beatBytes))\n   54  \n   55    val maxTransfer = slaves.map(_.maxTransfer).max\n   ..\n   57  \n   58    // Check the link is not pointlessly wide\n   59:   require (maxTransfer >= beatBytes,\n   60      s\"maxTransfer ($maxTransfer) should not be smaller than bus width ($beatBytes)\")\n   61    // Check that the link can be implemented in AXI4\n   62    val limit = beatBytes * (1 << AXI4Parameters.lenBits)\n   63:   require (maxTransfer <= limit,\n   64      s\"maxTransfer ($maxTransfer) cannot be larger than $limit on a $beatBytes*8 width bus\")\n   65  \n   ..\n   67    slaves.combinations(2).foreach { case Seq(x,y) =>\n   68      x.address.foreach { a => y.address.foreach { b =>\n   69:       require (!a.overlaps(b), s\"$a and $b overlap\")\n   70      } }\n   71    }\n   ..\n   79    nodePath:  Seq[BaseNode] = Seq())\n   80  {\n   81:   maxFlight.foreach { m => require (m >= 0) }\n   82  }\n   83  \n   ..\n   92    // Require disjoint ranges for ids\n   93    IdRange.overlaps(masters.map(_.id)).foreach { case (x, y) =>\n   94:     require (!x.overlaps(y), s\"AXI4MasterParameters.id $x and $y overlap\")\n   95    }\n   96  }\n   ..\n  104    responseFields: Seq[BundleFieldBase] = Nil)\n  105  {\n  106:   require (dataBits >= 8, s\"AXI4 data bits must be >= 8 (got $dataBits)\")\n  107:   require (addrBits >= 1, s\"AXI4 addr bits must be >= 1 (got $addrBits)\")\n  108:   require (idBits >= 1, s\"AXI4 id bits must be >= 1 (got $idBits)\")\n  109:   require (isPow2(dataBits), s\"AXI4 data bits must be pow2 (got $dataBits)\")\n  110:   echoFields.foreach { f => require (f.key.isControl, s\"${f} is not a legal echo field\") }\n  111  \n  112    // Bring the globals into scope\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/RegisterRouter.scala:\n   24      minLatency = 1)))\n   25  {\n   26:   require (address.contiguous)\n   27  \n   28    // Calling this method causes the matching AXI4 bundle to be\n   ..\n  121    extends AXI4RegisterRouterBase(AddressSet(base, size-1), interrupts, concurrency, beatBytes, undefZero, executable)\n  122  {\n  123:   require (isPow2(size))\n  124:   // require (size >= 4096) ... not absolutely required, but highly recommended\n  125  \n  126    lazy val module = moduleBuilder(bundleBuilder(AXI4RegBundleArg()), this)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/ToTL.scala:\n   22  case class AXI4ToTLNode(wcorrupt: Boolean)(implicit valName: ValName) extends MixedAdapterNode(AXI4Imp, TLImp)(\n   23    dFn = { case mp =>\n   24:     mp.masters.foreach { m => require (m.maxFlight.isDefined, \"AXI4 must include a transaction maximum per ID to convert to TL\") }\n   25      val maxFlight = mp.masters.map(_.maxFlight.get).max\n   26      TLMasterPortParameters.v1(\n   ..\n   71        val addedBits = logFlight + 1 // +1 for read vs. write source ID\n   72  \n   73:       require (edgeIn.master.masters(0).aligned)\n   74        edgeOut.manager.requireFifo()\n   75  \n   76        // Look for an Error device to redirect bad requests\n   77        val errorDevs = edgeOut.manager.managers.filter(_.nodePath.last.lazyModule.className == \"TLError\")\n   78:       require (!errorDevs.isEmpty, \"There is no TLError reachable from AXI4ToTL. One must be instantiated.\")\n   79        val errorDev = errorDevs.maxBy(_.maxTransfer)\n   80        val error = errorDev.address.head.base\n   81:       require (errorDev.supportsPutPartial.contains(edgeOut.manager.maxTransfer),\n   82          s\"Error device supports ${errorDev.supportsPutPartial} PutPartial but must support ${edgeOut.manager.maxTransfer}\")\n   83:       require (errorDev.supportsGet.contains(edgeOut.manager.maxTransfer),\n   84          s\"Error device supports ${errorDev.supportsGet} Get but must support ${edgeOut.manager.maxTransfer}\")\n   85  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/UserYanker.scala:\n   37  \n   38        edgeOut.master.masters.foreach { m =>\n   39:         require (m.maxFlight.isDefined, \"UserYanker needs a flight cap on each ID\")\n   40        }\n   41  \n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Xbar.scala:\n   16    awQueueDepth:      Int = 2)(implicit p: Parameters) extends LazyModule\n   17  {\n   18:   require (maxFlightPerId >= 1)\n   19:   require (awQueueDepth >= 1)\n   20  \n   21    val node = new AXI4NexusNode(\n   ..\n   36          minLatency = seq.map(_.minLatency).min,\n   37          slaves = seq.flatMap { port =>\n   38:           require (port.beatBytes == seq(0).beatBytes,\n   39              s\"Xbar data widths don't match: ${port.slaves.map(_.name)} has ${port.beatBytes}B vs ${seq(0).slaves.map(_.name)} has ${seq(0).beatBytes}B\")\n   40            port.slaves\n   ..\n  244    }\n  245    def returnWinner[T <: Data](policy: TLArbiter.Policy)(sink: IrrevocableIO[T], sources: IrrevocableIO[T]*) = {\n  246:     require (!sources.isEmpty)\n  247  \n  248      // The arbiter is irrevocable; when !idle, repeat last request\n  ...\n  258  \n  259      // Confirm the policy works properly\n  260:     require (readys.size == valids.size)\n  261      // Never two winners\n  262      val prefixOR = winner.scanLeft(Bool(false))(_||_).init\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axis/Parameters.scala:\n   15    val nodePath:      Seq[BaseNode])\n   16  {\n   17:   require (!supportsSizes.none)\n   18:   require (destinationId >= 0)\n   19  \n   20    def v1copy(\n   ..\n   57    val beatBytes:     Option[Int])\n   58  {\n   59:   require (!slaves.isEmpty)\n   60:   beatBytes.foreach { b => require(isPow2(b)) }\n   61  \n   62    val endDestinationId = slaves.map(_.destinationId).max + 1\n   ..\n   99    val nodePath:   Seq[BaseNode])\n  100  {\n  101:   require (!emitsSizes.none)\n  102:   require (!sourceId.isEmpty)\n  103  \n  104    def v1copy(\n  ...\n  142    val beatBytes:    Option[Int])\n  143  {\n  144:   require (!masters.isEmpty)\n  145:   beatBytes.foreach { b => require(isPow2(b)) }\n  146  \n  147    val endSourceId = masters.map(_.sourceId.end).max\n  ...\n  189    val aligned:     Boolean)\n  190  {\n  191:   require (idBits >= 0)\n  192:   require (destBits >= 0)\n  193:   require (dataBits >= 8)\n  194:   require (isPow2(dataBits))\n  195  \n  196    val keepBits = dataBits/8\n  ...\n  264    val sourceInfo: SourceInfo)\n  265  {\n  266:   require (!slave.beatBytes.isEmpty || !master.beatBytes.isEmpty,\n  267      s\"Neither master nor slave port specify a bus width (insert an AXISBusBinder between them?) at ${sourceInfo}\")\n  268:   require (slave.beatBytes.isEmpty || master.beatBytes.isEmpty || slave.beatBytes == master.beatBytes,\n  269      s\"Master and slave ports specify incompatible bus widths (insert an AXISWidthWidget between them?) at ${sourceInfo}\")\n  270:   require (!slave.reqAligned || master.isAligned, s\"Slave port requires aligned stream data at ${sourceInfo}\")\n  271:   require (!slave.reqContinuous || master.isContinuous, s\"Slave port requires continuous stream data at ${sourceInfo}\")\n  272  \n  273    val beatBytes = slave.beatBytes.getOrElse(master.beatBytes.get)\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/axis/Xbar.scala:\n   14    val node = AXISNexusNode(\n   15      masterFn  = { seq =>\n   16:       seq.foreach { port => require(port.userFields == seq(0).userFields) }\n   17        seq(0).v1copy(\n   18          beatBytes = Some(beatBytes),\n   ..\n   91  \n   92        // Confirm the policy works properly\n   93:       require (readys.size == valids.size)\n   94        // Never two winners\n   95        val prefixOR = winner.scanLeft(false.B)(_||_).init\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Parameters.scala:\n   18    device: Option[Device] = None) // The device will not interleave responses (R+B)\n   19  {\n   20:   address.foreach { a => require (a.finite) }\n   21:   address.combinations(2).foreach { case Seq(x,y) => require (!x.overlaps(y), s\"$x and $y overlap\") }\n   22  \n   23    val name = nodePath.lastOption.map(_.lazyModule.name).getOrElse(\"disconnected\")\n   ..\n   27  \n   28    // The device had better not support a transfer larger than its alignment\n   29:   require (minAlignment >= maxTransfer,\n   30      s\"minAlignment ($minAlignment) must be >= maxTransfer ($maxTransfer)\")\n   31  \n   ..\n   37    minLatency: Int = 1)\n   38  {\n   39:   require (!slaves.isEmpty)\n   40:   require (isPow2(beatBytes))\n   41  \n   42    val maxTransfer = slaves.map(_.maxTransfer).max\n   ..\n   44  \n   45    // Check the link is not pointlessly wide\n   46:   require (maxTransfer >= beatBytes,\n   47      s\"maxTransfer ($maxTransfer) should not be smaller than bus width ($beatBytes)\")\n   48    // Check that the link can be implemented in Custom\n   ..\n   51    slaves.combinations(2).foreach { case Seq(x,y) =>\n   52      x.address.foreach { a => y.address.foreach { b =>\n   53:       require (!a.overlaps(b), s\"$a and $b overlap\")\n   54      } }\n   55    }\n   ..\n   62    nodePath:  Seq[BaseNode] = Seq())\n   63  {\n   64:   maxFlight.foreach { m => require (m >= 0) }\n   65  }\n   66  \n   ..\n   72    // Require disjoint ranges for ids\n   73    IdRange.overlaps(masters.map(_.id)).foreach { case (x, y) =>\n   74:     require (!x.overlaps(y), s\"CustomMasterParameters.id $x and $y overlap\")\n   75    }\n   76  }\n   ..\n   81    idBits:   Int)\n   82  {\n   83:   require (dataBits >= 8, s\"Custom data bits must be >= 8 (got $dataBits)\")\n   84:   require (addrBits >= 1, s\"Custom addr bits must be >= 1 (got $addrBits)\")\n   85:   require (idBits >= 1, s\"Custom id bits must be >= 1 (got $idBits)\")\n   86:   require (isPow2(dataBits), s\"Custom data bits must be pow2 (got $dataBits)\")\n   87  \n   88    // Bring the globals into scope\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/ToCustom.scala:\n   86  class TLToCustom(val combinational: Boolean = true, val adapterName: Option[String] = None, val stripBits: Int = 0, val wcorrupt: Boolean = true)(implicit p: Parameters) extends LazyModule\n   87  {\n   88:   require(stripBits == 0, \"stripBits > 0 is no longer supported on TLToCustom\")\n   89    val node = TLToCustomNode(wcorrupt)\n   90  \n   ..\n  117  \n  118        // We need to keep the following state from A => D: (size, source)\n  119:       // All of those fields could potentially require 0 bits (argh. Chisel.)\n  120        // We will pack all of that extra information into the echo bits.\n  121  \n  122:       require (log2Ceil(edgeIn.maxLgSize+1) <= 4)\n  123        val a_address = edgeIn.address(in.a.bits)\n  124        val a_source  = in.a.bits.source\n\n/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Xbar.scala:\n   16    awQueueDepth:      Int = 2)(implicit p: Parameters) extends LazyModule\n   17  {\n   18:   require (maxFlightPerId >= 1)\n   19:   require (awQueueDepth >= 1)\n   20  \n   21    val node = new CustomNexusNode(\n   ..\n   31          minLatency = seq.map(_.minLatency).min,\n   32          slaves = seq.flatMap { port =>\n   33:           require (port.beatBytes == seq(0).beatBytes,\n   34              s\"Xbar data widths don't match: ${port.slaves.map(_.name)} has ${port.beatBytes}B vs ${seq(0).slaves.map(_.name)} has ${seq(0).beatBytes}B\")\n   35            port.slaves\n   ..\n  239    }\n  240    def returnWinner[T <: Data](policy: TLArbiter.Policy)(sink: IrrevocableIO[T], sources: IrrevocableIO[T]*) = {\n  241:     require (!sources.isEmpty)\n  242  \n  243      // The arbiter is irrevocable; when !idle, repeat last request\n  ...\n  253  \n  254      // Confirm the policy works properly\n  255:     require (readys.size == valids.size)\n  256      // Never two winners\n  257      val prefixOR = winner.scanLeft(Bool(false))(_||_).init\n\n121 matches across 24 files\n",
			"settings":
			{
				"buffer_size": 327920,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			},
			"undo_stack":
			[
			]
		},
		{
			"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/SRAM.scala",
			"settings":
			{
				"buffer_size": 5083,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
			]
		},
		{
			"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Nodes.scala",
			"settings":
			{
				"buffer_size": 2557,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
			]
		},
		{
			"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Parameters.scala",
			"settings":
			{
				"buffer_size": 5107,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					16,
					1,
					"insert",
					{
						"characters": "\nval"
					},
					"BQAAAPwMAAAAAAAA/QwAAAAAAAAAAAAA/QwAAAAAAAD/DAAAAAAAAAAAAAD/DAAAAAAAAAANAAAAAAAAAAAAAAANAAAAAAAAAQ0AAAAAAAAAAAAAAQ0AAAAAAAACDQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA/AwAAAAAAAD8DAAAAAAAAAAAAAAAAPC/"
				],
				[
					17,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAAINAAAAAAAAAw0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAAg0AAAAAAAACDQAAAAAAAAAAAAAAAPC/"
				],
				[
					18,
					1,
					"paste",
					null,
					"AQAAAAMNAAAAAAAACw0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAAw0AAAAAAAADDQAAAAAAAAAAAAAAAPC/"
				],
				[
					19,
					1,
					"insert",
					{
						"characters": "  "
					},
					"AgAAAAsNAAAAAAAADA0AAAAAAAAAAAAADA0AAAAAAAANDQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAACw0AAAAAAAALDQAAAAAAAAAAAAAAAPC/"
				],
				[
					20,
					1,
					"left_delete",
					null,
					"AQAAAAwNAAAAAAAADA0AAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAADQ0AAAAAAAANDQAAAAAAAAAAAAAAAPC/"
				],
				[
					21,
					1,
					"insert",
					{
						"characters": "="
					},
					"AQAAAAwNAAAAAAAADQ0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADA0AAAAAAAAMDQAAAAAAAAAAAAAAAPC/"
				],
				[
					22,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAA0NAAAAAAAADg0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADQ0AAAAAAAANDQAAAAAAAAAAAAAAAPC/"
				],
				[
					23,
					1,
					"paste",
					null,
					"AQAAAA4NAAAAAAAAFg0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADg0AAAAAAAAODQAAAAAAAAAAAAAAAPC/"
				],
				[
					32,
					1,
					"paste",
					null,
					"AQAAAA4NAAAAAAAAHw0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADg0AAAAAAAAODQAAAAAAAAAAAAAAAPC/"
				],
				[
					56,
					2,
					"right_delete",
					null,
					"AgAAALYEAAAAAAAAtgQAAAAAAAA1AQAAICAvL2J5IGRvbmdkZWppIGRlZiB0b1Jlc291cmNlOiBSZXNvdXJjZUFkZHJlc3MgPSB7CiAgLy9ieSBkb25nZGVqaSAgIFJlc291cmNlQWRkcmVzcyhhZGRyZXNzLCBSZXNvdXJjZVBlcm1pc3Npb25zKAogIC8vYnkgZG9uZ2RlamkgICAgIHIgPSBzdXBwb3J0c1JlYWQsCiAgLy9ieSBkb25nZGVqaSAgICAgdyA9IHN1cHBvcnRzV3JpdGUsCiAgLy9ieSBkb25nZGVqaSAgICAgeCA9IGV4ZWN1dGFibGUsCiAgLy9ieSBkb25nZGVqaSAgICAgYyA9IGZhbHNlLAogIC8vYnkgZG9uZ2RlamkgICAgIGEgPSBmYWxzZSkpCiAgLy9ieSBkb25nZGVqaSB9tgQAAAAAAAC2BAAAAAAAAAEAAAAK",
					"AQAAAAAAAAABAAAA6wUAAAAAAAC2BAAAAAAAAAAAAAAAAPC/"
				],
				[
					107,
					1,
					"paste",
					null,
					"AgAAANgLAAAAAAAA4AsAAAAAAAAAAAAA4AsAAAAAAADgCwAAAAAAABkAAABDdXN0b21QYXJhbWV0ZXJzLmRhdGFCaXRz",
					"AQAAAAAAAAABAAAA2AsAAAAAAADxCwAAAAAAAAAAAAAAAPC/"
				],
				[
					124,
					2,
					"right_delete",
					null,
					"AgAAAMcLAAAAAAAAxwsAAAAAAAAZAAAAICB2YWwgZGF0YUJpdHMgPSBkYXRhQml0c8cLAAAAAAAAxwsAAAAAAAABAAAACg",
					"AQAAAAAAAAABAAAA4AsAAAAAAADHCwAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/SRAM.scala",
			"settings":
			{
				"buffer_size": 2478,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
			]
		},
		{
			"file": "/share/code/rocket-chip-dongdeji/src/main/scala/util/DescribedSRAM.scala",
			"settings":
			{
				"buffer_size": 1183,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
			]
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/share/code/rocket-chip-dongdeji",
		"/share/code/rocket-chip-dongdeji/src",
		"/share/code/rocket-chip-dongdeji/src/main",
		"/share/code/rocket-chip-dongdeji/src/main/scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom",
		"/share/code/rocket-chip-dongdeji/src/main/scala/unittest",
		"/share/code/rocket-chip-dongdeji/src/test"
	],
	"file_history":
	[
		"/share/code/rocket-chip-dongdeji/src/main/scala/unittest/Configs.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Xbar.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Protocol.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/ToCustom.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/devices/tilelink/TestRAM.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/util/GenericParameterizedBundle.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Bundles.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/Nodes.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Bundles.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axis/Bundles.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Filter.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Parameters.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/unittest/UnitTest.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Xbar.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Buffer.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/subsystem/BaseSubsystem.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/Resources.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/LazyModule.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Nodes.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/util/BundleMap.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/ToCustom.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Xbar.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/ToAXI4.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/PatternPusher.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/SRAM.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Protocol.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/diplomaticobjectmodel/model/OMPorts.scala",
		"/share/code/rocket-chip-dongdeji/emulator/generated-src/freechips.rocketchip.unittest.AMBAUnitTestConfig.v",
		"/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/SRAM.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Arbiter.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/stage/RocketChipOptions.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/Parameters.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Parameters.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/RAMModel.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Fuzzer.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/tilelink/Parameters.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Nodes.scala",
		"/share/code/thread/rocket-chip/src/main/scala/tilelink/Xbar.scala",
		"/share/code/thread/rocket-chip/src/main/scala/util/GenericParameterizedBundle.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/CrossingHelper.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axi4/Nodes.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/CrossingHelper.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axi4/Protocol.scala",
		"/share/code/thread/rocket-chip/src/main/scala/diplomacy/ClockDomain.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/AsyncCrossing.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/Buffer.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axis/Buffer.scala",
		"/share/code/thread/rocket-chip/src/main/scala/util/BundleMap.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/package.scala",
		"/share/code/rocket-chip-dongdeji/src/main/scala/amba/axis/Nodes.scala",
		"/share/code/thread/rocket-chip/docs/src/diplomacy/adder_tutorial.md",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axi4/Parameters.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/apb/Xbar.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axis/Xbar.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axis/Nodes.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axis/Buffer.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axis/Bundles.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axi4/Bundles.scala",
		"/share/code/thread/rocket-chip/src/main/scala/util/AsyncQueue.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/ahb/Bundles.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/package.scala",
		"/share/code/thread/rocket-chip/src/main/scala/diplomacy/Parameters.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axi4/Buffer.scala",
		"/share/code/thread/rocket-chip/src/main/scala/rocket/HellaCacheArbiter.scala",
		"/share/code/thread/rocket-chip/src/main/scala/rocket/HellaCache.scala",
		"/share/code/thread/rocket-chip/src/main/scala/tile/RocketTile.scala",
		"/share/code/thread/rocket-chip/src/main/scala/tile/LazyRoCC.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axi4/package.scala",
		"/share/code/thread/rocket-chip/src/main/scala/diplomacy/ValName.scala",
		"/share/code/thread/rocket-chip/src/main/scala/diplomacy/Nodes.scala",
		"/share/code/thread/rocket-chip/src/main/scala/amba/axi4/RegisterRouter.scala"
	],
	"find":
	{
		"height": 26.0
	},
	"find_in_files":
	{
		"height": 98.0,
		"where_history":
		[
			"/share/code/rocket-chip-dongdeji/src/main/scala/amba,<project filters>",
			"/share/code/rocket-chip-dongdeji/src/main/scala,<project filters>",
			"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom,<project filters>",
			"/share/code/rocket-chip-dongdeji/src,<project filters>",
			"/share/code/rocket-chip-dongdeji/src/main/scala,<project filters>",
			"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom,<project filters>",
			"/share/code/rocket-chip-dongdeji/src",
			"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom,<project filters>",
			"/share/code/rocket-chip-dongdeji/src/main/scala/",
			"/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom,<project filters>",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"require",
			"aqure",
			"asTypeOf",
			"Valid",
			"asTypeof",
			"cloneType",
			"==== edgeIn",
			"====",
			"mem.write",
			"Fill",
			"dataBits",
			"beatBytes",
			"dataBits",
			"CustomBundle",
			"CustomBundleParameters",
			"opcodeBits",
			"UInt",
			"BindingScope",
			"bindingTree",
			"ElaborationArtefacts",
			"respBits",
			"cacheable",
			"echoFields",
			"aligned",
			"requestKeys",
			"responseFields",
			"regionType",
			"interleavedId",
			"executable",
			"toResource",
			"executable",
			"echoFields",
			"dataBits",
			"CustomBundle",
			"respBits",
			"CustomParameters",
			"respBits",
			"protBits",
			"cacheBits",
			"burstBits",
			"RESP_DECERR",
			"RESP_SLVERR",
			"RESP_EXOKAY",
			"RESP_OKAY",
			"BURST_WRAP",
			"BURST_INCR",
			"BURST_FIXED",
			"PROT_INSTRUCTION",
			"PROT_INSECURE",
			"PROT_PRIVILEDGED",
			"CACHE_BUFFERABLE",
			"CACHE_MODIFIABLE",
			"CACHE_WALLOCATE",
			"CACHE_RALLOCATE",
			"respBits",
			"qosBits",
			"protBits",
			"cacheBits",
			"lockBits",
			"burstBits",
			"sizeBits",
			"lenBits",
			"burst",
			"size",
			"len",
			"CustomBundle",
			"CustomXbar",
			"axi4",
			"AXI4",
			"AXI4_Lite",
			"Custom_Lite",
			"axi4",
			"AXI4",
			"aQueueDepth",
			"awQueueDepth",
			"CustomArbiter",
			"AsynchronousCrossing",
			"AXI4",
			"AXI4AsyncCrossingSink",
			"axi4",
			"AXI4",
			"AXI4InwardClockCrossingHelper",
			"AXI4",
			"AXI4SlavePortParameters",
			"CustomMonitorBuilder",
			"axi4",
			"AXI4",
			"axis",
			"AXIS",
			"Irrevocable",
			"AXI4",
			"axi4",
			"AXI4",
			"Searching",
			"SimpleNodeImp",
			"ArbiterIO",
			"Arbiter",
			"RoccCommandRouter",
			"HellaCacheArbiter",
			"dcacheArb",
			"cmdRouter",
			"router"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"custom",
			"Custom",
			"custom",
			"Custom",
			"awQueueDepth",
			"aQueueDepth",
			"Custom",
			"custom",
			"Custom",
			"custom",
			"Custom",
			"custom",
			"Custom"
		],
		"reverse": false,
		"scrollbar_highlights": true,
		"show_context": true,
		"use_buffer2": true,
		"use_gitignore": true,
		"whole_word": true,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/SRAM.scala",
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4784,
						"regions":
						{
						},
						"selection":
						[
							[
								2178,
								2178
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Protocol.scala",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 325,
						"regions":
						{
						},
						"selection":
						[
							[
								282,
								282
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/share/code/rocket-chip-dongdeji/src/main/scala/util/package.scala",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12800,
						"regions":
						{
						},
						"selection":
						[
							[
								3365,
								3371
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1191.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Xbar.scala",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14500,
						"regions":
						{
						},
						"selection":
						[
							[
								14439,
								14439
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5202.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 4,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 327920,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions": "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",
								"scope": ""
							}
						},
						"selection":
						[
							[
								306592,
								306565
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 11,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 120921.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/axi4/SRAM.scala",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5083,
						"regions":
						{
						},
						"selection":
						[
							[
								3312,
								3312
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1123.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Nodes.scala",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2557,
						"regions":
						{
						},
						"selection":
						[
							[
								739,
								739
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/share/code/rocket-chip-dongdeji/src/main/scala/amba/custom/Parameters.scala",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5107,
						"regions":
						{
						},
						"selection":
						[
							[
								2555,
								2563
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1071.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/share/code/rocket-chip-dongdeji/src/main/scala/diplomacy/SRAM.scala",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2478,
						"regions":
						{
						},
						"selection":
						[
							[
								1416,
								1429
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 222.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/share/code/rocket-chip-dongdeji/src/main/scala/util/DescribedSRAM.scala",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1183,
						"regions":
						{
						},
						"selection":
						[
							[
								525,
								536
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "thread.sublime-project",
	"replace":
	{
		"height": 48.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 238.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
